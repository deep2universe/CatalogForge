This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.devcontainer/
  devcontainer.json
  Dockerfile
gradle/
  wrapper/
    gradle-wrapper.properties
scripts/
  package.json
  pdf-generator.js
  print-presets.js
src/
  main/
    java/
      com/
        catalogforge/
          agent/
            steps/
              ImageAnalysisStep.java
              LayoutGenerationStep.java
              PromptAssemblyStep.java
              ValidationStep.java
            strategies/
              ComplexLayoutStrategy.java
              MultiVariantStrategy.java
              SimpleLayoutStrategy.java
            AgentContext.java
            AgentOrchestrator.java
            AgentStep.java
            CorrectionStep.java
            FallbackStep.java
            IterativePipeline.java
            LinearPipeline.java
            ParallelPipeline.java
            Pipeline.java
            PipelineStrategy.java
          config/
            properties/
              GeminiProperties.java
              ImageProperties.java
              LayoutProperties.java
              LoggingProperties.java
              PuppeteerProperties.java
              SkillsProperties.java
            GeminiConfig.java
            LoggingConfig.java
            SkillsConfig.java
            WebConfig.java
          controller/
            ImageController.java
            LayoutController.java
            PdfController.java
            ProductController.java
            SkillsController.java
          exception/
            CatalogForgeException.java
            GlobalExceptionHandler.java
            ImageAnalysisException.java
            ImageUploadException.java
            ImageUrlNotReachableException.java
            LayoutGenerationException.java
            PdfGenerationException.java
            ResourceNotFoundException.java
            SkillLoadException.java
          gemini/
            GeminiClient.java
            GeminiModelSelector.java
            GeminiRequest.java
            GeminiResponse.java
            GeminiVisionAnalyzer.java
          logging/
            LlmInteractionLogger.java
            LlmLogEntry.java
            LlmLogWriter.java
          model/
            request/
              ImageLayoutOptions.java
              ImageToLayoutRequest.java
              LayoutOptions.java
              LayoutUpdateRequest.java
              PdfGenerationRequest.java
              TextToLayoutRequest.java
            response/
              ErrorResponse.java
              ImageUploadResponse.java
              LayoutResponse.java
              PdfResponse.java
              ProductListResponse.java
            ColorPalette.java
            ImageAnalysisResult.java
            Layout.java
            LayoutHints.java
            LayoutMetadata.java
            LayoutVariant.java
            MoodAnalysis.java
            PageFormat.java
            Product.java
            Skill.java
            TechnicalData.java
          pdf/
            PdfOptions.java
            PrintPreset.java
            PuppeteerBridge.java
          service/
            ImageService.java
            LayoutGenerationService.java
            PdfGenerationService.java
            ProductService.java
            SkillsService.java
          skill/
            SkillAssembler.java
            SkillLoader.java
          util/
            ColorUtils.java
            CssValidator.java
            FileUtils.java
            HtmlSanitizer.java
            JsonUtils.java
          CatalogForgeApplication.java
    resources/
      css/
        components/
          feature-list.css
          product-card.css
          spec-table.css
        print/
          print-base.css
          print-bleed.css
          print-crop-marks.css
        .gitkeep
        reset.css
        typography.css
        utilities.css
        variables.css
      data/
        .gitkeep
        products.json
      prompts/
        .gitkeep
        example-prompts.json
      skills/
        core/
          COLOR_THEORY.md
          GRID_SYSTEMS.md
          LAYOUT_PRINCIPLES.md
          MASTER_SKILL.md
          SPACING.md
          TYPOGRAPHY.md
        formats/
          FORMAT_A4.md
          FORMAT_A5.md
          FORMAT_A6.md
          FORMAT_DL.md
          FORMAT_SQUARE.md
        styles/
          STYLE_DYNAMIC.md
          STYLE_ECO.md
          STYLE_MODERN.md
          STYLE_PREMIUM.md
          STYLE_TECHNICAL.md
        .gitkeep
      templates/
        .gitkeep
      application.yml
  test/
    java/
      com/
        catalogforge/
          agent/
            AgentFrameworkTest.java
          controller/
            ProductControllerTest.java
            SkillsControllerTest.java
          exception/
            ErrorResponsePropertyTest.java
          gemini/
            GeminiModelSelectorTest.java
            GeminiRequestTest.java
            GeminiVisionAnalyzerTest.java
          logging/
            LlmLoggingTest.java
          service/
            ImageServiceTest.java
            ProductServiceTest.java
          skill/
            SkillAssemblerTest.java
            SkillLoaderTest.java
          util/
            ColorUtilsPropertyTest.java
            CssValidatorPropertyTest.java
            HtmlSanitizerPropertyTest.java
          CatalogForgeApplicationTest.java
    resources/
      fixtures/
        gemini/
          error-response.json
          image-analysis-dynamic.json
          image-analysis-premium.json
          layout-simple.json
          layout-with-specs.json
        gemini-responses/
          .gitkeep
      application-test.yml
.env.example
.gitignore
build.gradle.kts
daimler_truck_katalog_schema_dokumentation.md
daimler_truck_katalog_schema.json
dummy-katalog-data.json
gradle.properties
gradlew
gradlew.bat
README.md
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".devcontainer/devcontainer.json">
{
  "name": "CatalogForge Backend",
  "build": {
    "dockerfile": "Dockerfile"
  },
  "features": {
    "ghcr.io/devcontainers/features/git:1": {}
  },
  "forwardPorts": [8080],
  "portsAttributes": {
    "8080": {
      "label": "CatalogForge API",
      "onAutoForward": "notify"
    }
  },
  "customizations": {
    "vscode": {
      "extensions": [
        "vscjava.vscode-java-pack",
        "vmware.vscode-spring-boot",
        "vscjava.vscode-spring-initializr",
        "vscjava.vscode-spring-boot-dashboard",
        "vscjava.vscode-gradle",
        "redhat.vscode-yaml",
        "esbenp.prettier-vscode"
      ],
      "settings": {
        "java.configuration.updateBuildConfiguration": "automatic",
        "java.compile.nullAnalysis.mode": "automatic",
        "java.format.settings.profile": "GoogleStyle",
        "editor.formatOnSave": true,
        "editor.tabSize": 4,
        "files.trimTrailingWhitespace": true,
        "terminal.integrated.defaultProfile.linux": "zsh"
      }
    }
  },
  "postCreateCommand": "cd scripts && npm install && cd .. && chmod +x gradlew && ./gradlew dependencies --no-daemon",
  "postStartCommand": "echo '✅ CatalogForge Backend ready! Run: ./gradlew bootRun'",
  "remoteEnv": {
    "GEMINI_API_KEY": "${localEnv:GEMINI_API_KEY}",
    "PUPPETEER_SKIP_CHROMIUM_DOWNLOAD": "true",
    "PUPPETEER_EXECUTABLE_PATH": "/usr/bin/chromium"
  },
  "mounts": [
    "source=${localWorkspaceFolder}/.gradle-cache,target=/home/vscode/.gradle,type=bind,consistency=cached"
  ],
  "initializeCommand": "mkdir -p .gradle-cache"
}
</file>

<file path=".devcontainer/Dockerfile">
# CatalogForge Backend Dev Container
# Java 21 + Node.js 20 + Chromium for Puppeteer

FROM mcr.microsoft.com/devcontainers/java:21-bookworm

# Install Node.js 20 LTS
RUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - \
    && apt-get install -y nodejs \
    && npm install -g npm@latest

# Install Chromium and dependencies for Puppeteer
RUN apt-get update && apt-get install -y \
    chromium \
    fonts-liberation \
    fonts-noto-color-emoji \
    fonts-noto-cjk \
    libasound2 \
    libatk-bridge2.0-0 \
    libatk1.0-0 \
    libcups2 \
    libdrm2 \
    libgbm1 \
    libnss3 \
    libxcomposite1 \
    libxdamage1 \
    libxfixes3 \
    libxkbcommon0 \
    libxrandr2 \
    --no-install-recommends \
    && rm -rf /var/lib/apt/lists/*

# Configure Puppeteer to use system Chromium
ENV PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
ENV PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium

# Set Gradle user home for caching
ENV GRADLE_USER_HOME=/home/vscode/.gradle
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="scripts/package.json">
{
  "name": "catalogforge-pdf-generator",
  "version": "1.0.0",
  "description": "PDF generator for CatalogForge using Puppeteer",
  "main": "pdf-generator.js",
  "scripts": {
    "generate": "node pdf-generator.js"
  },
  "dependencies": {
    "puppeteer": "^21.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path="scripts/pdf-generator.js">
#!/usr/bin/env node

/**
 * PDF Generator using Puppeteer.
 * Reads JSON input from stdin, generates PDF, outputs JSON result to stdout.
 * 
 * Input JSON:
 * {
 *   "html": "<html>...</html>",
 *   "css": "body { ... }",
 *   "preset": "screen|print-standard|print-professional|print-premium",
 *   "pageFormat": "A4|A5|DL|...",
 *   "landscape": false,
 *   "dpi": 300,
 *   "bleedMm": 3,
 *   "cropMarks": true
 * }
 * 
 * Output JSON:
 * {
 *   "success": true,
 *   "pdfPath": "/path/to/output.pdf"
 * }
 */

const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { getPreset, getPageFormat, getPageWithBleed } = require('./print-presets');

/**
 * Reads JSON input from stdin.
 */
async function readInput() {
    return new Promise((resolve, reject) => {
        let data = '';
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', chunk => data += chunk);
        process.stdin.on('end', () => {
            try {
                resolve(JSON.parse(data));
            } catch (e) {
                reject(new Error('Invalid JSON input: ' + e.message));
            }
        });
        process.stdin.on('error', reject);
    });
}

/**
 * Generates crop marks SVG.
 */
function generateCropMarks(width, height, bleed) {
    const markLength = 10;
    const markOffset = 3;
    
    return `
        <svg class="crop-marks" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;">
            <!-- Top-left -->
            <line x1="${bleed - markOffset}mm" y1="${bleed}mm" x2="${bleed - markOffset - markLength}mm" y2="${bleed}mm" stroke="black" stroke-width="0.25"/>
            <line x1="${bleed}mm" y1="${bleed - markOffset}mm" x2="${bleed}mm" y2="${bleed - markOffset - markLength}mm" stroke="black" stroke-width="0.25"/>
            
            <!-- Top-right -->
            <line x1="${width - bleed + markOffset}mm" y1="${bleed}mm" x2="${width - bleed + markOffset + markLength}mm" y2="${bleed}mm" stroke="black" stroke-width="0.25"/>
            <line x1="${width - bleed}mm" y1="${bleed - markOffset}mm" x2="${width - bleed}mm" y2="${bleed - markOffset - markLength}mm" stroke="black" stroke-width="0.25"/>
            
            <!-- Bottom-left -->
            <line x1="${bleed - markOffset}mm" y1="${height - bleed}mm" x2="${bleed - markOffset - markLength}mm" y2="${height - bleed}mm" stroke="black" stroke-width="0.25"/>
            <line x1="${bleed}mm" y1="${height - bleed + markOffset}mm" x2="${bleed}mm" y2="${height - bleed + markOffset + markLength}mm" stroke="black" stroke-width="0.25"/>
            
            <!-- Bottom-right -->
            <line x1="${width - bleed + markOffset}mm" y1="${height - bleed}mm" x2="${width - bleed + markOffset + markLength}mm" y2="${height - bleed}mm" stroke="black" stroke-width="0.25"/>
            <line x1="${width - bleed}mm" y1="${height - bleed + markOffset}mm" x2="${width - bleed}mm" y2="${height - bleed + markOffset + markLength}mm" stroke="black" stroke-width="0.25"/>
        </svg>
    `;
}

/**
 * Builds the full HTML document.
 */
function buildHtmlDocument(input) {
    const preset = getPreset(input.preset);
    const bleed = input.bleedMm || preset.bleedMm || 0;
    const pageSize = getPageWithBleed(input.pageFormat, bleed);
    
    let cropMarksHtml = '';
    if (input.cropMarks || preset.cropMarks) {
        cropMarksHtml = generateCropMarks(pageSize.width, pageSize.height, bleed);
    }
    
    return `
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CatalogForge PDF</title>
    <style>
        @page {
            size: ${pageSize.width}mm ${pageSize.height}mm;
            margin: 0;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: ${pageSize.width}mm;
            height: ${pageSize.height}mm;
        }
        
        .pdf-container {
            position: relative;
            width: 100%;
            height: 100%;
            padding: ${bleed}mm;
        }
        
        .pdf-content {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        ${input.css || ''}
    </style>
</head>
<body>
    <div class="pdf-container">
        ${cropMarksHtml}
        <div class="pdf-content">
            ${input.html || ''}
        </div>
    </div>
</body>
</html>
    `;
}

/**
 * Main PDF generation function.
 */
async function generatePdf(input) {
    const preset = getPreset(input.preset);
    const pageSize = getPageWithBleed(input.pageFormat, input.bleedMm || preset.bleedMm || 0);
    
    // Generate output path
    const outputDir = path.join(os.tmpdir(), 'catalogforge-pdf');
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    const outputPath = path.join(outputDir, `pdf-${Date.now()}-${Math.random().toString(36).substr(2, 9)}.pdf`);
    
    // Launch browser
    const browser = await puppeteer.launch({
        headless: 'new',
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    try {
        const page = await browser.newPage();
        
        // Set viewport for high DPI
        const dpi = input.dpi || preset.dpi || 72;
        const scale = dpi / 72;
        
        await page.setViewport({
            width: Math.round(pageSize.width * 3.78 * scale), // mm to px at 96dpi * scale
            height: Math.round(pageSize.height * 3.78 * scale),
            deviceScaleFactor: scale
        });
        
        // Load HTML content
        const htmlContent = buildHtmlDocument(input);
        await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
        
        // Generate PDF
        await page.pdf({
            path: outputPath,
            width: `${pageSize.width}mm`,
            height: `${pageSize.height}mm`,
            printBackground: preset.printBackground,
            preferCSSPageSize: preset.preferCSSPageSize,
            landscape: input.landscape || false,
            margin: { top: 0, right: 0, bottom: 0, left: 0 }
        });
        
        return {
            success: true,
            pdfPath: outputPath,
            preset: preset.name,
            pageFormat: input.pageFormat,
            dimensions: pageSize
        };
        
    } finally {
        await browser.close();
    }
}

/**
 * Main entry point.
 */
async function main() {
    try {
        const input = await readInput();
        const result = await generatePdf(input);
        console.log(JSON.stringify(result));
        process.exit(0);
    } catch (error) {
        console.error(JSON.stringify({
            success: false,
            error: error.message
        }));
        process.exit(1);
    }
}

main();
</file>

<file path="scripts/print-presets.js">
/**
 * Print presets for PDF generation.
 * Defines quality settings for different output purposes.
 */

const PRESETS = {
    'screen': {
        name: 'screen',
        description: 'Screen viewing',
        dpi: 72,
        bleedMm: 0,
        cropMarks: false,
        printBackground: true,
        preferCSSPageSize: true
    },
    'print-standard': {
        name: 'print-standard',
        description: 'Standard office printing',
        dpi: 150,
        bleedMm: 0,
        cropMarks: false,
        printBackground: true,
        preferCSSPageSize: true
    },
    'print-professional': {
        name: 'print-professional',
        description: 'Professional printing',
        dpi: 300,
        bleedMm: 3,
        cropMarks: true,
        printBackground: true,
        preferCSSPageSize: true
    },
    'print-premium': {
        name: 'print-premium',
        description: 'Premium printing with bleed',
        dpi: 300,
        bleedMm: 5,
        cropMarks: true,
        printBackground: true,
        preferCSSPageSize: true
    }
};

/**
 * Page format dimensions in mm.
 */
const PAGE_FORMATS = {
    'A4': { width: 210, height: 297 },
    'A5': { width: 148, height: 210 },
    'A6': { width: 105, height: 148 },
    'DL': { width: 99, height: 210 },
    'square': { width: 210, height: 210 },
    'letter': { width: 216, height: 279 }
};

/**
 * Gets a preset by name.
 * @param {string} name - Preset name
 * @returns {object} Preset configuration
 */
function getPreset(name) {
    return PRESETS[name] || PRESETS['screen'];
}

/**
 * Gets page format dimensions.
 * @param {string} format - Format name
 * @returns {object} Width and height in mm
 */
function getPageFormat(format) {
    return PAGE_FORMATS[format] || PAGE_FORMATS['A4'];
}

/**
 * Calculates page dimensions with bleed.
 * @param {string} format - Format name
 * @param {number} bleedMm - Bleed in mm
 * @returns {object} Total width and height including bleed
 */
function getPageWithBleed(format, bleedMm) {
    const base = getPageFormat(format);
    return {
        width: base.width + (bleedMm * 2),
        height: base.height + (bleedMm * 2)
    };
}

module.exports = {
    PRESETS,
    PAGE_FORMATS,
    getPreset,
    getPageFormat,
    getPageWithBleed
};
</file>

<file path="src/main/java/com/catalogforge/agent/steps/ImageAnalysisStep.java">
package com.catalogforge.agent.steps;

import com.catalogforge.agent.AgentContext;
import com.catalogforge.agent.AgentStep;
import com.catalogforge.gemini.GeminiVisionAnalyzer;
import com.catalogforge.model.ColorPalette;
import com.catalogforge.model.ImageAnalysisResult;
import com.catalogforge.model.LayoutHints;
import com.catalogforge.model.MoodAnalysis;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * Analyzes reference images using Gemini Vision.
 * Extracts color palette, mood, and layout hints.
 */
@Component
public class ImageAnalysisStep implements AgentStep {

    private static final Logger log = LoggerFactory.getLogger(ImageAnalysisStep.class);

    private final GeminiVisionAnalyzer visionAnalyzer;

    public ImageAnalysisStep(GeminiVisionAnalyzer visionAnalyzer) {
        this.visionAnalyzer = visionAnalyzer;
    }

    @Override
    public AgentContext execute(AgentContext context) {
        if (!context.hasImage()) {
            log.debug("No image to analyze, skipping ImageAnalysisStep");
            return context;
        }
        
        log.debug("Analyzing image for pipeline: {}", context.pipelineId());
        
        try {
            ImageAnalysisResult result = visionAnalyzer.analyzeImage(
                    context.imageBase64(),
                    context.imageMimeType()
            );
            
            log.debug("Image analysis completed: mood={}, colors extracted", 
                    result.mood().type());
            
            return context.withImageAnalysis(result);
            
        } catch (Exception e) {
            log.warn("Image analysis failed, using placeholder: {}", e.getMessage());
            return context.withImageAnalysis(createPlaceholderAnalysis());
        }
    }

    private ImageAnalysisResult createPlaceholderAnalysis() {
        return new ImageAnalysisResult(
                new ColorPalette("#333333", "#666666", "#0066CC", "#F5F5F5", "#1A1A1A"),
                new MoodAnalysis("professional", 0.7, List.of("clean", "modern")),
                new LayoutHints("modular", "medium", "center", 2)
        );
    }

    @Override
    public String name() {
        return "ImageAnalysis";
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/steps/LayoutGenerationStep.java">
package com.catalogforge.agent.steps;

import com.catalogforge.agent.AgentContext;
import com.catalogforge.agent.AgentStep;
import com.catalogforge.gemini.GeminiClient;
import com.catalogforge.gemini.GeminiModelSelector;
import com.catalogforge.gemini.GeminiRequest;
import com.catalogforge.gemini.GeminiResponse;
import com.catalogforge.logging.LlmInteractionLogger;
import com.catalogforge.model.Layout;
import com.catalogforge.model.LayoutMetadata;
import com.catalogforge.model.LayoutVariant;
import com.catalogforge.model.PageFormat;
import com.catalogforge.util.JsonUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * Generates layout HTML/CSS using the Gemini API.
 */
@Component
public class LayoutGenerationStep implements AgentStep {

    private static final Logger log = LoggerFactory.getLogger(LayoutGenerationStep.class);

    private final GeminiClient geminiClient;
    private final LlmInteractionLogger llmLogger;

    public LayoutGenerationStep(GeminiClient geminiClient, LlmInteractionLogger llmLogger) {
        this.geminiClient = geminiClient;
        this.llmLogger = llmLogger;
    }

    @Override
    public AgentContext execute(AgentContext context) {
        log.debug("Generating layout for pipeline: {}", context.pipelineId());
        
        String model = selectModel(context);
        String requestId = llmLogger.generateRequestId();
        
        GeminiRequest request = buildRequest(context);
        
        llmLogger.logRequest(requestId, model, "/v1beta/models/" + model + ":generateContent", 
                summarizePrompt(context.assembledPrompt()));
        
        try {
            GeminiResponse response = geminiClient.generate(model, request);
            llmLogger.logResponse(requestId, model, response);
            
            Layout layout = parseLayoutResponse(response, context);
            return context.withGeneratedLayout(layout);
            
        } catch (Exception e) {
            llmLogger.logError(requestId, model, e);
            throw e;
        }
    }

    private String selectModel(AgentContext context) {
        if (context.options() != null && context.options().complexStrategy()) {
            return GeminiModelSelector.forComplexLayout();
        }
        return GeminiModelSelector.forSimpleLayout();
    }

    private GeminiRequest buildRequest(AgentContext context) {
        return GeminiRequest.builder()
                .systemInstruction(SYSTEM_INSTRUCTION)
                .userPrompt(context.assembledPrompt())
                .responseSchema(LAYOUT_RESPONSE_SCHEMA)
                .temperature(0.7)
                .build();
    }

    private Layout parseLayoutResponse(GeminiResponse response, AgentContext context) {
        String json = response.getText();
        if (json == null || json.isBlank()) {
            log.warn("Empty response from layout generation");
            return createFallbackLayout(context);
        }
        
        try {
            Map<String, Object> data = JsonUtils.fromJson(json, new TypeReference<>() {});
            
            String html = (String) data.getOrDefault("html", "<div>Layout generation failed</div>");
            String css = (String) data.getOrDefault("css", "");
            
            LayoutVariant variant = new LayoutVariant(
                    UUID.randomUUID().toString(),
                    html,
                    css
            );
            
            String format = context.options() != null ? context.options().pageFormat() : "A4";
            PageFormat pageFormat = new PageFormat(format, 210, 297, "mm");
            
            LayoutMetadata metadata = new LayoutMetadata(
                    List.of(), // skillsUsed
                    0L,        // generationTimeMs - will be set later
                    1          // llmCallCount
            );
            
            return new Layout(
                    UUID.randomUUID().toString(),
                    "completed",
                    Instant.now(),
                    pageFormat,
                    context.imageAnalysis(),
                    List.of(variant),
                    metadata
            );
            
        } catch (Exception e) {
            log.error("Failed to parse layout response", e);
            return createFallbackLayout(context);
        }
    }

    private Layout createFallbackLayout(AgentContext context) {
        String productNames = context.products() != null 
                ? context.products().stream()
                    .map(p -> p.name())
                    .reduce((a, b) -> a + ", " + b)
                    .orElse("Products")
                : "Products";
        
        String html = String.format("""
                <div class="fallback-layout">
                    <h1>%s</h1>
                    <p>Layout generation encountered an issue. Please try again.</p>
                </div>
                """, productNames);
        
        String css = """
                .fallback-layout {
                    padding: 2rem;
                    text-align: center;
                    font-family: system-ui, sans-serif;
                }
                """;
        
        LayoutVariant variant = new LayoutVariant(UUID.randomUUID().toString(), html, css);
        PageFormat pageFormat = new PageFormat("A4", 210, 297, "mm");
        
        return new Layout(
                UUID.randomUUID().toString(),
                "fallback",
                Instant.now(),
                pageFormat,
                null,
                List.of(variant),
                new LayoutMetadata(List.of(), 0L, 0)
        );
    }

    private String summarizePrompt(String prompt) {
        if (prompt == null) return "";
        return prompt.length() > 100 ? prompt.substring(0, 100) + "..." : prompt;
    }

    @Override
    public String name() {
        return "LayoutGeneration";
    }

    private static final String SYSTEM_INSTRUCTION = """
        You are a professional layout designer. Generate clean, semantic HTML and CSS 
        for product catalogs and marketing materials. Follow these principles:
        - Use semantic HTML5 elements
        - Create responsive, print-ready layouts
        - Apply consistent spacing and typography
        - Ensure accessibility compliance
        - Output valid JSON with 'html', 'css', and 'title' fields
        """;

    private static final Map<String, Object> LAYOUT_RESPONSE_SCHEMA = Map.of(
            "type", "object",
            "properties", Map.of(
                    "html", Map.of("type", "string", "description", "The generated HTML markup"),
                    "css", Map.of("type", "string", "description", "The generated CSS styles"),
                    "title", Map.of("type", "string", "description", "A title for the layout")
            ),
            "required", java.util.List.of("html", "css", "title")
    );
}
</file>

<file path="src/main/java/com/catalogforge/agent/steps/PromptAssemblyStep.java">
package com.catalogforge.agent.steps;

import com.catalogforge.agent.AgentContext;
import com.catalogforge.agent.AgentStep;
import com.catalogforge.model.Product;
import com.catalogforge.service.SkillsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * Assembles the complete prompt from skills and product data.
 */
@Component
public class PromptAssemblyStep implements AgentStep {

    private static final Logger log = LoggerFactory.getLogger(PromptAssemblyStep.class);

    private final SkillsService skillsService;

    public PromptAssemblyStep(SkillsService skillsService) {
        this.skillsService = skillsService;
    }

    @Override
    public AgentContext execute(AgentContext context) {
        log.debug("Assembling prompt for pipeline: {}", context.pipelineId());
        
        // Assemble skills based on options
        String style = context.options() != null ? context.options().style() : null;
        String format = context.options() != null ? context.options().pageFormat() : null;
        String skillsContent = skillsService.assemblePrompt(List.of(), style, format);
        
        // Build product data section
        String productData = buildProductDataSection(context);
        
        // Build user instructions section
        String userInstructions = buildUserInstructionsSection(context);
        
        // Build image analysis section if available
        String imageSection = buildImageAnalysisSection(context);
        
        // Combine all sections
        String assembledPrompt = String.join("\n\n",
                skillsContent,
                productData,
                imageSection,
                userInstructions
        ).trim();
        
        log.debug("Assembled prompt length: {} chars", assembledPrompt.length());
        
        return context.withAssembledPrompt(assembledPrompt);
    }

    private String buildProductDataSection(AgentContext context) {
        if (context.products() == null || context.products().isEmpty()) {
            return "";
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append("## Product Data\n\n");
        
        for (Product product : context.products()) {
            sb.append("### ").append(product.name()).append("\n");
            sb.append("- ID: ").append(product.id()).append("\n");
            sb.append("- Category: ").append(product.category()).append("\n");
            sb.append("- Series: ").append(product.series()).append("\n");
            
            if (product.shortDescription() != null) {
                sb.append("- Short Description: ").append(product.shortDescription()).append("\n");
            }
            if (product.description() != null) {
                sb.append("- Description: ").append(product.description()).append("\n");
            }
            if (product.priceEur() != null) {
                sb.append("- Price: €").append(product.priceEur()).append("\n");
            }
            if (product.highlights() != null && !product.highlights().isEmpty()) {
                sb.append("- Highlights: ").append(String.join(", ", product.highlights())).append("\n");
            }
            if (product.specs() != null && !product.specs().specifications().isEmpty()) {
                sb.append("- Technical Data:\n");
                product.specs().specifications().forEach((key, value) -> 
                    sb.append("  - ").append(key).append(": ").append(value).append("\n")
                );
            }
            if (product.imageUrl() != null) {
                sb.append("- Image: ").append(product.imageUrl()).append("\n");
            }
            sb.append("\n");
        }
        
        return sb.toString();
    }

    private String buildUserInstructionsSection(AgentContext context) {
        if (context.userPrompt() == null || context.userPrompt().isBlank()) {
            return "";
        }
        
        return "## User Instructions\n\n" + context.userPrompt();
    }

    private String buildImageAnalysisSection(AgentContext context) {
        if (context.imageAnalysis() == null) {
            return "";
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append("## Reference Image Analysis\n\n");
        
        var palette = context.imageAnalysis().colorPalette();
        if (palette != null) {
            sb.append("### Color Palette\n");
            sb.append("- Primary: ").append(palette.primary()).append("\n");
            sb.append("- Secondary: ").append(palette.secondary()).append("\n");
            sb.append("- Accent: ").append(palette.accent()).append("\n");
            sb.append("- Neutral Light: ").append(palette.neutralLight()).append("\n");
            sb.append("- Neutral Dark: ").append(palette.neutralDark()).append("\n\n");
        }
        
        var mood = context.imageAnalysis().mood();
        if (mood != null) {
            sb.append("### Mood Analysis\n");
            sb.append("- Type: ").append(mood.type()).append("\n");
            sb.append("- Confidence: ").append(mood.confidence()).append("\n");
            if (mood.keywords() != null && !mood.keywords().isEmpty()) {
                sb.append("- Keywords: ").append(String.join(", ", mood.keywords())).append("\n");
            }
            sb.append("\n");
        }
        
        var hints = context.imageAnalysis().layoutHints();
        if (hints != null) {
            sb.append("### Layout Hints\n");
            sb.append("- Grid Type: ").append(hints.gridType()).append("\n");
            sb.append("- Density: ").append(hints.density()).append("\n");
            sb.append("- Focus Area: ").append(hints.focusArea()).append("\n");
            sb.append("- Suggested Columns: ").append(hints.suggestedColumns()).append("\n");
        }
        
        return sb.toString();
    }

    @Override
    public String name() {
        return "PromptAssembly";
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/steps/ValidationStep.java">
package com.catalogforge.agent.steps;

import com.catalogforge.agent.AgentContext;
import com.catalogforge.agent.AgentStep;
import com.catalogforge.model.LayoutVariant;
import com.catalogforge.util.CssValidator;
import com.catalogforge.util.HtmlSanitizer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

/**
 * Validates and sanitizes the generated layout.
 */
@Component
public class ValidationStep implements AgentStep {

    private static final Logger log = LoggerFactory.getLogger(ValidationStep.class);

    @Override
    public AgentContext execute(AgentContext context) {
        log.debug("Validating layout for pipeline: {}", context.pipelineId());
        
        if (context.generatedLayout() == null) {
            return context.withValidationErrors(List.of("No layout generated"));
        }
        
        List<String> errors = new ArrayList<>();
        
        // Validate each variant
        List<LayoutVariant> variants = context.generatedLayout().variants();
        if (variants == null || variants.isEmpty()) {
            errors.add("No layout variants generated");
        } else {
            for (int i = 0; i < variants.size(); i++) {
                LayoutVariant variant = variants.get(i);
                validateVariant(variant, i, errors);
            }
        }
        
        if (!errors.isEmpty()) {
            log.warn("Layout validation found {} errors: {}", errors.size(), errors);
        } else {
            log.debug("Layout validation passed");
        }
        
        return context.withValidationErrors(errors);
    }

    private void validateVariant(LayoutVariant variant, int index, List<String> errors) {
        String prefix = "Variant " + index + ": ";
        
        // Validate HTML
        String html = variant.html();
        if (html == null || html.isBlank()) {
            errors.add(prefix + "HTML content is empty");
        } else {
            // Sanitize HTML
            String sanitized = HtmlSanitizer.sanitize(html);
            if (!sanitized.equals(html)) {
                log.debug("{}HTML was sanitized - potentially unsafe content removed", prefix);
            }
            
            // Check for minimum content
            if (html.length() < 50) {
                errors.add(prefix + "HTML content is too short - may be incomplete");
            }
        }
        
        // Validate CSS
        String css = variant.css();
        if (css != null && !css.isBlank()) {
            if (!CssValidator.hasBalancedBrackets(css)) {
                errors.add(prefix + "CSS has unbalanced brackets");
            }
        }
    }

    @Override
    public String name() {
        return "Validation";
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/strategies/ComplexLayoutStrategy.java">
package com.catalogforge.agent.strategies;

import com.catalogforge.agent.AgentContext;
import com.catalogforge.agent.IterativePipeline;
import com.catalogforge.agent.Pipeline;
import com.catalogforge.agent.PipelineStrategy;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

/**
 * Strategy for complex layouts requiring validation and correction.
 * Uses IterativePipeline with retry logic.
 */
@Component
@Order(20) // Higher priority than simple
public class ComplexLayoutStrategy implements PipelineStrategy {

    private final IterativePipeline iterativePipeline;

    public ComplexLayoutStrategy(IterativePipeline iterativePipeline) {
        this.iterativePipeline = iterativePipeline;
    }

    @Override
    public Pipeline getPipeline() {
        return iterativePipeline;
    }

    @Override
    public String name() {
        return "ComplexLayout";
    }

    @Override
    public boolean matches(AgentContext context) {
        if (context.options() == null) {
            return false;
        }
        
        // Use iterative pipeline for complex strategy or when specs are included
        return context.options().complexStrategy() || context.options().includeSpecs();
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/strategies/MultiVariantStrategy.java">
package com.catalogforge.agent.strategies;

import com.catalogforge.agent.AgentContext;
import com.catalogforge.agent.ParallelPipeline;
import com.catalogforge.agent.Pipeline;
import com.catalogforge.agent.PipelineStrategy;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

/**
 * Strategy for generating multiple layout variants in parallel.
 * Uses ParallelPipeline for concurrent generation.
 */
@Component
@Order(10) // Highest priority
public class MultiVariantStrategy implements PipelineStrategy {

    private final ParallelPipeline parallelPipeline;

    public MultiVariantStrategy(ParallelPipeline parallelPipeline) {
        this.parallelPipeline = parallelPipeline;
    }

    @Override
    public Pipeline getPipeline() {
        return parallelPipeline;
    }

    @Override
    public String name() {
        return "MultiVariant";
    }

    @Override
    public boolean matches(AgentContext context) {
        return context.isMultiVariant();
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/strategies/SimpleLayoutStrategy.java">
package com.catalogforge.agent.strategies;

import com.catalogforge.agent.AgentContext;
import com.catalogforge.agent.LinearPipeline;
import com.catalogforge.agent.Pipeline;
import com.catalogforge.agent.PipelineStrategy;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

/**
 * Strategy for simple, single-variant layout generation.
 * Uses LinearPipeline for straightforward generation.
 */
@Component
@Order(100) // Lower priority - fallback strategy
public class SimpleLayoutStrategy implements PipelineStrategy {

    private final LinearPipeline linearPipeline;

    public SimpleLayoutStrategy(LinearPipeline linearPipeline) {
        this.linearPipeline = linearPipeline;
    }

    @Override
    public Pipeline getPipeline() {
        return linearPipeline;
    }

    @Override
    public String name() {
        return "SimpleLayout";
    }

    @Override
    public boolean matches(AgentContext context) {
        // Default strategy - matches everything
        return true;
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/AgentContext.java">
package com.catalogforge.agent;

import com.catalogforge.model.*;
import com.catalogforge.model.request.LayoutOptions;

import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * Immutable context passed through the agent pipeline.
 * Contains all data needed for layout generation.
 */
public record AgentContext(
    String pipelineId,
    String requestId,
    
    // Input data
    List<Product> products,
    LayoutOptions options,
    String userPrompt,
    
    // Image analysis (optional)
    String imageBase64,
    String imageMimeType,
    ImageAnalysisResult imageAnalysis,
    
    // Assembled prompt
    String assembledPrompt,
    
    // Generated output
    Layout generatedLayout,
    List<LayoutVariant> variants,
    
    // Validation state
    List<String> validationErrors,
    int retryCount,
    
    // Metadata
    Map<String, Object> metadata
) {
    
    /**
     * Creates a new context for text-to-layout generation.
     */
    public static AgentContext forTextGeneration(
            List<Product> products,
            LayoutOptions options,
            String userPrompt
    ) {
        return new AgentContext(
                UUID.randomUUID().toString(),
                UUID.randomUUID().toString(),
                products,
                options != null ? options : LayoutOptions.defaults(),
                userPrompt,
                null, null, null,
                null,
                null, List.of(),
                List.of(), 0,
                Map.of()
        );
    }
    
    /**
     * Creates a new context for image-to-layout generation.
     */
    public static AgentContext forImageGeneration(
            List<Product> products,
            LayoutOptions options,
            String userPrompt,
            String imageBase64,
            String imageMimeType
    ) {
        return new AgentContext(
                UUID.randomUUID().toString(),
                UUID.randomUUID().toString(),
                products,
                options != null ? options : LayoutOptions.defaults(),
                userPrompt,
                imageBase64, imageMimeType, null,
                null,
                null, List.of(),
                List.of(), 0,
                Map.of()
        );
    }
    
    /**
     * Returns a copy with the assembled prompt set.
     */
    public AgentContext withAssembledPrompt(String prompt) {
        return new AgentContext(
                pipelineId, requestId, products, options, userPrompt,
                imageBase64, imageMimeType, imageAnalysis,
                prompt,
                generatedLayout, variants,
                validationErrors, retryCount, metadata
        );
    }
    
    /**
     * Returns a copy with the image analysis result set.
     */
    public AgentContext withImageAnalysis(ImageAnalysisResult analysis) {
        return new AgentContext(
                pipelineId, requestId, products, options, userPrompt,
                imageBase64, imageMimeType, analysis,
                assembledPrompt,
                generatedLayout, variants,
                validationErrors, retryCount, metadata
        );
    }
    
    /**
     * Returns a copy with the generated layout set.
     */
    public AgentContext withGeneratedLayout(Layout layout) {
        return new AgentContext(
                pipelineId, requestId, products, options, userPrompt,
                imageBase64, imageMimeType, imageAnalysis,
                assembledPrompt,
                layout, variants,
                validationErrors, retryCount, metadata
        );
    }
    
    /**
     * Returns a copy with variants added.
     */
    public AgentContext withVariants(List<LayoutVariant> newVariants) {
        return new AgentContext(
                pipelineId, requestId, products, options, userPrompt,
                imageBase64, imageMimeType, imageAnalysis,
                assembledPrompt,
                generatedLayout, newVariants,
                validationErrors, retryCount, metadata
        );
    }
    
    /**
     * Returns a copy with validation errors set.
     */
    public AgentContext withValidationErrors(List<String> errors) {
        return new AgentContext(
                pipelineId, requestId, products, options, userPrompt,
                imageBase64, imageMimeType, imageAnalysis,
                assembledPrompt,
                generatedLayout, variants,
                errors, retryCount, metadata
        );
    }
    
    /**
     * Returns a copy with incremented retry count.
     */
    public AgentContext withIncrementedRetry() {
        return new AgentContext(
                pipelineId, requestId, products, options, userPrompt,
                imageBase64, imageMimeType, imageAnalysis,
                assembledPrompt,
                generatedLayout, variants,
                validationErrors, retryCount + 1, metadata
        );
    }
    
    /**
     * Returns a copy with additional metadata.
     */
    public AgentContext withMetadata(String key, Object value) {
        var newMetadata = new java.util.HashMap<>(metadata);
        newMetadata.put(key, value);
        return new AgentContext(
                pipelineId, requestId, products, options, userPrompt,
                imageBase64, imageMimeType, imageAnalysis,
                assembledPrompt,
                generatedLayout, variants,
                validationErrors, retryCount, Map.copyOf(newMetadata)
        );
    }
    
    /**
     * Checks if this context has an image for analysis.
     */
    public boolean hasImage() {
        return imageBase64 != null && !imageBase64.isBlank();
    }
    
    /**
     * Checks if validation passed (no errors).
     */
    public boolean isValid() {
        return validationErrors == null || validationErrors.isEmpty();
    }
    
    /**
     * Checks if multi-variant generation is requested.
     */
    public boolean isMultiVariant() {
        return options != null && options.variantCount() > 1;
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/AgentOrchestrator.java">
package com.catalogforge.agent;

import com.catalogforge.agent.steps.ImageAnalysisStep;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Comparator;
import java.util.List;

/**
 * Orchestrates the agent pipeline execution.
 * Selects the appropriate strategy and executes the pipeline.
 */
@Service
public class AgentOrchestrator {

    private static final Logger log = LoggerFactory.getLogger(AgentOrchestrator.class);

    private final List<PipelineStrategy> strategies;
    private final ImageAnalysisStep imageAnalysisStep;

    public AgentOrchestrator(List<PipelineStrategy> strategies, ImageAnalysisStep imageAnalysisStep) {
        // Sort by @Order annotation (lower = higher priority)
        this.strategies = strategies.stream()
                .sorted(Comparator.comparingInt(s -> {
                    var order = s.getClass().getAnnotation(org.springframework.core.annotation.Order.class);
                    return order != null ? order.value() : Integer.MAX_VALUE;
                }))
                .toList();
        this.imageAnalysisStep = imageAnalysisStep;
        
        log.info("AgentOrchestrator initialized with {} strategies: {}", 
                strategies.size(),
                strategies.stream().map(PipelineStrategy::name).toList());
    }

    /**
     * Executes the agent pipeline for the given context.
     * 
     * @param context The initial context
     * @return The final context after pipeline execution
     */
    public AgentContext execute(AgentContext context) {
        log.info("Starting orchestration: pipelineId={}", context.pipelineId());
        long startTime = System.currentTimeMillis();
        
        // Step 1: Analyze image if present
        AgentContext current = context;
        if (context.hasImage()) {
            log.debug("Analyzing reference image");
            current = imageAnalysisStep.execute(current);
        }
        
        // Step 2: Select strategy
        PipelineStrategy strategy = selectStrategy(current);
        log.info("Selected strategy: {}", strategy.name());
        
        // Step 3: Execute pipeline
        Pipeline pipeline = strategy.getPipeline();
        current = pipeline.run(current);
        
        long duration = System.currentTimeMillis() - startTime;
        log.info("Orchestration completed: pipelineId={}, strategy={}, duration={}ms, valid={}", 
                context.pipelineId(), strategy.name(), duration, current.isValid());
        
        return current;
    }

    /**
     * Selects the appropriate strategy for the given context.
     */
    PipelineStrategy selectStrategy(AgentContext context) {
        return strategies.stream()
                .filter(s -> s.matches(context))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("No matching strategy found"));
    }

    /**
     * Returns all available strategies.
     */
    public List<String> getAvailableStrategies() {
        return strategies.stream()
                .map(PipelineStrategy::name)
                .toList();
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/AgentStep.java">
package com.catalogforge.agent;

/**
 * Interface for a single step in the agent pipeline.
 * Each step transforms the context and passes it to the next step.
 */
@FunctionalInterface
public interface AgentStep {
    
    /**
     * Executes this step with the given context.
     * 
     * @param context The current pipeline context
     * @return The updated context after this step
     */
    AgentContext execute(AgentContext context);
    
    /**
     * Returns the name of this step for logging purposes.
     */
    default String name() {
        return getClass().getSimpleName();
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/CorrectionStep.java">
package com.catalogforge.agent;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.stream.Collectors;

/**
 * Applies corrections to the prompt based on validation errors.
 * Enhances the prompt with specific instructions to fix identified issues.
 */
@Component
public class CorrectionStep implements AgentStep {

    private static final Logger log = LoggerFactory.getLogger(CorrectionStep.class);

    @Override
    public AgentContext execute(AgentContext context) {
        log.debug("Applying corrections for pipeline: {}", context.pipelineId());
        
        if (context.validationErrors() == null || context.validationErrors().isEmpty()) {
            return context;
        }
        
        // Build correction instructions based on errors
        String correctionInstructions = buildCorrectionInstructions(context);
        
        // Append correction instructions to the assembled prompt
        String enhancedPrompt = context.assembledPrompt() + "\n\n" + correctionInstructions;
        
        log.debug("Added correction instructions for {} errors", context.validationErrors().size());
        
        return context
                .withAssembledPrompt(enhancedPrompt)
                .withValidationErrors(java.util.List.of()); // Clear errors for retry
    }

    private String buildCorrectionInstructions(AgentContext context) {
        StringBuilder sb = new StringBuilder();
        sb.append("## IMPORTANT: Correction Required\n\n");
        sb.append("The previous generation had the following issues that MUST be fixed:\n\n");
        
        for (String error : context.validationErrors()) {
            sb.append("- ").append(error).append("\n");
            sb.append("  → ").append(getSuggestionForError(error)).append("\n");
        }
        
        sb.append("\nPlease regenerate the layout ensuring all issues are addressed.");
        
        return sb.toString();
    }

    private String getSuggestionForError(String error) {
        if (error.contains("empty")) {
            return "Ensure the content is not empty and contains meaningful HTML/CSS";
        }
        if (error.contains("too short")) {
            return "Generate more complete content with proper structure";
        }
        if (error.contains("unbalanced brackets")) {
            return "Check CSS syntax and ensure all brackets are properly closed";
        }
        if (error.contains("sanitized")) {
            return "Avoid using script tags, event handlers, or javascript: URLs";
        }
        return "Review and fix the identified issue";
    }

    @Override
    public String name() {
        return "Correction";
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/FallbackStep.java">
package com.catalogforge.agent;

import com.catalogforge.model.Layout;
import com.catalogforge.model.LayoutMetadata;
import com.catalogforge.model.LayoutVariant;
import com.catalogforge.model.PageFormat;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

/**
 * Provides a fallback layout when generation repeatedly fails.
 * Creates a minimal but valid layout structure.
 */
@Component
public class FallbackStep implements AgentStep {

    private static final Logger log = LoggerFactory.getLogger(FallbackStep.class);

    @Override
    public AgentContext execute(AgentContext context) {
        log.warn("Executing fallback for pipeline: {} after {} retries", 
                context.pipelineId(), context.retryCount());
        
        Layout fallbackLayout = createFallbackLayout(context);
        
        return context
                .withGeneratedLayout(fallbackLayout)
                .withValidationErrors(List.of()); // Clear errors
    }

    private Layout createFallbackLayout(AgentContext context) {
        String productInfo = buildProductInfo(context);
        
        String html = String.format("""
                <!DOCTYPE html>
                <html lang="de">
                <head>
                    <meta charset="UTF-8">
                    <title>Produktkatalog</title>
                </head>
                <body>
                    <div class="catalog-page">
                        <header class="page-header">
                            <h1>Produktkatalog</h1>
                        </header>
                        <main class="content">
                            %s
                        </main>
                        <footer class="page-footer">
                            <p>Generiert mit CatalogForge</p>
                        </footer>
                    </div>
                </body>
                </html>
                """, productInfo);
        
        String css = """
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }
                
                body {
                    font-family: 'Segoe UI', system-ui, sans-serif;
                    line-height: 1.6;
                    color: #333;
                    background: #fff;
                }
                
                .catalog-page {
                    max-width: 210mm;
                    margin: 0 auto;
                    padding: 20mm;
                }
                
                .page-header {
                    text-align: center;
                    margin-bottom: 2rem;
                    padding-bottom: 1rem;
                    border-bottom: 2px solid #0066cc;
                }
                
                .page-header h1 {
                    font-size: 2rem;
                    color: #0066cc;
                }
                
                .content {
                    min-height: 200mm;
                }
                
                .product-card {
                    background: #f8f9fa;
                    border-radius: 8px;
                    padding: 1.5rem;
                    margin-bottom: 1.5rem;
                }
                
                .product-card h2 {
                    color: #333;
                    margin-bottom: 0.5rem;
                }
                
                .product-card p {
                    color: #666;
                }
                
                .page-footer {
                    margin-top: 2rem;
                    padding-top: 1rem;
                    border-top: 1px solid #ddd;
                    text-align: center;
                    font-size: 0.875rem;
                    color: #666;
                }
                
                @media print {
                    .catalog-page {
                        padding: 15mm;
                    }
                }
                """;
        
        LayoutVariant variant = new LayoutVariant(
                UUID.randomUUID().toString(),
                html,
                css
        );
        
        String format = context.options() != null ? context.options().pageFormat() : "A4";
        PageFormat pageFormat = new PageFormat(format, 210, 297, "mm");
        
        return new Layout(
                UUID.randomUUID().toString(),
                "fallback",
                Instant.now(),
                pageFormat,
                context.imageAnalysis(),
                List.of(variant),
                new LayoutMetadata(List.of(), 0L, context.retryCount() + 1)
        );
    }

    private String buildProductInfo(AgentContext context) {
        if (context.products() == null || context.products().isEmpty()) {
            return "<p>Keine Produkte ausgewählt.</p>";
        }
        
        StringBuilder sb = new StringBuilder();
        for (var product : context.products()) {
            sb.append("<div class=\"product-card\">\n");
            sb.append("  <h2>").append(escapeHtml(product.name())).append("</h2>\n");
            if (product.shortDescription() != null) {
                sb.append("  <p>").append(escapeHtml(product.shortDescription())).append("</p>\n");
            }
            sb.append("</div>\n");
        }
        return sb.toString();
    }

    private String escapeHtml(String text) {
        if (text == null) return "";
        return text
                .replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;");
    }

    @Override
    public String name() {
        return "Fallback";
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/IterativePipeline.java">
package com.catalogforge.agent;

import com.catalogforge.agent.steps.LayoutGenerationStep;
import com.catalogforge.agent.steps.PromptAssemblyStep;
import com.catalogforge.agent.steps.ValidationStep;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * Iterative pipeline with validation and correction loop.
 * Retries layout generation if validation fails, up to maxRetries.
 */
@Component
public class IterativePipeline implements Pipeline {

    private static final Logger log = LoggerFactory.getLogger(IterativePipeline.class);
    private static final int DEFAULT_MAX_RETRIES = 3;

    private final PromptAssemblyStep promptAssemblyStep;
    private final LayoutGenerationStep layoutGenerationStep;
    private final ValidationStep validationStep;
    private final CorrectionStep correctionStep;
    private final FallbackStep fallbackStep;

    public IterativePipeline(
            PromptAssemblyStep promptAssemblyStep,
            LayoutGenerationStep layoutGenerationStep,
            ValidationStep validationStep,
            CorrectionStep correctionStep,
            FallbackStep fallbackStep
    ) {
        this.promptAssemblyStep = promptAssemblyStep;
        this.layoutGenerationStep = layoutGenerationStep;
        this.validationStep = validationStep;
        this.correctionStep = correctionStep;
        this.fallbackStep = fallbackStep;
    }

    @Override
    public AgentContext run(AgentContext context) {
        log.info("Starting IterativePipeline: {}", context.pipelineId());
        
        // Step 1: Assemble prompt
        AgentContext current = promptAssemblyStep.execute(context);
        
        // Step 2: Generate and validate with retry loop
        int maxRetries = DEFAULT_MAX_RETRIES;
        
        while (current.retryCount() <= maxRetries) {
            log.debug("Generation attempt {} of {}", current.retryCount() + 1, maxRetries + 1);
            
            // Generate layout
            current = layoutGenerationStep.execute(current);
            
            // Validate
            current = validationStep.execute(current);
            
            if (current.isValid()) {
                log.info("IterativePipeline completed successfully after {} attempts", 
                        current.retryCount() + 1);
                return current;
            }
            
            // If not valid and retries remaining, apply correction
            if (current.retryCount() < maxRetries) {
                log.debug("Validation failed, applying correction. Errors: {}", 
                        current.validationErrors());
                current = correctionStep.execute(current);
                current = current.withIncrementedRetry();
            } else {
                break;
            }
        }
        
        // Max retries exceeded, use fallback
        log.warn("IterativePipeline exceeded max retries, using fallback");
        current = fallbackStep.execute(current);
        
        log.info("IterativePipeline completed with fallback: {}", context.pipelineId());
        return current;
    }

    @Override
    public String name() {
        return "IterativePipeline";
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/LinearPipeline.java">
package com.catalogforge.agent;

import com.catalogforge.agent.steps.LayoutGenerationStep;
import com.catalogforge.agent.steps.PromptAssemblyStep;
import com.catalogforge.agent.steps.ValidationStep;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * Simple linear pipeline: PromptAssembly → LayoutGeneration → Validation.
 * Used for standard layout generation without retries or variants.
 */
@Component
public class LinearPipeline implements Pipeline {

    private static final Logger log = LoggerFactory.getLogger(LinearPipeline.class);

    private final List<AgentStep> steps;

    public LinearPipeline(
            PromptAssemblyStep promptAssemblyStep,
            LayoutGenerationStep layoutGenerationStep,
            ValidationStep validationStep
    ) {
        this.steps = List.of(promptAssemblyStep, layoutGenerationStep, validationStep);
    }

    @Override
    public AgentContext run(AgentContext context) {
        log.info("Starting LinearPipeline: {}", context.pipelineId());
        
        AgentContext current = context;
        
        for (AgentStep step : steps) {
            log.debug("Executing step: {}", step.name());
            long start = System.currentTimeMillis();
            
            current = step.execute(current);
            
            long duration = System.currentTimeMillis() - start;
            log.debug("Step {} completed in {}ms", step.name(), duration);
        }
        
        log.info("LinearPipeline completed: {} (valid={})", 
                context.pipelineId(), current.isValid());
        
        return current;
    }

    @Override
    public String name() {
        return "LinearPipeline";
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/ParallelPipeline.java">
package com.catalogforge.agent;

import com.catalogforge.agent.steps.LayoutGenerationStep;
import com.catalogforge.agent.steps.PromptAssemblyStep;
import com.catalogforge.agent.steps.ValidationStep;
import com.catalogforge.model.Layout;
import com.catalogforge.model.LayoutVariant;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

/**
 * Parallel pipeline for generating multiple layout variants simultaneously.
 * Executes N parallel layout generations and aggregates results.
 */
@Component
public class ParallelPipeline implements Pipeline {

    private static final Logger log = LoggerFactory.getLogger(ParallelPipeline.class);
    private static final int DEFAULT_VARIANT_COUNT = 3;

    private final PromptAssemblyStep promptAssemblyStep;
    private final LayoutGenerationStep layoutGenerationStep;
    private final ValidationStep validationStep;
    private final ExecutorService executor;

    public ParallelPipeline(
            PromptAssemblyStep promptAssemblyStep,
            LayoutGenerationStep layoutGenerationStep,
            ValidationStep validationStep
    ) {
        this.promptAssemblyStep = promptAssemblyStep;
        this.layoutGenerationStep = layoutGenerationStep;
        this.validationStep = validationStep;
        this.executor = Executors.newFixedThreadPool(4);
    }

    @Override
    public AgentContext run(AgentContext context) {
        log.info("Starting ParallelPipeline: {}", context.pipelineId());
        
        int variantCount = context.options() != null 
                ? context.options().variantCount() 
                : DEFAULT_VARIANT_COUNT;
        
        // Step 1: Assemble base prompt
        AgentContext baseContext = promptAssemblyStep.execute(context);
        
        // Step 2: Generate variants in parallel
        List<CompletableFuture<AgentContext>> futures = new ArrayList<>();
        
        for (int i = 0; i < variantCount; i++) {
            final int variantIndex = i;
            CompletableFuture<AgentContext> future = CompletableFuture.supplyAsync(() -> {
                log.debug("Generating variant {} of {}", variantIndex + 1, variantCount);
                
                // Add variant-specific instructions
                AgentContext variantContext = baseContext.withAssembledPrompt(
                        baseContext.assembledPrompt() + "\n\n" + 
                        getVariantInstructions(variantIndex, variantCount)
                );
                
                // Generate and validate
                AgentContext generated = layoutGenerationStep.execute(variantContext);
                return validationStep.execute(generated);
                
            }, executor);
            
            futures.add(future);
        }
        
        // Step 3: Collect results
        List<AgentContext> results = futures.stream()
                .map(CompletableFuture::join)
                .toList();
        
        // Step 4: Aggregate variants
        List<LayoutVariant> allVariants = results.stream()
                .filter(ctx -> ctx.generatedLayout() != null)
                .flatMap(ctx -> ctx.generatedLayout().variants().stream())
                .collect(Collectors.toList());
        
        // Use first valid layout as base, add all variants
        AgentContext firstValid = results.stream()
                .filter(AgentContext::isValid)
                .findFirst()
                .orElse(results.get(0));
        
        if (firstValid.generatedLayout() != null) {
            Layout aggregatedLayout = firstValid.generatedLayout().withVariants(allVariants);
            firstValid = firstValid.withGeneratedLayout(aggregatedLayout);
        }
        
        log.info("ParallelPipeline completed: {} variants generated", allVariants.size());
        return firstValid.withVariants(allVariants);
    }

    private String getVariantInstructions(int index, int total) {
        String[] styles = {
                "Create a clean, minimalist design with ample whitespace",
                "Create a bold, dynamic design with strong visual hierarchy",
                "Create an elegant, premium design with refined typography",
                "Create a modern, tech-focused design with geometric elements",
                "Create a warm, approachable design with rounded elements"
        };
        
        String style = styles[index % styles.length];
        
        return String.format("""
                ## Variant Instructions (Variant %d of %d)
                
                %s
                
                Make this variant distinct from others while maintaining brand consistency.
                """, index + 1, total, style);
    }

    @Override
    public String name() {
        return "ParallelPipeline";
    }
}
</file>

<file path="src/main/java/com/catalogforge/agent/Pipeline.java">
package com.catalogforge.agent;

/**
 * Interface for agent pipelines.
 * A pipeline orchestrates the execution of multiple steps.
 */
public interface Pipeline {
    
    /**
     * Runs the pipeline with the given context.
     * 
     * @param context The initial context
     * @return The final context after all steps
     */
    AgentContext run(AgentContext context);
    
    /**
     * Returns the name of this pipeline for logging purposes.
     */
    String name();
}
</file>

<file path="src/main/java/com/catalogforge/agent/PipelineStrategy.java">
package com.catalogforge.agent;

/**
 * Strategy interface for selecting and configuring pipelines.
 */
public interface PipelineStrategy {
    
    /**
     * Returns the pipeline to use for this strategy.
     */
    Pipeline getPipeline();
    
    /**
     * Returns the name of this strategy.
     */
    String name();
    
    /**
     * Checks if this strategy is appropriate for the given context.
     */
    boolean matches(AgentContext context);
}
</file>

<file path="src/main/java/com/catalogforge/config/properties/GeminiProperties.java">
package com.catalogforge.config.properties;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Positive;

/**
 * Configuration properties for Google Gemini API integration.
 */
@ConfigurationProperties(prefix = "catalogforge.gemini")
@Validated
public record GeminiProperties(
    String apiKey,
    
    @NotBlank
    String baseUrl,
    
    @NotBlank
    String modelDefault,
    
    @NotBlank
    String modelVision,
    
    @NotBlank
    String modelComplex,
    
    @Positive
    int timeoutSeconds,
    
    @Positive
    int maxRetries
) {
    public GeminiProperties {
        if (timeoutSeconds <= 0) timeoutSeconds = 60;
        if (maxRetries <= 0) maxRetries = 3;
    }
}
</file>

<file path="src/main/java/com/catalogforge/config/properties/ImageProperties.java">
package com.catalogforge.config.properties;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Positive;

/**
 * Configuration properties for image handling.
 */
@ConfigurationProperties(prefix = "catalogforge.images")
@Validated
public record ImageProperties(
    @NotBlank
    String tempDir,
    
    @Positive
    int urlValidationTimeoutMs,
    
    @Positive
    int expirationHours,
    
    boolean placeholderEnabled
) {
    public ImageProperties {
        if (tempDir == null || tempDir.isBlank()) tempDir = "/tmp/catalogforge/images";
        if (urlValidationTimeoutMs <= 0) urlValidationTimeoutMs = 5000;
        if (expirationHours <= 0) expirationHours = 24;
    }
}
</file>

<file path="src/main/java/com/catalogforge/config/properties/LayoutProperties.java">
package com.catalogforge.config.properties;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;

/**
 * Configuration properties for layout generation.
 */
@ConfigurationProperties(prefix = "catalogforge.layout")
@Validated
public record LayoutProperties(
    @Min(1) @Max(10)
    int variantCountDefault,
    
    @Min(1) @Max(10)
    int maxVariantCount,
    
    boolean fallbackEnabled
) {
    public LayoutProperties {
        if (variantCountDefault <= 0) variantCountDefault = 2;
        if (maxVariantCount <= 0) maxVariantCount = 5;
    }
}
</file>

<file path="src/main/java/com/catalogforge/config/properties/LoggingProperties.java">
package com.catalogforge.config.properties;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.constraints.NotBlank;

/**
 * Configuration properties for LLM interaction logging.
 */
@ConfigurationProperties(prefix = "catalogforge.logging.llm")
@Validated
public record LoggingProperties(
    boolean enabled,
    
    @NotBlank
    String directory,
    
    @NotBlank
    String filePattern
) {
    public LoggingProperties {
        if (directory == null || directory.isBlank()) directory = "./logs/llm";
        if (filePattern == null || filePattern.isBlank()) filePattern = "{date}_llm.jsonl";
    }
}
</file>

<file path="src/main/java/com/catalogforge/config/properties/PuppeteerProperties.java">
package com.catalogforge.config.properties;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Positive;

/**
 * Configuration properties for Puppeteer PDF generation.
 */
@ConfigurationProperties(prefix = "catalogforge.puppeteer")
@Validated
public record PuppeteerProperties(
    @NotBlank
    String nodePath,
    
    @NotBlank
    String scriptPath,
    
    @NotBlank
    String tempDir,
    
    @Positive
    int defaultDpi,
    
    @Positive
    int imageTimeoutSeconds
) {
    public PuppeteerProperties {
        if (nodePath == null || nodePath.isBlank()) nodePath = "/usr/bin/node";
        if (scriptPath == null || scriptPath.isBlank()) scriptPath = "./puppeteer/pdf-generator.js";
        if (tempDir == null || tempDir.isBlank()) tempDir = "/tmp/catalogforge/pdf";
        if (defaultDpi <= 0) defaultDpi = 300;
        if (imageTimeoutSeconds <= 0) imageTimeoutSeconds = 10;
    }
}
</file>

<file path="src/main/java/com/catalogforge/config/properties/SkillsProperties.java">
package com.catalogforge.config.properties;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.constraints.NotBlank;

/**
 * Configuration properties for the Skills system.
 */
@ConfigurationProperties(prefix = "catalogforge.skills")
@Validated
public record SkillsProperties(
    @NotBlank
    String basePath,
    
    boolean cacheEnabled
) {
    public SkillsProperties {
        if (cacheEnabled == false) cacheEnabled = true;
    }
}
</file>

<file path="src/main/java/com/catalogforge/config/GeminiConfig.java">
package com.catalogforge.config;

import java.time.Duration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;

import com.catalogforge.config.properties.GeminiProperties;

/**
 * Configuration for Google Gemini API client.
 */
@Configuration
public class GeminiConfig {

    @Bean
    public WebClient geminiWebClient(GeminiProperties properties) {
        return WebClient.builder()
            .baseUrl(properties.baseUrl())
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }
}
</file>

<file path="src/main/java/com/catalogforge/config/LoggingConfig.java">
package com.catalogforge.config;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Configuration;

import com.catalogforge.config.properties.LoggingProperties;

import jakarta.annotation.PostConstruct;

/**
 * Configuration for LLM interaction logging.
 * Ensures log directories exist on startup.
 */
@Configuration
public class LoggingConfig {

    private static final Logger log = LoggerFactory.getLogger(LoggingConfig.class);

    private final LoggingProperties properties;

    public LoggingConfig(LoggingProperties properties) {
        this.properties = properties;
    }

    @PostConstruct
    public void init() {
        if (properties.enabled()) {
            try {
                Path logDir = Paths.get(properties.directory());
                if (!Files.exists(logDir)) {
                    Files.createDirectories(logDir);
                    log.info("Created LLM log directory: {}", logDir.toAbsolutePath());
                }
            } catch (IOException e) {
                log.warn("Failed to create LLM log directory: {}", e.getMessage());
            }
        }
    }

    public boolean isEnabled() {
        return properties.enabled();
    }

    public String getDirectory() {
        return properties.directory();
    }

    public String getFilePattern() {
        return properties.filePattern();
    }
}
</file>

<file path="src/main/java/com/catalogforge/config/SkillsConfig.java">
package com.catalogforge.config;

import org.springframework.context.annotation.Configuration;

import com.catalogforge.config.properties.SkillsProperties;

/**
 * Configuration for the Skills system.
 * Skills are loaded from markdown files and assembled into prompts.
 */
@Configuration
public class SkillsConfig {

    private final SkillsProperties properties;

    public SkillsConfig(SkillsProperties properties) {
        this.properties = properties;
    }

    public String getBasePath() {
        return properties.basePath();
    }

    public boolean isCacheEnabled() {
        return properties.cacheEnabled();
    }
}
</file>

<file path="src/main/java/com/catalogforge/config/WebConfig.java">
package com.catalogforge.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * Web configuration including CORS settings.
 */
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("*")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
            .allowedHeaders("*")
            .maxAge(3600);
    }
}
</file>

<file path="src/main/java/com/catalogforge/controller/ImageController.java">
package com.catalogforge.controller;

import com.catalogforge.model.response.ImageUploadResponse;
import com.catalogforge.service.ImageService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Base64;

/**
 * REST controller for image upload and retrieval.
 */
@RestController
@RequestMapping("/api/v1/images")
public class ImageController {

    private static final Logger log = LoggerFactory.getLogger(ImageController.class);

    private final ImageService imageService;

    public ImageController(ImageService imageService) {
        this.imageService = imageService;
    }

    /**
     * Uploads an image.
     * POST /api/v1/images/upload
     */
    @PostMapping("/upload")
    public ResponseEntity<ImageUploadResponse> uploadImage(@RequestParam("file") MultipartFile file) throws IOException {
        log.info("POST /api/v1/images/upload - filename: {}, size: {} bytes", 
                file.getOriginalFilename(), file.getSize());
        
        String base64Data = Base64.getEncoder().encodeToString(file.getBytes());
        String mimeType = file.getContentType();
        String filename = file.getOriginalFilename();
        
        String imageId = imageService.upload(base64Data, mimeType, filename);
        String url = imageService.generateUrl(imageId);
        
        ImageUploadResponse response = new ImageUploadResponse(
                imageId,
                url,
                mimeType,
                Instant.now().plus(24, ChronoUnit.HOURS)
        );
        
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * Uploads an image as Base64 JSON.
     * POST /api/v1/images/upload/base64
     */
    @PostMapping("/upload/base64")
    public ResponseEntity<ImageUploadResponse> uploadImageBase64(@RequestBody ImageUploadRequest request) {
        log.info("POST /api/v1/images/upload/base64 - mimeType: {}", request.mimeType());
        
        String imageId = imageService.upload(request.base64Data(), request.mimeType(), request.filename());
        String url = imageService.generateUrl(imageId);
        
        ImageUploadResponse response = new ImageUploadResponse(
                imageId,
                url,
                request.mimeType(),
                Instant.now().plus(24, ChronoUnit.HOURS)
        );
        
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * Retrieves an image by ID.
     * GET /api/v1/images/{imageId}
     */
    @GetMapping("/{imageId}")
    public ResponseEntity<byte[]> getImage(@PathVariable String imageId) {
        log.debug("GET /api/v1/images/{}", imageId);
        
        ImageService.StoredImage image = imageService.getImage(imageId);
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(image.mimeType()));
        headers.setContentLength(image.data().length);
        
        return ResponseEntity.ok().headers(headers).body(image.data());
    }

    /**
     * Deletes an image.
     * DELETE /api/v1/images/{imageId}
     */
    @DeleteMapping("/{imageId}")
    public ResponseEntity<Void> deleteImage(@PathVariable String imageId) {
        log.info("DELETE /api/v1/images/{}", imageId);
        
        imageService.delete(imageId);
        return ResponseEntity.noContent().build();
    }

    /**
     * Request body for Base64 image upload.
     */
    public record ImageUploadRequest(
            String base64Data,
            String mimeType,
            String filename
    ) {}
}
</file>

<file path="src/main/java/com/catalogforge/controller/LayoutController.java">
package com.catalogforge.controller;

import com.catalogforge.model.Layout;
import com.catalogforge.model.LayoutVariant;
import com.catalogforge.model.request.ImageToLayoutRequest;
import com.catalogforge.model.request.TextToLayoutRequest;
import com.catalogforge.model.response.LayoutResponse;
import com.catalogforge.service.LayoutGenerationService;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST controller for layout generation and management.
 */
@RestController
@RequestMapping("/api/v1/layouts")
public class LayoutController {

    private static final Logger log = LoggerFactory.getLogger(LayoutController.class);

    private final LayoutGenerationService layoutService;

    public LayoutController(LayoutGenerationService layoutService) {
        this.layoutService = layoutService;
    }

    /**
     * Generates a layout from text prompt.
     * POST /api/v1/layouts/generate/text
     */
    @PostMapping("/generate/text")
    public ResponseEntity<LayoutResponse> generateFromText(@Valid @RequestBody TextToLayoutRequest request) {
        log.info("POST /api/v1/layouts/generate/text - products: {}", request.productIds());
        
        Layout layout = layoutService.generateFromText(
                request.productIds(),
                request.options(),
                request.prompt()
        );
        
        return ResponseEntity.status(HttpStatus.CREATED).body(LayoutResponse.from(layout));
    }

    /**
     * Generates a layout from image reference.
     * POST /api/v1/layouts/generate/image
     */
    @PostMapping("/generate/image")
    public ResponseEntity<LayoutResponse> generateFromImage(@Valid @RequestBody ImageToLayoutRequest request) {
        log.info("POST /api/v1/layouts/generate/image - products: {}, mimeType: {}", 
                request.productIds(), request.imageMimeType());
        
        Layout layout = layoutService.generateFromImage(
                request.productIds(),
                request.options(),
                request.prompt(),
                request.imageBase64(),
                request.imageMimeType()
        );
        
        return ResponseEntity.status(HttpStatus.CREATED).body(LayoutResponse.from(layout));
    }

    /**
     * Gets a layout by ID.
     * GET /api/v1/layouts/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<LayoutResponse> getLayout(@PathVariable String id) {
        log.debug("GET /api/v1/layouts/{}", id);
        
        Layout layout = layoutService.getLayout(id);
        return ResponseEntity.ok(LayoutResponse.from(layout));
    }

    /**
     * Updates a layout.
     * PUT /api/v1/layouts/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity<LayoutResponse> updateLayout(
            @PathVariable String id,
            @RequestBody Layout updatedLayout
    ) {
        log.info("PUT /api/v1/layouts/{}", id);
        
        Layout layout = layoutService.updateLayout(id, updatedLayout);
        return ResponseEntity.ok(LayoutResponse.from(layout));
    }

    /**
     * Deletes a layout.
     * DELETE /api/v1/layouts/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteLayout(@PathVariable String id) {
        log.info("DELETE /api/v1/layouts/{}", id);
        
        layoutService.deleteLayout(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Gets all variants for a layout.
     * GET /api/v1/layouts/{id}/variants
     */
    @GetMapping("/{id}/variants")
    public ResponseEntity<List<LayoutResponse.VariantResponse>> getVariants(@PathVariable String id) {
        log.debug("GET /api/v1/layouts/{}/variants", id);
        
        List<LayoutVariant> variants = layoutService.getVariants(id);
        List<LayoutResponse.VariantResponse> response = variants.stream()
                .map(LayoutResponse.VariantResponse::from)
                .toList();
        
        return ResponseEntity.ok(response);
    }

    /**
     * Gets a specific variant.
     * GET /api/v1/layouts/{layoutId}/variants/{variantId}
     */
    @GetMapping("/{layoutId}/variants/{variantId}")
    public ResponseEntity<LayoutResponse.VariantResponse> getVariant(
            @PathVariable String layoutId,
            @PathVariable String variantId
    ) {
        log.debug("GET /api/v1/layouts/{}/variants/{}", layoutId, variantId);
        
        LayoutVariant variant = layoutService.getVariant(layoutId, variantId);
        return ResponseEntity.ok(LayoutResponse.VariantResponse.from(variant));
    }
}
</file>

<file path="src/main/java/com/catalogforge/controller/PdfController.java">
package com.catalogforge.controller;

import com.catalogforge.pdf.PrintPreset;
import com.catalogforge.service.PdfGenerationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

/**
 * REST controller for PDF generation.
 */
@RestController
@RequestMapping("/api/v1/pdf")
public class PdfController {

    private static final Logger log = LoggerFactory.getLogger(PdfController.class);

    private final PdfGenerationService pdfService;

    public PdfController(PdfGenerationService pdfService) {
        this.pdfService = pdfService;
    }

    /**
     * Generates a PDF from a layout.
     * POST /api/v1/pdf/generate
     */
    @PostMapping("/generate")
    public ResponseEntity<Map<String, Object>> generatePdf(@RequestBody PdfGenerateRequest request) {
        log.info("POST /api/v1/pdf/generate - layoutId: {}, preset: {}", 
                request.layoutId(), request.preset());

        String pdfId = pdfService.generate(
                request.layoutId(),
                request.variantId(),
                request.preset()
        );

        Map<String, Object> response = Map.of(
                "pdfId", pdfId,
                "downloadUrl", "/api/v1/pdf/" + pdfId + "/download"
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * Downloads a generated PDF.
     * GET /api/v1/pdf/{id}/download
     */
    @GetMapping("/{id}/download")
    public ResponseEntity<byte[]> downloadPdf(@PathVariable String id) {
        log.info("GET /api/v1/pdf/{}/download", id);

        PdfGenerationService.GeneratedPdf pdf = pdfService.getPdf(id);
        byte[] content = pdfService.getPdfContent(id);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_PDF);
        headers.setContentDisposition(ContentDisposition.attachment()
                .filename("layout-" + pdf.layoutId() + ".pdf")
                .build());
        headers.setContentLength(content.length);

        return ResponseEntity.ok().headers(headers).body(content);
    }

    /**
     * Gets PDF metadata.
     * GET /api/v1/pdf/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<Map<String, Object>> getPdfInfo(@PathVariable String id) {
        log.debug("GET /api/v1/pdf/{}", id);

        PdfGenerationService.GeneratedPdf pdf = pdfService.getPdf(id);

        Map<String, Object> response = Map.of(
                "id", pdf.id(),
                "layoutId", pdf.layoutId(),
                "variantId", pdf.variantId() != null ? pdf.variantId() : "",
                "preset", pdf.preset().getName(),
                "downloadUrl", "/api/v1/pdf/" + id + "/download"
        );

        return ResponseEntity.ok(response);
    }

    /**
     * Deletes a generated PDF.
     * DELETE /api/v1/pdf/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletePdf(@PathVariable String id) {
        log.info("DELETE /api/v1/pdf/{}", id);

        pdfService.deletePdf(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Lists available print presets.
     * GET /api/v1/pdf/presets
     */
    @GetMapping("/presets")
    public ResponseEntity<List<Map<String, Object>>> getPresets() {
        List<Map<String, Object>> presets = Arrays.stream(PrintPreset.values())
                .map(p -> Map.<String, Object>of(
                        "name", p.getName(),
                        "description", p.getDescription(),
                        "dpi", p.getDpi(),
                        "bleedMm", p.getBleedMm(),
                        "cropMarks", p.hasCropMarks()
                ))
                .toList();

        return ResponseEntity.ok(presets);
    }

    /**
     * Request body for PDF generation.
     */
    public record PdfGenerateRequest(
            String layoutId,
            String variantId,
            String preset
    ) {
        public PdfGenerateRequest {
            if (preset == null || preset.isBlank()) preset = "screen";
        }
    }
}
</file>

<file path="src/main/java/com/catalogforge/controller/ProductController.java">
package com.catalogforge.controller;

import com.catalogforge.model.Product;
import com.catalogforge.service.ProductService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Set;

/**
 * REST controller for product operations.
 * Provides endpoints for listing, filtering, searching, and retrieving products.
 */
@RestController
@RequestMapping("/api/v1/products")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    /**
     * GET /api/v1/products
     * Returns all products, optionally filtered by category and/or series.
     */
    @GetMapping
    public ResponseEntity<List<Product>> getProducts(
            @RequestParam(required = false) String category,
            @RequestParam(required = false) String series) {
        
        List<Product> products;
        if (category != null || series != null) {
            products = productService.filterProducts(category, series);
        } else {
            products = productService.getAllProducts();
        }
        return ResponseEntity.ok(products);
    }

    /**
     * GET /api/v1/products/{id}
     * Returns a single product by ID.
     */
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProductById(@PathVariable Long id) {
        Product product = productService.getProductById(id);
        return ResponseEntity.ok(product);
    }

    /**
     * GET /api/v1/products/categories
     * Returns all unique product categories, sorted alphabetically.
     */
    @GetMapping("/categories")
    public ResponseEntity<Set<String>> getCategories() {
        return ResponseEntity.ok(productService.getAllCategories());
    }

    /**
     * GET /api/v1/products/series
     * Returns all unique product series, sorted alphabetically.
     */
    @GetMapping("/series")
    public ResponseEntity<Set<String>> getSeries() {
        return ResponseEntity.ok(productService.getAllSeries());
    }

    /**
     * GET /api/v1/products/search?q={query}
     * Searches products by query string (case-insensitive full-text search).
     */
    @GetMapping("/search")
    public ResponseEntity<List<Product>> searchProducts(@RequestParam String q) {
        List<Product> results = productService.searchProducts(q);
        return ResponseEntity.ok(results);
    }
}
</file>

<file path="src/main/java/com/catalogforge/controller/SkillsController.java">
package com.catalogforge.controller;

import com.catalogforge.model.Skill;
import com.catalogforge.service.SkillsService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Collection;
import java.util.List;
import java.util.Set;

/**
 * REST controller for skills operations.
 * Provides endpoints for listing and retrieving skills.
 */
@RestController
@RequestMapping("/api/v1/skills")
public class SkillsController {

    private final SkillsService skillsService;

    public SkillsController(SkillsService skillsService) {
        this.skillsService = skillsService;
    }

    /**
     * GET /api/v1/skills
     * Returns all loaded skills.
     */
    @GetMapping
    public ResponseEntity<Collection<Skill>> getAllSkills() {
        return ResponseEntity.ok(skillsService.getAllSkills());
    }

    /**
     * GET /api/v1/skills/categories
     * Returns all skill categories.
     */
    @GetMapping("/categories")
    public ResponseEntity<Set<String>> getCategories() {
        return ResponseEntity.ok(skillsService.getAllCategories());
    }

    /**
     * GET /api/v1/skills/{category}
     * Returns all skills in a specific category.
     */
    @GetMapping("/{category}")
    public ResponseEntity<List<Skill>> getSkillsByCategory(@PathVariable String category) {
        List<Skill> skills = skillsService.getSkillsByCategory(category);
        return ResponseEntity.ok(skills);
    }

    /**
     * GET /api/v1/skills/prompts/examples
     * Returns example prompts for different use cases.
     */
    @GetMapping("/prompts/examples")
    public ResponseEntity<List<ExamplePrompt>> getExamplePrompts() {
        List<ExamplePrompt> examples = List.of(
                new ExamplePrompt(
                        "product-page-modern",
                        "Moderne Produktseite",
                        "Erstelle eine moderne Produktseite für den Mercedes-Benz Actros L mit technischen Daten und Highlights.",
                        List.of("LAYOUT_PRINCIPLES", "TYPOGRAPHY"),
                        "modern",
                        "A4"
                ),
                new ExamplePrompt(
                        "flyer-technical",
                        "Technischer Flyer",
                        "Erstelle einen technischen Flyer mit Fokus auf Spezifikationen und Leistungsdaten.",
                        List.of("LAYOUT_PRINCIPLES"),
                        "technical",
                        "DL"
                ),
                new ExamplePrompt(
                        "catalog-overview",
                        "Katalog-Übersicht",
                        "Erstelle eine Übersichtsseite mit mehreren Produkten der Actros-Baureihe.",
                        List.of("LAYOUT_PRINCIPLES", "TYPOGRAPHY"),
                        "modern",
                        "A4"
                )
        );
        return ResponseEntity.ok(examples);
    }

    /**
     * POST /api/v1/skills/reload
     * Reloads all skills from disk.
     */
    @PostMapping("/reload")
    public ResponseEntity<Void> reloadSkills() {
        skillsService.reloadSkills();
        return ResponseEntity.ok().build();
    }

    /**
     * Example prompt DTO for the examples endpoint.
     */
    public record ExamplePrompt(
            String id,
            String title,
            String prompt,
            List<String> skills,
            String style,
            String format
    ) {}
}
</file>

<file path="src/main/java/com/catalogforge/exception/CatalogForgeException.java">
package com.catalogforge.exception;

/**
 * Base exception for all CatalogForge application exceptions.
 */
public abstract class CatalogForgeException extends RuntimeException {

    protected CatalogForgeException(String message) {
        super(message);
    }

    protected CatalogForgeException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/catalogforge/exception/GlobalExceptionHandler.java">
package com.catalogforge.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.multipart.MaxUploadSizeExceededException;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import com.catalogforge.model.response.ErrorResponse;

/**
 * Global exception handler for REST API.
 * Maps exceptions to appropriate HTTP responses with ErrorResponse body.
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
            MethodArgumentNotValidException ex, WebRequest request) {
        
        log.warn("Validation error: {}", ex.getMessage());
        
        String message = ex.getBindingResult().getFieldErrors().stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .findFirst()
            .orElse("Validation failed");
        
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(ErrorResponse.of(
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                message,
                getPath(request)
            ));
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(
            ResourceNotFoundException ex, WebRequest request) {
        
        log.warn("Resource not found: {}", ex.getMessage());
        
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(ErrorResponse.of(
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                getPath(request)
            ));
    }

    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<ErrorResponse> handleTooLarge(
            MaxUploadSizeExceededException ex, WebRequest request) {
        
        log.warn("File too large: {}", ex.getMessage());
        
        return ResponseEntity
            .status(HttpStatus.PAYLOAD_TOO_LARGE)
            .body(ErrorResponse.of(
                HttpStatus.PAYLOAD_TOO_LARGE.value(),
                "Payload Too Large",
                "File size exceeds maximum allowed size of 10MB",
                getPath(request)
            ));
    }

    @ExceptionHandler(ImageUploadException.class)
    public ResponseEntity<ErrorResponse> handleImageUpload(
            ImageUploadException ex, WebRequest request) {
        
        log.warn("Image upload error: {}", ex.getMessage());
        
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(ErrorResponse.of(
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                getPath(request)
            ));
    }

    @ExceptionHandler({ImageAnalysisException.class, LayoutGenerationException.class})
    public ResponseEntity<ErrorResponse> handleGeminiError(
            CatalogForgeException ex, WebRequest request) {
        
        log.error("Gemini API error: {}", ex.getMessage(), ex);
        
        return ResponseEntity
            .status(HttpStatus.BAD_GATEWAY)
            .body(ErrorResponse.of(
                HttpStatus.BAD_GATEWAY.value(),
                "Bad Gateway",
                "External AI service error: " + ex.getMessage(),
                getPath(request)
            ));
    }

    @ExceptionHandler(PdfGenerationException.class)
    public ResponseEntity<ErrorResponse> handlePdfGeneration(
            PdfGenerationException ex, WebRequest request) {
        
        log.error("PDF generation error: {}", ex.getMessage(), ex);
        
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ErrorResponse.of(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                "PDF generation failed",
                getPath(request)
            ));
    }

    @ExceptionHandler(SkillLoadException.class)
    public ResponseEntity<ErrorResponse> handleSkillLoad(
            SkillLoadException ex, WebRequest request) {
        
        log.error("Skill loading error: {}", ex.getMessage(), ex);
        
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ErrorResponse.of(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                "Failed to load skills",
                getPath(request)
            ));
    }

    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponse> handleMethodNotAllowed(
            HttpRequestMethodNotSupportedException ex, WebRequest request) {
        
        log.debug("Method not allowed: {} on {}", ex.getMethod(), getPath(request));
        
        return ResponseEntity
            .status(HttpStatus.METHOD_NOT_ALLOWED)
            .body(ErrorResponse.of(
                HttpStatus.METHOD_NOT_ALLOWED.value(),
                "Method Not Allowed",
                "Method " + ex.getMethod() + " not supported",
                getPath(request)
            ));
    }

    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<ErrorResponse> handleNoResourceFound(
            NoResourceFoundException ex, WebRequest request) {
        
        // Don't log as error - this is normal for favicon, dashboard, etc.
        log.debug("Static resource not found: {}", getPath(request));
        
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(ErrorResponse.of(
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                "Resource not found",
                getPath(request)
            ));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(
            Exception ex, WebRequest request) {
        
        log.error("Unexpected error: {}", ex.getMessage(), ex);
        
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ErrorResponse.of(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                "An unexpected error occurred",
                getPath(request)
            ));
    }

    private String getPath(WebRequest request) {
        return request.getDescription(false).replace("uri=", "");
    }
}
</file>

<file path="src/main/java/com/catalogforge/exception/ImageAnalysisException.java">
package com.catalogforge.exception;

/**
 * Exception thrown when image analysis via Gemini Vision fails.
 */
public class ImageAnalysisException extends CatalogForgeException {

    public ImageAnalysisException(String message) {
        super(message);
    }

    public ImageAnalysisException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/catalogforge/exception/ImageUploadException.java">
package com.catalogforge.exception;

/**
 * Exception thrown when image upload fails.
 */
public class ImageUploadException extends CatalogForgeException {

    public ImageUploadException(String message) {
        super(message);
    }

    public ImageUploadException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/catalogforge/exception/ImageUrlNotReachableException.java">
package com.catalogforge.exception;

/**
 * Exception thrown when an image URL is not reachable.
 */
public class ImageUrlNotReachableException extends CatalogForgeException {

    private final String imageUrl;

    public ImageUrlNotReachableException(String imageUrl) {
        super(String.format("Image URL not reachable: %s", imageUrl));
        this.imageUrl = imageUrl;
    }

    public ImageUrlNotReachableException(String imageUrl, Throwable cause) {
        super(String.format("Image URL not reachable: %s", imageUrl), cause);
        this.imageUrl = imageUrl;
    }

    public String getImageUrl() {
        return imageUrl;
    }
}
</file>

<file path="src/main/java/com/catalogforge/exception/LayoutGenerationException.java">
package com.catalogforge.exception;

/**
 * Exception thrown when layout generation fails.
 */
public class LayoutGenerationException extends CatalogForgeException {

    public LayoutGenerationException(String message) {
        super(message);
    }

    public LayoutGenerationException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/catalogforge/exception/PdfGenerationException.java">
package com.catalogforge.exception;

/**
 * Exception thrown when PDF generation fails.
 */
public class PdfGenerationException extends CatalogForgeException {

    public PdfGenerationException(String message) {
        super(message);
    }

    public PdfGenerationException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/catalogforge/exception/ResourceNotFoundException.java">
package com.catalogforge.exception;

/**
 * Exception thrown when a requested resource is not found.
 */
public class ResourceNotFoundException extends CatalogForgeException {

    private final String resourceType;
    private final String resourceId;

    public ResourceNotFoundException(String resourceType, String resourceId) {
        super(String.format("%s not found: %s", resourceType, resourceId));
        this.resourceType = resourceType;
        this.resourceId = resourceId;
    }

    public String getResourceType() {
        return resourceType;
    }

    public String getResourceId() {
        return resourceId;
    }
}
</file>

<file path="src/main/java/com/catalogforge/exception/SkillLoadException.java">
package com.catalogforge.exception;

/**
 * Exception thrown when skill loading fails.
 */
public class SkillLoadException extends CatalogForgeException {

    public SkillLoadException(String message) {
        super(message);
    }

    public SkillLoadException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/catalogforge/gemini/GeminiClient.java">
package com.catalogforge.gemini;

import com.catalogforge.config.properties.GeminiProperties;
import com.catalogforge.exception.LayoutGenerationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;

import java.time.Duration;

/**
 * Client for communicating with the Gemini API.
 * Handles request/response serialization and error handling.
 */
@Component
public class GeminiClient {

    private static final Logger log = LoggerFactory.getLogger(GeminiClient.class);
    private static final String API_KEY_HEADER = "x-goog-api-key";

    private final WebClient webClient;
    private final GeminiProperties properties;

    public GeminiClient(GeminiProperties properties) {
        this.properties = properties;
        this.webClient = WebClient.builder()
                .baseUrl(properties.baseUrl())
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
        
        log.info("GeminiClient initialized: baseUrl={}, apiKeyConfigured={}", 
                properties.baseUrl(), 
                properties.apiKey() != null && !properties.apiKey().isBlank());
    }

    /**
     * Generates content using the specified model.
     * 
     * @param model The model identifier (e.g., "gemini-2.0-flash")
     * @param request The request payload
     * @return The response from Gemini
     */
    public GeminiResponse generate(String model, GeminiRequest request) {
        String endpoint = buildEndpoint(model);
        
        log.debug("Calling Gemini API: model={}, endpoint={}", model, endpoint);
        
        try {
            GeminiResponse response = webClient.post()
                    .uri(endpoint)
                    .header(API_KEY_HEADER, properties.apiKey())
                    .bodyValue(request)
                    .retrieve()
                    .bodyToMono(GeminiResponse.class)
                    .timeout(Duration.ofSeconds(properties.timeoutSeconds()))
                    .block();
            
            if (response == null) {
                throw new LayoutGenerationException("Empty response from Gemini API");
            }
            
            log.debug("Gemini response: success={}, tokens={}", 
                    response.isSuccess(), response.getTotalTokens());
            
            return response;
            
        } catch (WebClientResponseException e) {
            log.error("Gemini API error: status={}, body={}", 
                    e.getStatusCode(), e.getResponseBodyAsString());
            throw new LayoutGenerationException("Gemini API error: " + e.getMessage(), e);
        } catch (Exception e) {
            log.error("Failed to call Gemini API", e);
            throw new LayoutGenerationException("Failed to generate content: " + e.getMessage(), e);
        }
    }

    /**
     * Generates content asynchronously.
     */
    public Mono<GeminiResponse> generateAsync(String model, GeminiRequest request) {
        String endpoint = buildEndpoint(model);
        
        return webClient.post()
                .uri(endpoint)
                .header(API_KEY_HEADER, properties.apiKey())
                .bodyValue(request)
                .retrieve()
                .bodyToMono(GeminiResponse.class)
                .timeout(Duration.ofSeconds(properties.timeoutSeconds()));
    }

    private String buildEndpoint(String model) {
        return String.format("/models/%s:generateContent", model);
    }

    /**
     * Checks if the API key is configured.
     */
    public boolean isConfigured() {
        return properties.apiKey() != null && !properties.apiKey().isBlank();
    }
}
</file>

<file path="src/main/java/com/catalogforge/gemini/GeminiModelSelector.java">
package com.catalogforge.gemini;

/**
 * Selects the appropriate Gemini model based on task requirements.
 */
public class GeminiModelSelector {

    /**
     * Model for standard layout generation tasks.
     */
    public static final String MODEL_FLASH = "gemini-3-flash-preview";

    /**
     * Model for complex layouts requiring more reasoning.
     */
    public static final String MODEL_PRO = "gemini-3-flash-preview";

    /**
     * Model for image analysis tasks.
     */
    public static final String MODEL_VISION = "gemini-3-flash-preview";

    /**
     * Selects the appropriate model for layout generation.
     * 
     * @param isComplex Whether the layout is complex (multiple products, variants)
     * @param hasImage Whether the request includes image analysis
     * @return The model identifier
     */
    public static String selectModel(boolean isComplex, boolean hasImage) {
        if (hasImage) {
            return MODEL_VISION;
        }
        if (isComplex) {
            return MODEL_PRO;
        }
        return MODEL_FLASH;
    }

    /**
     * Selects model for simple text-to-layout generation.
     */
    public static String forSimpleLayout() {
        return MODEL_FLASH;
    }

    /**
     * Selects model for complex multi-variant generation.
     */
    public static String forComplexLayout() {
        return MODEL_PRO;
    }

    /**
     * Selects model for image analysis.
     */
    public static String forImageAnalysis() {
        return MODEL_VISION;
    }
}
</file>

<file path="src/main/java/com/catalogforge/gemini/GeminiRequest.java">
package com.catalogforge.gemini;

import java.util.List;
import java.util.Map;

/**
 * Request structure for Gemini API calls.
 * Supports text generation with optional system instructions and response schema.
 */
public record GeminiRequest(
    List<Content> contents,
    SystemInstruction systemInstruction,
    GenerationConfig generationConfig
) {
    
    public record Content(
        List<Part> parts,
        String role
    ) {}
    
    public record Part(
        String text,
        InlineData inlineData
    ) {
        public static Part text(String text) {
            return new Part(text, null);
        }
        
        public static Part image(String mimeType, String base64Data) {
            return new Part(null, new InlineData(mimeType, base64Data));
        }
    }
    
    public record InlineData(
        String mimeType,
        String data
    ) {}
    
    public record SystemInstruction(
        List<Part> parts
    ) {
        public static SystemInstruction of(String text) {
            return new SystemInstruction(List.of(Part.text(text)));
        }
    }
    
    public record GenerationConfig(
        String responseMimeType,
        Map<String, Object> responseSchema,
        Double temperature,
        Integer maxOutputTokens
    ) {}

    /**
     * Builder for creating GeminiRequest instances.
     */
    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private String userPrompt;
        private String systemInstruction;
        private String responseMimeType = "application/json";
        private Map<String, Object> responseSchema;
        private Double temperature = 0.7;
        private Integer maxOutputTokens = 8192;
        private String imageBase64;
        private String imageMimeType;

        public Builder userPrompt(String prompt) {
            this.userPrompt = prompt;
            return this;
        }

        public Builder systemInstruction(String instruction) {
            this.systemInstruction = instruction;
            return this;
        }

        public Builder responseMimeType(String mimeType) {
            this.responseMimeType = mimeType;
            return this;
        }

        public Builder responseSchema(Map<String, Object> schema) {
            this.responseSchema = schema;
            return this;
        }

        public Builder temperature(Double temp) {
            this.temperature = temp;
            return this;
        }

        public Builder maxOutputTokens(Integer tokens) {
            this.maxOutputTokens = tokens;
            return this;
        }

        public Builder image(String base64Data, String mimeType) {
            this.imageBase64 = base64Data;
            this.imageMimeType = mimeType;
            return this;
        }

        public GeminiRequest build() {
            List<Part> parts = new java.util.ArrayList<>();
            
            if (imageBase64 != null && imageMimeType != null) {
                parts.add(Part.image(imageMimeType, imageBase64));
            }
            
            if (userPrompt != null) {
                parts.add(Part.text(userPrompt));
            }

            Content content = new Content(parts, "user");
            
            SystemInstruction sysInstr = systemInstruction != null 
                    ? SystemInstruction.of(systemInstruction) 
                    : null;
            
            GenerationConfig config = new GenerationConfig(
                    responseMimeType,
                    responseSchema,
                    temperature,
                    maxOutputTokens
            );

            return new GeminiRequest(List.of(content), sysInstr, config);
        }
    }
}
</file>

<file path="src/main/java/com/catalogforge/gemini/GeminiResponse.java">
package com.catalogforge.gemini;

import java.util.List;

/**
 * Response structure from Gemini API.
 */
public record GeminiResponse(
    List<Candidate> candidates,
    UsageMetadata usageMetadata,
    String modelVersion
) {
    
    public record Candidate(
        Content content,
        String finishReason,
        Integer index,
        List<SafetyRating> safetyRatings
    ) {}
    
    public record Content(
        List<Part> parts,
        String role
    ) {}
    
    public record Part(
        String text
    ) {}
    
    public record SafetyRating(
        String category,
        String probability
    ) {}
    
    public record UsageMetadata(
        Integer promptTokenCount,
        Integer candidatesTokenCount,
        Integer totalTokenCount
    ) {}

    /**
     * Extracts the text content from the first candidate.
     * @return The generated text or null if not available
     */
    public String getText() {
        if (candidates == null || candidates.isEmpty()) {
            return null;
        }
        Candidate first = candidates.get(0);
        if (first.content() == null || first.content().parts() == null || first.content().parts().isEmpty()) {
            return null;
        }
        return first.content().parts().get(0).text();
    }

    /**
     * Checks if the response was successful.
     */
    public boolean isSuccess() {
        return candidates != null && !candidates.isEmpty() 
                && candidates.get(0).finishReason() != null
                && ("STOP".equals(candidates.get(0).finishReason()) 
                    || "MAX_TOKENS".equals(candidates.get(0).finishReason()));
    }

    /**
     * Gets the finish reason from the first candidate.
     */
    public String getFinishReason() {
        if (candidates == null || candidates.isEmpty()) {
            return null;
        }
        return candidates.get(0).finishReason();
    }

    /**
     * Gets the total token count.
     */
    public int getTotalTokens() {
        return usageMetadata != null && usageMetadata.totalTokenCount() != null 
                ? usageMetadata.totalTokenCount() 
                : 0;
    }

    /**
     * Gets the input/prompt token count.
     */
    public int getInputTokens() {
        return usageMetadata != null && usageMetadata.promptTokenCount() != null
                ? usageMetadata.promptTokenCount()
                : 0;
    }

    /**
     * Gets the output/candidates token count.
     */
    public int getOutputTokens() {
        return usageMetadata != null && usageMetadata.candidatesTokenCount() != null
                ? usageMetadata.candidatesTokenCount()
                : 0;
    }
}
</file>

<file path="src/main/java/com/catalogforge/gemini/GeminiVisionAnalyzer.java">
package com.catalogforge.gemini;

import com.catalogforge.model.ColorPalette;
import com.catalogforge.model.ImageAnalysisResult;
import com.catalogforge.model.LayoutHints;
import com.catalogforge.model.MoodAnalysis;
import com.catalogforge.util.JsonUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

/**
 * Analyzes images using Gemini Vision to extract color palettes, mood, and layout hints.
 */
@Component
public class GeminiVisionAnalyzer {

    private static final Logger log = LoggerFactory.getLogger(GeminiVisionAnalyzer.class);

    private final GeminiClient geminiClient;

    public GeminiVisionAnalyzer(GeminiClient geminiClient) {
        this.geminiClient = geminiClient;
    }

    /**
     * Analyzes an image and extracts design-relevant information.
     * 
     * @param imageBase64 Base64-encoded image data
     * @param mimeType Image MIME type (e.g., "image/jpeg")
     * @return Analysis result with color palette, mood, and layout hints
     */
    public ImageAnalysisResult analyzeImage(String imageBase64, String mimeType) {
        log.debug("Analyzing image: mimeType={}", mimeType);

        GeminiRequest request = GeminiRequest.builder()
                .systemInstruction(ANALYSIS_SYSTEM_PROMPT)
                .userPrompt(ANALYSIS_USER_PROMPT)
                .image(imageBase64, mimeType)
                .responseSchema(ANALYSIS_SCHEMA)
                .temperature(0.3)
                .build();

        GeminiResponse response = geminiClient.generate(
                GeminiModelSelector.forImageAnalysis(), 
                request
        );

        return parseAnalysisResponse(response);
    }

    private ImageAnalysisResult parseAnalysisResponse(GeminiResponse response) {
        String json = response.getText();
        if (json == null || json.isBlank()) {
            log.warn("Empty response from vision analysis");
            return createPlaceholderResult();
        }

        try {
            Map<String, Object> data = JsonUtils.fromJson(json, new TypeReference<>() {});
            
            ColorPalette colorPalette = parseColorPalette(data);
            MoodAnalysis moodAnalysis = parseMoodAnalysis(data);
            LayoutHints layoutHints = parseLayoutHints(data);

            return new ImageAnalysisResult(colorPalette, moodAnalysis, layoutHints);
            
        } catch (Exception e) {
            log.error("Failed to parse vision analysis response", e);
            return createPlaceholderResult();
        }
    }

    @SuppressWarnings("unchecked")
    private ColorPalette parseColorPalette(Map<String, Object> data) {
        Map<String, Object> palette = (Map<String, Object>) data.get("colorPalette");
        if (palette == null) {
            return new ColorPalette("#333333", "#666666", "#0066CC", "#F5F5F5", "#1A1A1A");
        }
        
        String primary = (String) palette.getOrDefault("primary", "#333333");
        String secondary = (String) palette.getOrDefault("secondary", "#666666");
        String accent = (String) palette.getOrDefault("accent", "#0066CC");
        String neutralLight = (String) palette.getOrDefault("neutralLight", "#F5F5F5");
        String neutralDark = (String) palette.getOrDefault("neutralDark", "#1A1A1A");
        
        return new ColorPalette(primary, secondary, accent, neutralLight, neutralDark);
    }

    @SuppressWarnings("unchecked")
    private MoodAnalysis parseMoodAnalysis(Map<String, Object> data) {
        Map<String, Object> mood = (Map<String, Object>) data.get("moodAnalysis");
        if (mood == null) {
            return new MoodAnalysis("professional", 0.8, List.of("clean", "modern"));
        }
        
        String type = (String) mood.getOrDefault("type", "professional");
        double confidence = mood.containsKey("confidence") 
                ? ((Number) mood.get("confidence")).doubleValue() 
                : 0.8;
        List<String> keywords = (List<String>) mood.getOrDefault("keywords", List.of());
        
        return new MoodAnalysis(type, confidence, keywords);
    }

    @SuppressWarnings("unchecked")
    private LayoutHints parseLayoutHints(Map<String, Object> data) {
        Map<String, Object> hints = (Map<String, Object>) data.get("layoutHints");
        if (hints == null) {
            return new LayoutHints("modular", "medium", "center", 2);
        }
        
        String gridType = (String) hints.getOrDefault("gridType", "modular");
        String density = (String) hints.getOrDefault("density", "medium");
        String focusArea = (String) hints.getOrDefault("focusArea", "center");
        int suggestedColumns = hints.containsKey("suggestedColumns") 
                ? ((Number) hints.get("suggestedColumns")).intValue() 
                : 2;
        
        return new LayoutHints(gridType, density, focusArea, suggestedColumns);
    }

    private ImageAnalysisResult createPlaceholderResult() {
        return new ImageAnalysisResult(
                new ColorPalette("#333333", "#666666", "#0066CC", "#F5F5F5", "#1A1A1A"),
                new MoodAnalysis("professional", 0.8, List.of("clean", "modern")),
                new LayoutHints("modular", "medium", "center", 2)
        );
    }

    private static final String ANALYSIS_SYSTEM_PROMPT = """
        You are an expert image analyst for design purposes.
        Analyze images to extract color palettes, mood/atmosphere, and layout suggestions.
        Always respond with valid JSON matching the specified schema.
        """;

    private static final String ANALYSIS_USER_PROMPT = """
        Analyze this image and extract:
        1. Color palette (primary, secondary, background, accent colors as hex codes)
        2. Mood analysis (overall mood, energy level, descriptive keywords)
        3. Layout hints (focal point position, orientation, text presence, complexity)
        """;

    private static final Map<String, Object> ANALYSIS_SCHEMA = Map.of(
            "type", "object",
            "properties", Map.of(
                    "colorPalette", Map.of(
                            "type", "object",
                            "properties", Map.of(
                                    "primary", Map.of("type", "string"),
                                    "secondary", Map.of("type", "string"),
                                    "accent", Map.of("type", "string"),
                                    "neutralLight", Map.of("type", "string"),
                                    "neutralDark", Map.of("type", "string")
                            )
                    ),
                    "moodAnalysis", Map.of(
                            "type", "object",
                            "properties", Map.of(
                                    "type", Map.of("type", "string"),
                                    "confidence", Map.of("type", "number"),
                                    "keywords", Map.of("type", "array", "items", Map.of("type", "string"))
                            )
                    ),
                    "layoutHints", Map.of(
                            "type", "object",
                            "properties", Map.of(
                                    "gridType", Map.of("type", "string"),
                                    "density", Map.of("type", "string"),
                                    "focusArea", Map.of("type", "string"),
                                    "suggestedColumns", Map.of("type", "integer")
                            )
                    )
            )
    );
}
</file>

<file path="src/main/java/com/catalogforge/logging/LlmInteractionLogger.java">
package com.catalogforge.logging;

import com.catalogforge.gemini.GeminiResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * High-level logger for LLM interactions.
 * Provides correlation between requests and responses via requestId.
 */
@Component
public class LlmInteractionLogger {

    private static final Logger log = LoggerFactory.getLogger(LlmInteractionLogger.class);
    private static final int MAX_SUMMARY_LENGTH = 200;

    private final LlmLogWriter logWriter;
    private final Map<String, Long> requestStartTimes = new ConcurrentHashMap<>();

    public LlmInteractionLogger(LlmLogWriter logWriter) {
        this.logWriter = logWriter;
    }

    /**
     * Generates a new unique request ID.
     */
    public String generateRequestId() {
        return UUID.randomUUID().toString();
    }

    /**
     * Logs an outgoing request to the LLM.
     * 
     * @param requestId Unique identifier for correlation
     * @param model The model being called
     * @param endpoint The API endpoint
     * @param prompt The prompt being sent (will be summarized)
     */
    public void logRequest(String requestId, String model, String endpoint, String prompt) {
        requestStartTimes.put(requestId, System.currentTimeMillis());
        
        String promptSummary = summarize(prompt);
        LlmLogEntry entry = LlmLogEntry.request(requestId, model, endpoint, promptSummary);
        
        logWriter.write(entry);
        log.debug("LLM Request [{}]: model={}, prompt={}", requestId, model, promptSummary);
    }

    /**
     * Logs a successful response from the LLM.
     * 
     * @param requestId The request ID for correlation
     * @param model The model that responded
     * @param response The Gemini response
     */
    public void logResponse(String requestId, String model, GeminiResponse response) {
        long durationMs = calculateDuration(requestId);
        
        String responseSummary = summarize(response.getText());
        int inputTokens = response.getInputTokens();
        int outputTokens = response.getOutputTokens();
        
        LlmLogEntry entry = LlmLogEntry.successResponse(
                requestId, model, inputTokens, outputTokens, durationMs, responseSummary
        );
        
        logWriter.write(entry);
        log.debug("LLM Response [{}]: tokens={}/{}, duration={}ms", 
                requestId, inputTokens, outputTokens, durationMs);
    }

    /**
     * Logs a successful response with custom token counts.
     */
    public void logResponse(String requestId, String model, String responseText, 
                           int inputTokens, int outputTokens) {
        long durationMs = calculateDuration(requestId);
        
        String responseSummary = summarize(responseText);
        LlmLogEntry entry = LlmLogEntry.successResponse(
                requestId, model, inputTokens, outputTokens, durationMs, responseSummary
        );
        
        logWriter.write(entry);
        log.debug("LLM Response [{}]: tokens={}/{}, duration={}ms", 
                requestId, inputTokens, outputTokens, durationMs);
    }

    /**
     * Logs an error response from the LLM.
     * 
     * @param requestId The request ID for correlation
     * @param model The model that was called
     * @param error The error that occurred
     */
    public void logError(String requestId, String model, Throwable error) {
        long durationMs = calculateDuration(requestId);
        
        String errorMessage = error.getMessage();
        LlmLogEntry entry = LlmLogEntry.errorResponse(requestId, model, durationMs, errorMessage);
        
        logWriter.write(entry);
        log.warn("LLM Error [{}]: model={}, error={}, duration={}ms", 
                requestId, model, errorMessage, durationMs);
    }

    /**
     * Logs an error with a custom message.
     */
    public void logError(String requestId, String model, String errorMessage) {
        long durationMs = calculateDuration(requestId);
        
        LlmLogEntry entry = LlmLogEntry.errorResponse(requestId, model, durationMs, errorMessage);
        
        logWriter.write(entry);
        log.warn("LLM Error [{}]: model={}, error={}, duration={}ms", 
                requestId, model, errorMessage, durationMs);
    }

    /**
     * Logs a timeout.
     */
    public void logTimeout(String requestId, String model) {
        long durationMs = calculateDuration(requestId);
        
        LlmLogEntry entry = LlmLogEntry.timeoutResponse(requestId, model, durationMs);
        
        logWriter.write(entry);
        log.warn("LLM Timeout [{}]: model={}, duration={}ms", requestId, model, durationMs);
    }

    private long calculateDuration(String requestId) {
        Long startTime = requestStartTimes.remove(requestId);
        if (startTime == null) {
            return 0;
        }
        return System.currentTimeMillis() - startTime;
    }

    private String summarize(String text) {
        if (text == null || text.isBlank()) {
            return "";
        }
        String cleaned = text.replaceAll("\\s+", " ").trim();
        if (cleaned.length() <= MAX_SUMMARY_LENGTH) {
            return cleaned;
        }
        return cleaned.substring(0, MAX_SUMMARY_LENGTH - 3) + "...";
    }
}
</file>

<file path="src/main/java/com/catalogforge/logging/LlmLogEntry.java">
package com.catalogforge.logging;

import java.time.Instant;
import java.util.Map;

/**
 * Log entry for LLM interactions.
 * Each entry represents either a request to or response from the LLM.
 */
public record LlmLogEntry(
    String requestId,
    Instant timestamp,
    Direction direction,
    String model,
    String endpoint,
    Status status,
    Integer inputTokens,
    Integer outputTokens,
    Long durationMs,
    String promptSummary,
    String responseSummary,
    String errorMessage,
    Map<String, Object> metadata
) {
    
    public enum Direction {
        REQUEST, RESPONSE
    }
    
    public enum Status {
        SUCCESS, ERROR, TIMEOUT
    }
    
    /**
     * Creates a request log entry.
     */
    public static LlmLogEntry request(String requestId, String model, String endpoint, String promptSummary) {
        return new LlmLogEntry(
                requestId,
                Instant.now(),
                Direction.REQUEST,
                model,
                endpoint,
                null,
                null,
                null,
                null,
                promptSummary,
                null,
                null,
                null
        );
    }
    
    /**
     * Creates a success response log entry.
     */
    public static LlmLogEntry successResponse(
            String requestId, 
            String model, 
            int inputTokens, 
            int outputTokens,
            long durationMs,
            String responseSummary
    ) {
        return new LlmLogEntry(
                requestId,
                Instant.now(),
                Direction.RESPONSE,
                model,
                null,
                Status.SUCCESS,
                inputTokens,
                outputTokens,
                durationMs,
                null,
                responseSummary,
                null,
                null
        );
    }
    
    /**
     * Creates an error response log entry.
     */
    public static LlmLogEntry errorResponse(
            String requestId,
            String model,
            long durationMs,
            String errorMessage
    ) {
        return new LlmLogEntry(
                requestId,
                Instant.now(),
                Direction.RESPONSE,
                model,
                null,
                Status.ERROR,
                null,
                null,
                durationMs,
                null,
                null,
                errorMessage,
                null
        );
    }
    
    /**
     * Creates a timeout response log entry.
     */
    public static LlmLogEntry timeoutResponse(String requestId, String model, long durationMs) {
        return new LlmLogEntry(
                requestId,
                Instant.now(),
                Direction.RESPONSE,
                model,
                null,
                Status.TIMEOUT,
                null,
                null,
                durationMs,
                null,
                null,
                "Request timed out",
                null
        );
    }
    
    /**
     * Returns a copy with additional metadata.
     */
    public LlmLogEntry withMetadata(Map<String, Object> additionalMetadata) {
        return new LlmLogEntry(
                requestId, timestamp, direction, model, endpoint, status,
                inputTokens, outputTokens, durationMs, promptSummary,
                responseSummary, errorMessage, additionalMetadata
        );
    }
}
</file>

<file path="src/main/java/com/catalogforge/logging/LlmLogWriter.java">
package com.catalogforge.logging;

import com.catalogforge.util.JsonUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import jakarta.annotation.PreDestroy;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Writes LLM log entries to daily JSONL files.
 * Thread-safe implementation with automatic date-based file rotation.
 */
@Component
public class LlmLogWriter {

    private static final Logger log = LoggerFactory.getLogger(LlmLogWriter.class);
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private static final String FILE_SUFFIX = "_llm.jsonl";

    private final Path logDirectory;
    private final ReentrantLock lock = new ReentrantLock();
    
    private BufferedWriter currentWriter;
    private LocalDate currentDate;
    private Path currentFilePath;

    public LlmLogWriter(@Value("${catalogforge.logging.llm-dir:logs/llm}") String logDir) {
        this.logDirectory = Path.of(logDir);
        initializeDirectory();
    }

    private void initializeDirectory() {
        try {
            Files.createDirectories(logDirectory);
            log.info("LLM log directory initialized: {}", logDirectory.toAbsolutePath());
        } catch (IOException e) {
            log.error("Failed to create LLM log directory: {}", logDirectory, e);
        }
    }

    /**
     * Writes a log entry to the current day's JSONL file.
     * 
     * @param entry The log entry to write
     */
    public void write(LlmLogEntry entry) {
        lock.lock();
        try {
            ensureWriterForToday();
            if (currentWriter != null) {
                String json = JsonUtils.toJson(entry);
                currentWriter.write(json);
                currentWriter.newLine();
                currentWriter.flush();
            }
        } catch (IOException e) {
            log.error("Failed to write LLM log entry: {}", entry.requestId(), e);
        } finally {
            lock.unlock();
        }
    }

    private void ensureWriterForToday() throws IOException {
        LocalDate today = LocalDate.now();
        
        if (currentWriter == null || !today.equals(currentDate)) {
            closeCurrentWriter();
            currentDate = today;
            currentFilePath = logDirectory.resolve(today.format(DATE_FORMAT) + FILE_SUFFIX);
            currentWriter = Files.newBufferedWriter(
                    currentFilePath,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.APPEND
            );
            log.debug("Opened new LLM log file: {}", currentFilePath);
        }
    }

    private void closeCurrentWriter() {
        if (currentWriter != null) {
            try {
                currentWriter.close();
                log.debug("Closed LLM log file: {}", currentFilePath);
            } catch (IOException e) {
                log.error("Failed to close LLM log file", e);
            }
            currentWriter = null;
        }
    }

    /**
     * Returns the path to today's log file.
     */
    public Path getCurrentLogFile() {
        return logDirectory.resolve(LocalDate.now().format(DATE_FORMAT) + FILE_SUFFIX);
    }

    /**
     * Returns the log directory path.
     */
    public Path getLogDirectory() {
        return logDirectory;
    }

    @PreDestroy
    public void shutdown() {
        lock.lock();
        try {
            closeCurrentWriter();
        } finally {
            lock.unlock();
        }
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/request/ImageLayoutOptions.java">
package com.catalogforge.model.request;

/**
 * Options for image-to-layout generation.
 */
public record ImageLayoutOptions(
    String pageFormat,
    boolean extractColors,
    boolean analyzeMood,
    boolean analyzeLayout
) {
    public ImageLayoutOptions {
        if (pageFormat == null || pageFormat.isBlank()) pageFormat = "A4";
    }

    /**
     * Create default options with all analysis enabled.
     */
    public static ImageLayoutOptions defaults() {
        return new ImageLayoutOptions("A4", true, true, true);
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/request/ImageToLayoutRequest.java">
package com.catalogforge.model.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

/**
 * Request for image-to-layout generation.
 */
public record ImageToLayoutRequest(
    @Size(min = 1, message = "At least one product ID is required")
    List<Long> productIds,
    
    LayoutOptions options,
    
    @Size(max = 5000, message = "Prompt must not exceed 5000 characters")
    String prompt,
    
    @NotBlank(message = "Image data is required")
    String imageBase64,
    
    @NotBlank(message = "Image MIME type is required")
    String imageMimeType
) {
    public ImageToLayoutRequest {
        if (productIds == null) productIds = List.of();
        if (options == null) options = LayoutOptions.defaults();
        if (prompt == null) prompt = "";
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/request/LayoutOptions.java">
package com.catalogforge.model.request;

/**
 * Options for text-to-layout generation.
 */
public record LayoutOptions(
    String pageFormat,
    String style,
    int variantCount,
    boolean includeSpecs,
    boolean complexStrategy
) {
    public LayoutOptions {
        if (pageFormat == null || pageFormat.isBlank()) pageFormat = "A4";
        if (variantCount <= 0) variantCount = 1;
    }

    /**
     * Create default options.
     */
    public static LayoutOptions defaults() {
        return new LayoutOptions("A4", null, 1, true, false);
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/request/LayoutUpdateRequest.java">
package com.catalogforge.model.request;

import jakarta.validation.constraints.NotBlank;

/**
 * Request for updating an existing layout.
 */
public record LayoutUpdateRequest(
    @NotBlank(message = "HTML content is required")
    String html,
    
    @NotBlank(message = "CSS content is required")
    String css
) {}
</file>

<file path="src/main/java/com/catalogforge/model/request/PdfGenerationRequest.java">
package com.catalogforge.model.request;

import jakarta.validation.constraints.NotBlank;

/**
 * Request for PDF generation from a layout.
 */
public record PdfGenerationRequest(
    @NotBlank(message = "Layout ID is required")
    String layoutId,
    
    String printPreset
) {
    public PdfGenerationRequest {
        if (printPreset == null || printPreset.isBlank()) printPreset = "print-standard";
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/request/TextToLayoutRequest.java">
package com.catalogforge.model.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.List;

/**
 * Request for text-to-layout generation.
 */
public record TextToLayoutRequest(
    @Size(min = 1, message = "At least one product ID is required")
    List<Long> productIds,
    
    LayoutOptions options,
    
    @NotBlank(message = "User prompt is required")
    @Size(max = 5000, message = "Prompt must not exceed 5000 characters")
    String prompt
) {
    public TextToLayoutRequest {
        if (productIds == null) productIds = List.of();
        if (options == null) options = LayoutOptions.defaults();
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/response/ErrorResponse.java">
package com.catalogforge.model.response;

import java.time.Instant;

/**
 * Standard error response format for all API errors.
 */
public record ErrorResponse(
    Instant timestamp,
    int status,
    String error,
    String message,
    String path
) {
    /**
     * Create an error response with current timestamp.
     */
    public static ErrorResponse of(int status, String error, String message, String path) {
        return new ErrorResponse(Instant.now(), status, error, message, path);
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/response/ImageUploadResponse.java">
package com.catalogforge.model.response;

import java.time.Instant;

/**
 * Response for image upload.
 */
public record ImageUploadResponse(
    String imageId,
    String url,
    String mimeType,
    Instant expiresAt
) {}
</file>

<file path="src/main/java/com/catalogforge/model/response/LayoutResponse.java">
package com.catalogforge.model.response;

import com.catalogforge.model.Layout;
import com.catalogforge.model.LayoutVariant;

import java.time.Instant;
import java.util.List;

/**
 * Response containing generated layout data.
 */
public record LayoutResponse(
    String id,
    String status,
    Instant generatedAt,
    String pageFormat,
    List<VariantResponse> variants,
    int variantCount
) {
    
    public record VariantResponse(
        String id,
        String html,
        String css
    ) {
        public static VariantResponse from(LayoutVariant variant) {
            return new VariantResponse(variant.id(), variant.html(), variant.css());
        }
    }
    
    public static LayoutResponse from(Layout layout) {
        List<VariantResponse> variants = layout.variants().stream()
                .map(VariantResponse::from)
                .toList();
        
        return new LayoutResponse(
                layout.id(),
                layout.status(),
                layout.generatedAt(),
                layout.pageFormat() != null ? layout.pageFormat().name() : "A4",
                variants,
                variants.size()
        );
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/response/PdfResponse.java">
package com.catalogforge.model.response;

/**
 * Response for PDF generation requests.
 */
public record PdfResponse(
    String pdfId,
    String downloadUrl
) {}
</file>

<file path="src/main/java/com/catalogforge/model/response/ProductListResponse.java">
package com.catalogforge.model.response;

import java.util.List;

import com.catalogforge.model.Product;

/**
 * Paginated response for product list requests.
 */
public record ProductListResponse(
    List<Product> products,
    int page,
    int size,
    long totalElements,
    int totalPages
) {
    public ProductListResponse {
        products = products != null ? List.copyOf(products) : List.of();
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/ColorPalette.java">
package com.catalogforge.model;

/**
 * Color palette extracted from an image via LLM vision analysis.
 * All colors are hex codes (e.g., "#1a1a2e").
 */
public record ColorPalette(
    String primary,
    String secondary,
    String accent,
    String neutralLight,
    String neutralDark
) {}
</file>

<file path="src/main/java/com/catalogforge/model/ImageAnalysisResult.java">
package com.catalogforge.model;

/**
 * Complete result of LLM-based image analysis.
 * Contains color palette, mood analysis, and layout hints.
 */
public record ImageAnalysisResult(
    ColorPalette colorPalette,
    MoodAnalysis mood,
    LayoutHints layoutHints
) {}
</file>

<file path="src/main/java/com/catalogforge/model/Layout.java">
package com.catalogforge.model;

import java.time.Instant;
import java.util.List;

/**
 * Represents a generated layout with all its variants and metadata.
 */
public record Layout(
    String id,
    String status,
    Instant generatedAt,
    PageFormat pageFormat,
    ImageAnalysisResult imageAnalysis,
    List<LayoutVariant> variants,
    LayoutMetadata metadata
) {
    public Layout {
        variants = variants != null ? List.copyOf(variants) : List.of();
    }

    /**
     * Create a new Layout with updated variants.
     */
    public Layout withVariants(List<LayoutVariant> newVariants) {
        return new Layout(id, status, generatedAt, pageFormat, imageAnalysis, newVariants, metadata);
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/LayoutHints.java">
package com.catalogforge.model;

/**
 * Layout hints extracted from an image via LLM vision analysis.
 * Provides suggestions for layout structure based on the reference image.
 */
public record LayoutHints(
    String gridType,
    String density,
    String focusArea,
    int suggestedColumns
) {}
</file>

<file path="src/main/java/com/catalogforge/model/LayoutMetadata.java">
package com.catalogforge.model;

import java.util.List;

/**
 * Metadata about a layout generation process.
 */
public record LayoutMetadata(
    List<String> skillsUsed,
    long generationTimeMs,
    int llmCallCount
) {
    public LayoutMetadata {
        skillsUsed = skillsUsed != null ? List.copyOf(skillsUsed) : List.of();
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/LayoutVariant.java">
package com.catalogforge.model;

/**
 * A single layout variant containing generated HTML and CSS.
 */
public record LayoutVariant(
    String id,
    String html,
    String css
) {}
</file>

<file path="src/main/java/com/catalogforge/model/MoodAnalysis.java">
package com.catalogforge.model;

import java.util.List;

/**
 * Mood analysis result from LLM vision analysis.
 * Describes the visual style and feeling of an image.
 */
public record MoodAnalysis(
    String type,
    double confidence,
    List<String> keywords
) {
    public MoodAnalysis {
        keywords = keywords != null ? List.copyOf(keywords) : List.of();
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/PageFormat.java">
package com.catalogforge.model;

/**
 * Represents a page format for layout generation.
 * Dimensions are typically in millimeters for print output.
 */
public record PageFormat(
    String name,
    int width,
    int height,
    String unit
) {
    // Common page formats
    public static final PageFormat A4 = new PageFormat("A4", 210, 297, "mm");
    public static final PageFormat A5 = new PageFormat("A5", 148, 210, "mm");
    public static final PageFormat A6 = new PageFormat("A6", 105, 148, "mm");
    public static final PageFormat DL = new PageFormat("DL", 99, 210, "mm");
    public static final PageFormat SQUARE = new PageFormat("SQUARE", 210, 210, "mm");

    /**
     * Get a PageFormat by name.
     */
    public static PageFormat fromName(String name) {
        return switch (name.toUpperCase()) {
            case "A4" -> A4;
            case "A5" -> A5;
            case "A6" -> A6;
            case "DL" -> DL;
            case "SQUARE" -> SQUARE;
            default -> A4;
        };
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/Product.java">
package com.catalogforge.model;

import java.util.List;

/**
 * Represents a product in the catalog.
 * Products are loaded from products.json and used for layout generation.
 * 
 * Contains multiple text variants for different layout needs:
 * - shortDescription: 1-2 sentences for compact layouts
 * - description: ~150 words for standard layouts  
 * - longDescription: 300+ words for detailed product pages
 * - highlights: Feature list for bullet-point displays
 */
public record Product(
    Long id,
    String name,
    String shortDescription,
    String description,
    String longDescription,
    String category,
    String series,
    TechnicalData specs,
    List<String> highlights,
    String imageUrl,
    Integer priceEur
) {
    public Product {
        highlights = highlights != null ? List.copyOf(highlights) : List.of();
    }
}
</file>

<file path="src/main/java/com/catalogforge/model/Skill.java">
package com.catalogforge.model;

import java.util.List;

/**
 * Represents a skill (prompt template) for layout generation.
 * Skills are loaded from markdown files in resources/skills/.
 */
public record Skill(
    String name,
    String category,
    String content,
    List<String> dependencies,
    int priority
) {
    public Skill {
        dependencies = dependencies != null ? List.copyOf(dependencies) : List.of();
    }

    /**
     * Default priority for skills without explicit priority.
     */
    public static final int DEFAULT_PRIORITY = 100;

    /**
     * Priority for the master skill (always first).
     */
    public static final int MASTER_PRIORITY = 0;
}
</file>

<file path="src/main/java/com/catalogforge/model/TechnicalData.java">
package com.catalogforge.model;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;

import java.util.Map;

/**
 * Technical specifications for a product.
 * Contains key-value pairs of specification data.
 * Serializes/deserializes directly as a Map for cleaner JSON structure.
 */
public record TechnicalData(
    Map<String, String> specifications
) {
    public TechnicalData {
        specifications = specifications != null ? Map.copyOf(specifications) : Map.of();
    }

    /**
     * Creates TechnicalData directly from a Map (for JSON deserialization).
     */
    @JsonCreator
    public static TechnicalData fromMap(Map<String, String> specs) {
        return new TechnicalData(specs);
    }

    /**
     * Returns the specifications map directly (for JSON serialization).
     */
    @JsonValue
    public Map<String, String> specifications() {
        return specifications;
    }
}
</file>

<file path="src/main/java/com/catalogforge/pdf/PdfOptions.java">
package com.catalogforge.pdf;

/**
 * Options for PDF generation.
 */
public record PdfOptions(
    PrintPreset preset,
    String pageFormat,
    boolean landscape,
    String headerHtml,
    String footerHtml
) {
    public PdfOptions {
        if (preset == null) preset = PrintPreset.SCREEN;
        if (pageFormat == null || pageFormat.isBlank()) pageFormat = "A4";
    }

    public static PdfOptions defaults() {
        return new PdfOptions(PrintPreset.SCREEN, "A4", false, null, null);
    }

    public static PdfOptions forPrint() {
        return new PdfOptions(PrintPreset.PRINT_STANDARD, "A4", false, null, null);
    }

    public static PdfOptions forProfessionalPrint() {
        return new PdfOptions(PrintPreset.PRINT_PROFESSIONAL, "A4", false, null, null);
    }
}
</file>

<file path="src/main/java/com/catalogforge/pdf/PrintPreset.java">
package com.catalogforge.pdf;

/**
 * Print presets for PDF generation.
 * Defines quality settings for different output purposes.
 */
public enum PrintPreset {
    
    SCREEN("screen", 72, 0, false, "Screen viewing"),
    PRINT_STANDARD("print-standard", 150, 0, false, "Standard office printing"),
    PRINT_PROFESSIONAL("print-professional", 300, 3, true, "Professional printing"),
    PRINT_PREMIUM("print-premium", 300, 5, true, "Premium printing with bleed");

    private final String name;
    private final int dpi;
    private final int bleedMm;
    private final boolean cropMarks;
    private final String description;

    PrintPreset(String name, int dpi, int bleedMm, boolean cropMarks, String description) {
        this.name = name;
        this.dpi = dpi;
        this.bleedMm = bleedMm;
        this.cropMarks = cropMarks;
        this.description = description;
    }

    public String getName() {
        return name;
    }

    public int getDpi() {
        return dpi;
    }

    public int getBleedMm() {
        return bleedMm;
    }

    public boolean hasCropMarks() {
        return cropMarks;
    }

    public String getDescription() {
        return description;
    }

    public static PrintPreset fromName(String name) {
        for (PrintPreset preset : values()) {
            if (preset.name.equalsIgnoreCase(name)) {
                return preset;
            }
        }
        return SCREEN;
    }
}
</file>

<file path="src/main/java/com/catalogforge/pdf/PuppeteerBridge.java">
package com.catalogforge.pdf;

import com.catalogforge.exception.PdfGenerationException;
import com.catalogforge.util.JsonUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Bridge to Puppeteer/Node.js for PDF generation.
 * Communicates via stdin/stdout JSON.
 */
@Component
public class PuppeteerBridge {

    private static final Logger log = LoggerFactory.getLogger(PuppeteerBridge.class);
    private static final int TIMEOUT_SECONDS = 60;

    private final String nodeCommand;
    private final String scriptPath;
    private final boolean enabled;

    public PuppeteerBridge(
            @Value("${catalogforge.pdf.node-command:node}") String nodeCommand,
            @Value("${catalogforge.pdf.script-path:scripts/pdf-generator.js}") String scriptPath,
            @Value("${catalogforge.pdf.enabled:false}") boolean enabled
    ) {
        this.nodeCommand = nodeCommand;
        this.scriptPath = scriptPath;
        this.enabled = enabled;
    }

    /**
     * Generates a PDF from HTML content.
     * 
     * @param html The HTML content
     * @param css The CSS styles
     * @param options PDF generation options
     * @return Path to the generated PDF file
     */
    public Path generatePdf(String html, String css, PdfOptions options) {
        if (!enabled) {
            log.warn("PDF generation is disabled, returning placeholder");
            return createPlaceholderPdf(options);
        }

        log.debug("Generating PDF: preset={}, format={}", 
                options.preset().getName(), options.pageFormat());

        try {
            // Prepare input JSON
            Map<String, Object> input = Map.of(
                    "html", html,
                    "css", css,
                    "preset", options.preset().getName(),
                    "pageFormat", options.pageFormat(),
                    "landscape", options.landscape(),
                    "dpi", options.preset().getDpi(),
                    "bleedMm", options.preset().getBleedMm(),
                    "cropMarks", options.preset().hasCropMarks()
            );
            String inputJson = JsonUtils.toJson(input);

            // Execute Node.js script
            ProcessBuilder pb = new ProcessBuilder(nodeCommand, scriptPath);
            pb.redirectErrorStream(false);
            
            Process process = pb.start();

            // Write input to stdin
            try (OutputStream stdin = process.getOutputStream()) {
                stdin.write(inputJson.getBytes());
                stdin.flush();
            }

            // Read output from stdout
            String output;
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()))) {
                output = reader.lines().reduce("", (a, b) -> a + b);
            }

            // Read errors
            String errors;
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getErrorStream()))) {
                errors = reader.lines().reduce("", (a, b) -> a + "\n" + b);
            }

            boolean completed = process.waitFor(TIMEOUT_SECONDS, TimeUnit.SECONDS);
            if (!completed) {
                process.destroyForcibly();
                throw new PdfGenerationException("PDF generation timed out");
            }

            int exitCode = process.exitValue();
            if (exitCode != 0) {
                log.error("PDF generation failed: exitCode={}, errors={}", exitCode, errors);
                throw new PdfGenerationException("PDF generation failed: " + errors);
            }

            // Parse output
            Map<String, Object> result = JsonUtils.fromJson(output, new TypeReference<>() {});
            String pdfPath = (String) result.get("pdfPath");
            
            if (pdfPath == null) {
                throw new PdfGenerationException("No PDF path in response");
            }

            log.info("PDF generated: {}", pdfPath);
            return Path.of(pdfPath);

        } catch (IOException | InterruptedException e) {
            log.error("PDF generation error", e);
            throw new PdfGenerationException("PDF generation failed: " + e.getMessage(), e);
        }
    }

    /**
     * Creates a placeholder PDF when generation is disabled.
     */
    private Path createPlaceholderPdf(PdfOptions options) {
        try {
            Path tempFile = Files.createTempFile("placeholder-", ".pdf");
            // Write minimal PDF content
            String minimalPdf = "%PDF-1.4\n1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj\n" +
                    "2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj\n" +
                    "3 0 obj<</Type/Page/MediaBox[0 0 612 792]/Parent 2 0 R>>endobj\n" +
                    "xref\n0 4\n0000000000 65535 f\n0000000009 00000 n\n" +
                    "0000000052 00000 n\n0000000101 00000 n\n" +
                    "trailer<</Size 4/Root 1 0 R>>\nstartxref\n178\n%%EOF";
            Files.writeString(tempFile, minimalPdf);
            return tempFile;
        } catch (IOException e) {
            throw new PdfGenerationException("Failed to create placeholder PDF", e);
        }
    }

    /**
     * Checks if PDF generation is enabled.
     */
    public boolean isEnabled() {
        return enabled;
    }
}
</file>

<file path="src/main/java/com/catalogforge/service/ImageService.java">
package com.catalogforge.service;

import com.catalogforge.exception.ImageUploadException;
import com.catalogforge.exception.ResourceNotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Service for temporary image storage and management.
 */
@Service
public class ImageService {

    private static final Logger log = LoggerFactory.getLogger(ImageService.class);
    
    private static final Set<String> ALLOWED_MIME_TYPES = Set.of(
            "image/jpeg", "image/png", "image/webp"
    );
    private static final long MAX_SIZE_BYTES = 10 * 1024 * 1024; // 10MB
    private static final int URL_VALIDITY_HOURS = 24;

    private final Map<String, StoredImage> imageStore = new ConcurrentHashMap<>();
    private final String baseUrl;

    public ImageService(@Value("${catalogforge.base-url:http://localhost:8080}") String baseUrl) {
        this.baseUrl = baseUrl;
    }

    /**
     * Uploads and stores an image temporarily.
     * 
     * @param base64Data Base64-encoded image data
     * @param mimeType Image MIME type
     * @param filename Original filename (optional)
     * @return The generated image ID
     */
    public String upload(String base64Data, String mimeType, String filename) {
        validateMimeType(mimeType);
        
        byte[] data = Base64.getDecoder().decode(base64Data);
        validateSize(data.length);
        
        String imageId = UUID.randomUUID().toString();
        Instant expiresAt = Instant.now().plus(URL_VALIDITY_HOURS, ChronoUnit.HOURS);
        
        StoredImage image = new StoredImage(
                imageId,
                data,
                mimeType,
                filename,
                Instant.now(),
                expiresAt
        );
        
        imageStore.put(imageId, image);
        log.info("Image uploaded: id={}, size={} bytes, mimeType={}", 
                imageId, data.length, mimeType);
        
        return imageId;
    }

    /**
     * Generates a URL for accessing the image.
     */
    public String generateUrl(String imageId) {
        if (!imageStore.containsKey(imageId)) {
            throw new ResourceNotFoundException("Image", imageId);
        }
        return baseUrl + "/api/v1/images/" + imageId;
    }

    /**
     * Retrieves an image by ID.
     */
    public StoredImage getImage(String imageId) {
        StoredImage image = imageStore.get(imageId);
        if (image == null) {
            throw new ResourceNotFoundException("Image", imageId);
        }
        
        if (image.isExpired()) {
            imageStore.remove(imageId);
            throw new ResourceNotFoundException("Image", imageId);
        }
        
        return image;
    }

    /**
     * Retrieves image as Base64.
     */
    public String getImageBase64(String imageId) {
        StoredImage image = getImage(imageId);
        return Base64.getEncoder().encodeToString(image.data());
    }

    /**
     * Checks if an image exists and is valid.
     */
    public boolean exists(String imageId) {
        StoredImage image = imageStore.get(imageId);
        return image != null && !image.isExpired();
    }

    /**
     * Deletes an image.
     */
    public void delete(String imageId) {
        if (imageStore.remove(imageId) == null) {
            throw new ResourceNotFoundException("Image", imageId);
        }
        log.info("Image deleted: id={}", imageId);
    }

    /**
     * Scheduled cleanup of expired images.
     * Runs every hour.
     */
    @Scheduled(fixedRate = 3600000) // 1 hour
    public void cleanup() {
        int before = imageStore.size();
        
        imageStore.entrySet().removeIf(entry -> entry.getValue().isExpired());
        
        int removed = before - imageStore.size();
        if (removed > 0) {
            log.info("Cleaned up {} expired images", removed);
        }
    }

    /**
     * Returns the number of stored images.
     */
    public int getImageCount() {
        return imageStore.size();
    }

    private void validateMimeType(String mimeType) {
        if (mimeType == null || !ALLOWED_MIME_TYPES.contains(mimeType.toLowerCase())) {
            throw new ImageUploadException(
                    "Invalid image type: " + mimeType + ". Allowed: " + ALLOWED_MIME_TYPES
            );
        }
    }

    private void validateSize(long size) {
        if (size > MAX_SIZE_BYTES) {
            throw new ImageUploadException(
                    "Image too large: " + size + " bytes. Maximum: " + MAX_SIZE_BYTES + " bytes"
            );
        }
    }

    /**
     * Stored image record.
     */
    public record StoredImage(
            String id,
            byte[] data,
            String mimeType,
            String filename,
            Instant uploadedAt,
            Instant expiresAt
    ) {
        public boolean isExpired() {
            return Instant.now().isAfter(expiresAt);
        }
    }
}
</file>

<file path="src/main/java/com/catalogforge/service/LayoutGenerationService.java">
package com.catalogforge.service;

import com.catalogforge.agent.AgentContext;
import com.catalogforge.agent.AgentOrchestrator;
import com.catalogforge.exception.LayoutGenerationException;
import com.catalogforge.exception.ResourceNotFoundException;
import com.catalogforge.model.Layout;
import com.catalogforge.model.LayoutVariant;
import com.catalogforge.model.Product;
import com.catalogforge.model.request.LayoutOptions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Service for layout generation and lifecycle management.
 */
@Service
public class LayoutGenerationService {

    private static final Logger log = LoggerFactory.getLogger(LayoutGenerationService.class);

    private final AgentOrchestrator orchestrator;
    private final ProductService productService;
    private final Map<String, Layout> layoutStore = new ConcurrentHashMap<>();

    public LayoutGenerationService(AgentOrchestrator orchestrator, ProductService productService) {
        this.orchestrator = orchestrator;
        this.productService = productService;
    }

    /**
     * Generates a layout from text prompt.
     */
    public Layout generateFromText(List<Long> productIds, LayoutOptions options, String userPrompt) {
        log.info("Generating layout from text: products={}, options={}", productIds, options);
        
        List<Product> products = resolveProducts(productIds);
        
        AgentContext context = AgentContext.forTextGeneration(products, options, userPrompt);
        AgentContext result = orchestrator.execute(context);
        
        if (result.generatedLayout() == null) {
            throw new LayoutGenerationException("Layout generation failed - no layout produced");
        }
        
        Layout layout = result.generatedLayout();
        layoutStore.put(layout.id(), layout);
        
        log.info("Layout generated: id={}, variants={}", layout.id(), layout.variants().size());
        return layout;
    }

    /**
     * Generates a layout from image reference.
     */
    public Layout generateFromImage(
            List<Long> productIds, 
            LayoutOptions options, 
            String userPrompt,
            String imageBase64,
            String imageMimeType
    ) {
        log.info("Generating layout from image: products={}, mimeType={}", productIds, imageMimeType);
        
        List<Product> products = resolveProducts(productIds);
        
        AgentContext context = AgentContext.forImageGeneration(
                products, options, userPrompt, imageBase64, imageMimeType
        );
        AgentContext result = orchestrator.execute(context);
        
        if (result.generatedLayout() == null) {
            throw new LayoutGenerationException("Layout generation failed - no layout produced");
        }
        
        Layout layout = result.generatedLayout();
        layoutStore.put(layout.id(), layout);
        
        log.info("Layout generated from image: id={}, variants={}", 
                layout.id(), layout.variants().size());
        return layout;
    }

    /**
     * Retrieves a layout by ID.
     */
    public Layout getLayout(String layoutId) {
        return Optional.ofNullable(layoutStore.get(layoutId))
                .orElseThrow(() -> new ResourceNotFoundException("Layout", layoutId));
    }

    /**
     * Retrieves a layout by ID, returning Optional.
     */
    public Optional<Layout> findLayout(String layoutId) {
        return Optional.ofNullable(layoutStore.get(layoutId));
    }

    /**
     * Updates a layout.
     */
    public Layout updateLayout(String layoutId, Layout updatedLayout) {
        if (!layoutStore.containsKey(layoutId)) {
            throw new ResourceNotFoundException("Layout", layoutId);
        }
        
        layoutStore.put(layoutId, updatedLayout);
        log.info("Layout updated: id={}", layoutId);
        return updatedLayout;
    }

    /**
     * Deletes a layout.
     */
    public void deleteLayout(String layoutId) {
        if (layoutStore.remove(layoutId) == null) {
            throw new ResourceNotFoundException("Layout", layoutId);
        }
        log.info("Layout deleted: id={}", layoutId);
    }

    /**
     * Gets all variants for a layout.
     */
    public List<LayoutVariant> getVariants(String layoutId) {
        Layout layout = getLayout(layoutId);
        return layout.variants();
    }

    /**
     * Gets a specific variant.
     */
    public LayoutVariant getVariant(String layoutId, String variantId) {
        Layout layout = getLayout(layoutId);
        return layout.variants().stream()
                .filter(v -> v.id().equals(variantId))
                .findFirst()
                .orElseThrow(() -> new ResourceNotFoundException("Variant", variantId));
    }

    /**
     * Returns the number of stored layouts.
     */
    public int getLayoutCount() {
        return layoutStore.size();
    }

    private List<Product> resolveProducts(List<Long> productIds) {
        if (productIds == null || productIds.isEmpty()) {
            return List.of();
        }
        
        return productIds.stream()
                .map(id -> productService.findProductById(id)
                        .orElseThrow(() -> new ResourceNotFoundException("Product", id.toString())))
                .toList();
    }
}
</file>

<file path="src/main/java/com/catalogforge/service/PdfGenerationService.java">
package com.catalogforge.service;

import com.catalogforge.exception.PdfGenerationException;
import com.catalogforge.exception.ResourceNotFoundException;
import com.catalogforge.model.Layout;
import com.catalogforge.model.LayoutVariant;
import com.catalogforge.pdf.PdfOptions;
import com.catalogforge.pdf.PrintPreset;
import com.catalogforge.pdf.PuppeteerBridge;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Service for PDF generation from layouts.
 */
@Service
public class PdfGenerationService {

    private static final Logger log = LoggerFactory.getLogger(PdfGenerationService.class);

    private final LayoutGenerationService layoutService;
    private final PuppeteerBridge puppeteerBridge;
    private final Map<String, GeneratedPdf> pdfStore = new ConcurrentHashMap<>();

    public PdfGenerationService(LayoutGenerationService layoutService, PuppeteerBridge puppeteerBridge) {
        this.layoutService = layoutService;
        this.puppeteerBridge = puppeteerBridge;
    }

    /**
     * Generates a PDF from a layout.
     * 
     * @param layoutId The layout ID
     * @param variantId Optional variant ID (uses first variant if null)
     * @param presetName Print preset name
     * @return The generated PDF ID
     */
    public String generate(String layoutId, String variantId, String presetName) {
        log.info("Generating PDF: layoutId={}, variantId={}, preset={}", 
                layoutId, variantId, presetName);

        Layout layout = layoutService.getLayout(layoutId);
        LayoutVariant variant = resolveVariant(layout, variantId);
        PrintPreset preset = PrintPreset.fromName(presetName);

        String html = buildFullHtml(variant, layout);
        String css = variant.css();

        PdfOptions options = new PdfOptions(
                preset,
                layout.pageFormat() != null ? layout.pageFormat().name() : "A4",
                false,
                null,
                null
        );

        Path pdfPath = puppeteerBridge.generatePdf(html, css, options);
        
        String pdfId = UUID.randomUUID().toString();
        GeneratedPdf pdf = new GeneratedPdf(
                pdfId,
                layoutId,
                variantId,
                preset,
                pdfPath
        );
        
        pdfStore.put(pdfId, pdf);
        log.info("PDF generated: pdfId={}, path={}", pdfId, pdfPath);
        
        return pdfId;
    }

    /**
     * Gets a generated PDF by ID.
     */
    public GeneratedPdf getPdf(String pdfId) {
        return Optional.ofNullable(pdfStore.get(pdfId))
                .orElseThrow(() -> new ResourceNotFoundException("PDF", pdfId));
    }

    /**
     * Gets the PDF file content.
     */
    public byte[] getPdfContent(String pdfId) {
        GeneratedPdf pdf = getPdf(pdfId);
        try {
            return Files.readAllBytes(pdf.path());
        } catch (IOException e) {
            throw new PdfGenerationException("Failed to read PDF file", e);
        }
    }

    /**
     * Deletes a generated PDF.
     */
    public void deletePdf(String pdfId) {
        GeneratedPdf pdf = pdfStore.remove(pdfId);
        if (pdf == null) {
            throw new ResourceNotFoundException("PDF", pdfId);
        }
        
        try {
            Files.deleteIfExists(pdf.path());
            log.info("PDF deleted: pdfId={}", pdfId);
        } catch (IOException e) {
            log.warn("Failed to delete PDF file: {}", pdf.path(), e);
        }
    }

    private LayoutVariant resolveVariant(Layout layout, String variantId) {
        if (layout.variants() == null || layout.variants().isEmpty()) {
            throw new PdfGenerationException("Layout has no variants");
        }

        if (variantId == null || variantId.isBlank()) {
            return layout.variants().get(0);
        }

        return layout.variants().stream()
                .filter(v -> v.id().equals(variantId))
                .findFirst()
                .orElseThrow(() -> new ResourceNotFoundException("Variant", variantId));
    }

    private String buildFullHtml(LayoutVariant variant, Layout layout) {
        String format = layout.pageFormat() != null ? layout.pageFormat().name() : "A4";
        
        return String.format("""
                <!DOCTYPE html>
                <html lang="de">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>CatalogForge Layout</title>
                    <style>
                        @page {
                            size: %s;
                            margin: 0;
                        }
                        %s
                    </style>
                </head>
                <body>
                    %s
                </body>
                </html>
                """, format, variant.css(), variant.html());
    }

    /**
     * Record for stored PDF metadata.
     */
    public record GeneratedPdf(
            String id,
            String layoutId,
            String variantId,
            PrintPreset preset,
            Path path
    ) {}
}
</file>

<file path="src/main/java/com/catalogforge/service/ProductService.java">
package com.catalogforge.service;

import com.catalogforge.exception.ResourceNotFoundException;
import com.catalogforge.model.Product;
import com.catalogforge.util.JsonUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Service for managing product data.
 * Loads products from JSON file at startup and provides filtering, search, and lookup operations.
 */
@Service
public class ProductService {

    private static final Logger log = LoggerFactory.getLogger(ProductService.class);
    private static final String PRODUCTS_FILE = "data/products.json";

    private final Map<Long, Product> productsById = new ConcurrentHashMap<>();
    private final List<Product> allProducts = new ArrayList<>();
    private volatile Set<String> cachedCategories;
    private volatile Set<String> cachedSeries;

    @PostConstruct
    public void init() {
        loadProducts();
    }

    /**
     * Loads products from the JSON file into memory.
     */
    void loadProducts() {
        try {
            ClassPathResource resource = new ClassPathResource(PRODUCTS_FILE);
            try (InputStream is = resource.getInputStream()) {
                List<Product> products = JsonUtils.fromJson(is, new TypeReference<>() {});
                
                productsById.clear();
                allProducts.clear();
                
                for (Product product : products) {
                    productsById.put(product.id(), product);
                    allProducts.add(product);
                }
                
                // Invalidate caches
                cachedCategories = null;
                cachedSeries = null;
                
                log.info("Loaded {} products from {}", allProducts.size(), PRODUCTS_FILE);
            }
        } catch (IOException e) {
            log.error("Failed to load products from {}", PRODUCTS_FILE, e);
            throw new IllegalStateException("Could not load products", e);
        }
    }

    /**
     * Returns all products.
     */
    public List<Product> getAllProducts() {
        return Collections.unmodifiableList(allProducts);
    }

    /**
     * Returns a product by ID.
     * @throws ResourceNotFoundException if product not found
     */
    public Product getProductById(Long id) {
        Product product = productsById.get(id);
        if (product == null) {
            throw new ResourceNotFoundException("Product", String.valueOf(id));
        }
        return product;
    }

    /**
     * Returns an optional product by ID.
     */
    public Optional<Product> findProductById(Long id) {
        return Optional.ofNullable(productsById.get(id));
    }

    /**
     * Filters products by category and/or series.
     * Both filters are optional and case-insensitive.
     */
    public List<Product> filterProducts(String category, String series) {
        return allProducts.stream()
                .filter(p -> category == null || p.category().equalsIgnoreCase(category))
                .filter(p -> series == null || p.series().equalsIgnoreCase(series))
                .toList();
    }

    /**
     * Searches products by query string.
     * Performs case-insensitive full-text search across name, description, shortDescription, and series.
     */
    public List<Product> searchProducts(String query) {
        if (query == null || query.isBlank()) {
            return getAllProducts();
        }
        
        String lowerQuery = query.toLowerCase(Locale.ROOT);
        
        return allProducts.stream()
                .filter(p -> matchesQuery(p, lowerQuery))
                .toList();
    }

    private boolean matchesQuery(Product product, String lowerQuery) {
        return containsIgnoreCase(product.name(), lowerQuery)
                || containsIgnoreCase(product.shortDescription(), lowerQuery)
                || containsIgnoreCase(product.description(), lowerQuery)
                || containsIgnoreCase(product.series(), lowerQuery)
                || containsIgnoreCase(product.category(), lowerQuery);
    }

    private boolean containsIgnoreCase(String text, String query) {
        return text != null && text.toLowerCase(Locale.ROOT).contains(query);
    }

    /**
     * Returns all unique categories, sorted alphabetically.
     */
    public Set<String> getAllCategories() {
        Set<String> categories = cachedCategories;
        if (categories == null) {
            categories = allProducts.stream()
                    .map(Product::category)
                    .filter(Objects::nonNull)
                    .collect(Collectors.toCollection(TreeSet::new));
            cachedCategories = categories;
        }
        return Collections.unmodifiableSet(categories);
    }

    /**
     * Returns all unique series, sorted alphabetically.
     */
    public Set<String> getAllSeries() {
        Set<String> series = cachedSeries;
        if (series == null) {
            series = allProducts.stream()
                    .map(Product::series)
                    .filter(Objects::nonNull)
                    .collect(Collectors.toCollection(TreeSet::new));
            cachedSeries = series;
        }
        return Collections.unmodifiableSet(series);
    }

    /**
     * Returns the total number of products.
     */
    public int getProductCount() {
        return allProducts.size();
    }
}
</file>

<file path="src/main/java/com/catalogforge/service/SkillsService.java">
package com.catalogforge.service;

import com.catalogforge.model.Skill;
import com.catalogforge.skill.SkillAssembler;
import com.catalogforge.skill.SkillLoader;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Service for managing and assembling skills.
 * Provides caching and high-level operations for skill management.
 */
@Service
public class SkillsService {

    private static final Logger log = LoggerFactory.getLogger(SkillsService.class);

    private final SkillLoader skillLoader;
    private final SkillAssembler skillAssembler;
    
    private volatile Map<String, Skill> skillCache = Map.of();

    public SkillsService(SkillLoader skillLoader, SkillAssembler skillAssembler) {
        this.skillLoader = skillLoader;
        this.skillAssembler = skillAssembler;
    }

    @PostConstruct
    public void init() {
        reloadSkills();
    }

    /**
     * Reloads all skills from disk.
     */
    public void reloadSkills() {
        skillCache = skillLoader.loadAllSkills();
        log.info("Skills cache refreshed with {} skills", skillCache.size());
    }

    /**
     * Returns all loaded skills.
     */
    public Collection<Skill> getAllSkills() {
        return Collections.unmodifiableCollection(skillCache.values());
    }

    /**
     * Returns a skill by name.
     */
    public Optional<Skill> getSkill(String name) {
        return Optional.ofNullable(skillCache.get(name));
    }

    /**
     * Returns all skills in a specific category.
     */
    public List<Skill> getSkillsByCategory(String category) {
        return skillCache.values().stream()
                .filter(s -> s.category().equalsIgnoreCase(category))
                .sorted(Comparator.comparing(Skill::name))
                .toList();
    }

    /**
     * Returns all unique categories.
     */
    public Set<String> getAllCategories() {
        return skillCache.values().stream()
                .map(Skill::category)
                .collect(Collectors.toCollection(TreeSet::new));
    }

    /**
     * Assembles a prompt from the specified skills.
     * 
     * @param skillNames List of skill names to include
     * @param style Optional style (e.g., "modern", "technical")
     * @param format Optional format (e.g., "A4", "DL")
     * @return Assembled prompt string
     */
    public String assemblePrompt(List<String> skillNames, String style, String format) {
        return skillAssembler.assemble(skillCache, skillNames, style, format);
    }

    /**
     * Returns the ordered list of skill names that would be included in assembly.
     */
    public List<String> getAssemblyOrder(List<String> skillNames, String style, String format) {
        return skillAssembler.getOrderedSkillNames(skillCache, skillNames, style, format);
    }

    /**
     * Returns the total number of loaded skills.
     */
    public int getSkillCount() {
        return skillCache.size();
    }
}
</file>

<file path="src/main/java/com/catalogforge/skill/SkillAssembler.java">
package com.catalogforge.skill;

import com.catalogforge.model.Skill;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * Assembles skills into a combined prompt.
 * Handles dependency resolution, priority ordering, and style/format skill inclusion.
 */
@Component
public class SkillAssembler {

    private static final Logger log = LoggerFactory.getLogger(SkillAssembler.class);
    private static final String MASTER_SKILL = "MASTER_SKILL";

    /**
     * Assembles skills into a combined prompt string.
     * 
     * @param skills Map of all available skills
     * @param requestedSkills List of skill names to include
     * @param style Optional style skill name (e.g., "STYLE_MODERN")
     * @param format Optional format skill name (e.g., "FORMAT_A4")
     * @return Combined prompt string
     */
    public String assemble(Map<String, Skill> skills, List<String> requestedSkills, 
                          String style, String format) {
        
        Set<String> toInclude = new LinkedHashSet<>();
        
        // 1. Always include MASTER_SKILL first
        if (skills.containsKey(MASTER_SKILL)) {
            toInclude.add(MASTER_SKILL);
        }
        
        // 2. Add requested skills with their dependencies
        for (String skillName : requestedSkills) {
            addWithDependencies(skills, skillName, toInclude, new HashSet<>());
        }
        
        // 3. Add style skill if specified
        if (style != null && !style.isBlank()) {
            String styleSkill = normalizeStyleName(style);
            addWithDependencies(skills, styleSkill, toInclude, new HashSet<>());
        }
        
        // 4. Add format skill if specified
        if (format != null && !format.isBlank()) {
            String formatSkill = normalizeFormatName(format);
            addWithDependencies(skills, formatSkill, toInclude, new HashSet<>());
        }
        
        // 5. Sort by priority (MASTER first, then by priority, then alphabetically)
        List<Skill> orderedSkills = toInclude.stream()
                .map(skills::get)
                .filter(Objects::nonNull)
                .sorted(Comparator
                        .comparingInt(Skill::priority)
                        .thenComparing(Skill::name))
                .toList();
        
        // 6. Combine contents
        StringBuilder combined = new StringBuilder();
        for (Skill skill : orderedSkills) {
            if (!combined.isEmpty()) {
                combined.append("\n\n---\n\n");
            }
            combined.append("# ").append(skill.name()).append("\n\n");
            combined.append(skill.content());
        }
        
        log.debug("Assembled {} skills: {}", orderedSkills.size(), 
                orderedSkills.stream().map(Skill::name).toList());
        
        return combined.toString();
    }

    /**
     * Recursively adds a skill and its dependencies to the include set.
     */
    void addWithDependencies(Map<String, Skill> skills, String skillName, 
                            Set<String> toInclude, Set<String> visited) {
        if (skillName == null || visited.contains(skillName)) {
            return;
        }
        
        visited.add(skillName);
        Skill skill = skills.get(skillName);
        
        if (skill == null) {
            log.warn("Skill not found: {}", skillName);
            return;
        }
        
        // Add dependencies first
        for (String dep : skill.dependencies()) {
            addWithDependencies(skills, dep, toInclude, visited);
        }
        
        // Then add the skill itself
        toInclude.add(skillName);
    }

    /**
     * Normalizes style name to skill name format.
     * e.g., "modern" -> "STYLE_MODERN"
     */
    String normalizeStyleName(String style) {
        String upper = style.toUpperCase(Locale.ROOT);
        if (upper.startsWith("STYLE_")) {
            return upper;
        }
        return "STYLE_" + upper;
    }

    /**
     * Normalizes format name to skill name format.
     * e.g., "A4" -> "FORMAT_A4"
     */
    String normalizeFormatName(String format) {
        String upper = format.toUpperCase(Locale.ROOT);
        if (upper.startsWith("FORMAT_")) {
            return upper;
        }
        return "FORMAT_" + upper;
    }

    /**
     * Gets the ordered list of skill names that would be included.
     * Useful for debugging and testing.
     */
    public List<String> getOrderedSkillNames(Map<String, Skill> skills, List<String> requestedSkills,
                                             String style, String format) {
        Set<String> toInclude = new LinkedHashSet<>();
        
        if (skills.containsKey(MASTER_SKILL)) {
            toInclude.add(MASTER_SKILL);
        }
        
        for (String skillName : requestedSkills) {
            addWithDependencies(skills, skillName, toInclude, new HashSet<>());
        }
        
        if (style != null && !style.isBlank()) {
            addWithDependencies(skills, normalizeStyleName(style), toInclude, new HashSet<>());
        }
        
        if (format != null && !format.isBlank()) {
            addWithDependencies(skills, normalizeFormatName(format), toInclude, new HashSet<>());
        }
        
        return toInclude.stream()
                .map(skills::get)
                .filter(Objects::nonNull)
                .sorted(Comparator
                        .comparingInt(Skill::priority)
                        .thenComparing(Skill::name))
                .map(Skill::name)
                .toList();
    }
}
</file>

<file path="src/main/java/com/catalogforge/skill/SkillLoader.java">
package com.catalogforge.skill;

import com.catalogforge.exception.SkillLoadException;
import com.catalogforge.model.Skill;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Loads skill files from resources/skills/ directory.
 * Parses metadata headers and extracts skill content.
 */
@Component
public class SkillLoader {

    private static final Logger log = LoggerFactory.getLogger(SkillLoader.class);
    private static final String SKILLS_PATTERN = "classpath:skills/**/*.md";
    
    // Metadata patterns
    private static final Pattern METADATA_BLOCK = Pattern.compile("^---\\s*\\n(.*?)\\n---\\s*\\n", Pattern.DOTALL);
    private static final Pattern DEPENDENCIES_PATTERN = Pattern.compile("dependencies:\\s*\\[([^\\]]*)]");
    private static final Pattern PRIORITY_PATTERN = Pattern.compile("priority:\\s*(\\d+)");

    private final PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();

    /**
     * Loads all skills from the skills directory.
     * @return Map of skill name to Skill object
     */
    public Map<String, Skill> loadAllSkills() {
        Map<String, Skill> skills = new HashMap<>();
        
        try {
            Resource[] resources = resolver.getResources(SKILLS_PATTERN);
            
            for (Resource resource : resources) {
                try {
                    Skill skill = loadSkill(resource);
                    skills.put(skill.name(), skill);
                    log.debug("Loaded skill: {} (category: {}, priority: {})", 
                            skill.name(), skill.category(), skill.priority());
                } catch (Exception e) {
                    log.warn("Failed to load skill from {}: {}", resource.getFilename(), e.getMessage());
                }
            }
            
            log.info("Loaded {} skills from {}", skills.size(), SKILLS_PATTERN);
            
        } catch (IOException e) {
            throw new SkillLoadException("Failed to scan skills directory", e);
        }
        
        return skills;
    }

    /**
     * Loads a single skill from a resource.
     */
    Skill loadSkill(Resource resource) throws IOException {
        String filename = resource.getFilename();
        if (filename == null) {
            throw new SkillLoadException("Resource has no filename");
        }
        
        String content = resource.getContentAsString(StandardCharsets.UTF_8);
        String name = extractName(filename);
        String category = extractCategory(resource);
        
        // Parse metadata
        List<String> dependencies = List.of();
        int priority = Skill.DEFAULT_PRIORITY;
        String skillContent = content;
        
        Matcher metaMatcher = METADATA_BLOCK.matcher(content);
        if (metaMatcher.find()) {
            String metadata = metaMatcher.group(1);
            dependencies = parseDependencies(metadata);
            priority = parsePriority(metadata);
            skillContent = content.substring(metaMatcher.end());
        }
        
        // Master skill always has priority 0
        if ("MASTER_SKILL".equals(name)) {
            priority = Skill.MASTER_PRIORITY;
        }
        
        return new Skill(name, category, skillContent.trim(), dependencies, priority);
    }

    /**
     * Extracts skill name from filename (removes .md extension).
     */
    String extractName(String filename) {
        return filename.endsWith(".md") 
                ? filename.substring(0, filename.length() - 3) 
                : filename;
    }

    /**
     * Extracts category from resource path.
     * e.g., "skills/core/LAYOUT.md" -> "core"
     */
    String extractCategory(Resource resource) throws IOException {
        String path = resource.getURL().getPath();
        
        // Find "skills/" in path and extract next segment
        int skillsIdx = path.indexOf("skills/");
        if (skillsIdx >= 0) {
            String afterSkills = path.substring(skillsIdx + 7);
            int slashIdx = afterSkills.indexOf('/');
            if (slashIdx > 0) {
                return afterSkills.substring(0, slashIdx);
            }
        }
        
        return "default";
    }

    /**
     * Parses dependencies from metadata block.
     * Format: dependencies: [DEP1, DEP2]
     */
    List<String> parseDependencies(String metadata) {
        Matcher matcher = DEPENDENCIES_PATTERN.matcher(metadata);
        if (matcher.find()) {
            String deps = matcher.group(1).trim();
            if (deps.isEmpty()) {
                return List.of();
            }
            return Arrays.stream(deps.split(","))
                    .map(String::trim)
                    .filter(s -> !s.isEmpty())
                    .toList();
        }
        return List.of();
    }

    /**
     * Parses priority from metadata block.
     * Format: priority: 10
     */
    int parsePriority(String metadata) {
        Matcher matcher = PRIORITY_PATTERN.matcher(metadata);
        if (matcher.find()) {
            return Integer.parseInt(matcher.group(1));
        }
        return Skill.DEFAULT_PRIORITY;
    }
}
</file>

<file path="src/main/java/com/catalogforge/util/ColorUtils.java">
package com.catalogforge.util;

import java.util.regex.Pattern;

/**
 * Utility for color validation and WCAG contrast calculations.
 */
public final class ColorUtils {

    // Pattern for 3-digit hex (#RGB)
    private static final Pattern HEX_3_PATTERN = Pattern.compile("^#[0-9A-Fa-f]{3}$");
    
    // Pattern for 6-digit hex (#RRGGBB)
    private static final Pattern HEX_6_PATTERN = Pattern.compile("^#[0-9A-Fa-f]{6}$");

    private ColorUtils() {
        // Utility class
    }

    /**
     * Validate a hex color code.
     *
     * @param color the color to validate
     * @return true if valid hex color (#RGB or #RRGGBB)
     */
    public static boolean isValidHexColor(String color) {
        if (color == null || color.isEmpty()) {
            return false;
        }
        return HEX_3_PATTERN.matcher(color).matches() 
            || HEX_6_PATTERN.matcher(color).matches();
    }

    /**
     * Calculate WCAG contrast ratio between two colors.
     * 
     * @param color1 first color (hex format)
     * @param color2 second color (hex format)
     * @return contrast ratio (1.0 to 21.0)
     * @throws IllegalArgumentException if colors are invalid
     */
    public static double calculateContrastRatio(String color1, String color2) {
        if (!isValidHexColor(color1) || !isValidHexColor(color2)) {
            throw new IllegalArgumentException("Invalid hex color format");
        }

        double luminance1 = calculateRelativeLuminance(color1);
        double luminance2 = calculateRelativeLuminance(color2);

        double lighter = Math.max(luminance1, luminance2);
        double darker = Math.min(luminance1, luminance2);

        return (lighter + 0.05) / (darker + 0.05);
    }

    /**
     * Calculate relative luminance of a color.
     * Based on WCAG 2.0 formula.
     */
    public static double calculateRelativeLuminance(String hexColor) {
        int[] rgb = hexToRgb(hexColor);
        
        double r = linearize(rgb[0] / 255.0);
        double g = linearize(rgb[1] / 255.0);
        double b = linearize(rgb[2] / 255.0);

        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }

    /**
     * Convert hex color to RGB array.
     */
    public static int[] hexToRgb(String hexColor) {
        String hex = hexColor.substring(1); // Remove #
        
        if (hex.length() == 3) {
            // Expand 3-digit to 6-digit
            hex = "" + hex.charAt(0) + hex.charAt(0) 
                     + hex.charAt(1) + hex.charAt(1) 
                     + hex.charAt(2) + hex.charAt(2);
        }

        return new int[] {
            Integer.parseInt(hex.substring(0, 2), 16),
            Integer.parseInt(hex.substring(2, 4), 16),
            Integer.parseInt(hex.substring(4, 6), 16)
        };
    }

    /**
     * Linearize a color channel value for luminance calculation.
     */
    private static double linearize(double value) {
        if (value <= 0.03928) {
            return value / 12.92;
        }
        return Math.pow((value + 0.055) / 1.055, 2.4);
    }

    /**
     * Check if contrast ratio meets WCAG AA standard for normal text (4.5:1).
     */
    public static boolean meetsWcagAA(String color1, String color2) {
        return calculateContrastRatio(color1, color2) >= 4.5;
    }

    /**
     * Check if contrast ratio meets WCAG AAA standard for normal text (7:1).
     */
    public static boolean meetsWcagAAA(String color1, String color2) {
        return calculateContrastRatio(color1, color2) >= 7.0;
    }
}
</file>

<file path="src/main/java/com/catalogforge/util/CssValidator.java">
package com.catalogforge.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Utility for validating CSS content.
 */
public final class CssValidator {

    // Valid print units
    private static final Pattern PRINT_UNITS_PATTERN = Pattern.compile(
        "\\d+(\\.\\d+)?\\s*(mm|cm|pt|in|px|em|rem|%|vh|vw)"
    );

    private CssValidator() {
        // Utility class
    }

    /**
     * Validation result containing validity status and any warnings/errors.
     */
    public record ValidationResult(boolean isValid, List<String> errors, List<String> warnings) {
        public static ValidationResult valid() {
            return new ValidationResult(true, List.of(), List.of());
        }

        public static ValidationResult invalid(List<String> errors) {
            return new ValidationResult(false, errors, List.of());
        }

        public static ValidationResult withWarnings(List<String> warnings) {
            return new ValidationResult(true, List.of(), warnings);
        }
    }

    /**
     * Validate CSS syntax.
     *
     * @param css the CSS to validate
     * @return validation result
     */
    public static ValidationResult validate(String css) {
        if (css == null || css.isEmpty()) {
            return ValidationResult.valid();
        }

        List<String> errors = new ArrayList<>();
        List<String> warnings = new ArrayList<>();

        // Check for balanced brackets
        if (!hasBalancedBrackets(css)) {
            errors.add("Unbalanced brackets in CSS");
        }

        // Check for balanced parentheses
        if (!hasBalancedParentheses(css)) {
            errors.add("Unbalanced parentheses in CSS");
        }

        if (!errors.isEmpty()) {
            return ValidationResult.invalid(errors);
        }

        if (!warnings.isEmpty()) {
            return ValidationResult.withWarnings(warnings);
        }

        return ValidationResult.valid();
    }

    /**
     * Check if CSS has balanced curly brackets.
     */
    public static boolean hasBalancedBrackets(String css) {
        int count = 0;
        boolean inString = false;
        char stringChar = 0;

        for (int i = 0; i < css.length(); i++) {
            char c = css.charAt(i);

            // Handle string literals
            if ((c == '"' || c == '\'') && (i == 0 || css.charAt(i - 1) != '\\')) {
                if (!inString) {
                    inString = true;
                    stringChar = c;
                } else if (c == stringChar) {
                    inString = false;
                }
                continue;
            }

            if (!inString) {
                if (c == '{') {
                    count++;
                } else if (c == '}') {
                    count--;
                    if (count < 0) {
                        return false;
                    }
                }
            }
        }

        return count == 0;
    }

    /**
     * Check if CSS has balanced parentheses.
     */
    public static boolean hasBalancedParentheses(String css) {
        int count = 0;
        boolean inString = false;
        char stringChar = 0;

        for (int i = 0; i < css.length(); i++) {
            char c = css.charAt(i);

            // Handle string literals
            if ((c == '"' || c == '\'') && (i == 0 || css.charAt(i - 1) != '\\')) {
                if (!inString) {
                    inString = true;
                    stringChar = c;
                } else if (c == stringChar) {
                    inString = false;
                }
                continue;
            }

            if (!inString) {
                if (c == '(') {
                    count++;
                } else if (c == ')') {
                    count--;
                    if (count < 0) {
                        return false;
                    }
                }
            }
        }

        return count == 0;
    }

    /**
     * Check if a value contains valid print units.
     */
    public static boolean containsPrintUnits(String value) {
        return PRINT_UNITS_PATTERN.matcher(value).find();
    }
}
</file>

<file path="src/main/java/com/catalogforge/util/FileUtils.java">
package com.catalogforge.util;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * Utility for file operations.
 */
public final class FileUtils {

    private FileUtils() {
        // Utility class
    }

    /**
     * Read file content as string from classpath.
     *
     * @param resourcePath path relative to classpath (e.g., "data/products.json")
     * @return file content as string
     * @throws IOException if file cannot be read
     */
    public static String readClasspathResource(String resourcePath) throws IOException {
        Resource resource = new ClassPathResource(resourcePath);
        try (InputStream is = resource.getInputStream()) {
            return new String(is.readAllBytes(), StandardCharsets.UTF_8);
        }
    }

    /**
     * Read file content as string from filesystem.
     *
     * @param path file path
     * @return file content as string
     * @throws IOException if file cannot be read
     */
    public static String readFile(Path path) throws IOException {
        return Files.readString(path, StandardCharsets.UTF_8);
    }

    /**
     * Write string content to file.
     *
     * @param path file path
     * @param content content to write
     * @throws IOException if file cannot be written
     */
    public static void writeFile(Path path, String content) throws IOException {
        Files.createDirectories(path.getParent());
        Files.writeString(path, content, StandardCharsets.UTF_8);
    }

    /**
     * Append string content to file.
     *
     * @param path file path
     * @param content content to append
     * @throws IOException if file cannot be written
     */
    public static void appendToFile(Path path, String content) throws IOException {
        Files.createDirectories(path.getParent());
        Files.writeString(path, content, StandardCharsets.UTF_8, 
            java.nio.file.StandardOpenOption.CREATE,
            java.nio.file.StandardOpenOption.APPEND);
    }

    /**
     * Check if a classpath resource exists.
     */
    public static boolean classpathResourceExists(String resourcePath) {
        return new ClassPathResource(resourcePath).exists();
    }

    /**
     * Get file extension from filename.
     */
    public static String getExtension(String filename) {
        if (filename == null) {
            return "";
        }
        int lastDot = filename.lastIndexOf('.');
        if (lastDot == -1) {
            return "";
        }
        return filename.substring(lastDot + 1).toLowerCase();
    }
}
</file>

<file path="src/main/java/com/catalogforge/util/HtmlSanitizer.java">
package com.catalogforge.util;

import java.util.regex.Pattern;

/**
 * Utility for sanitizing HTML content.
 * Removes potentially dangerous elements while preserving structure.
 */
public final class HtmlSanitizer {

    // Pattern to match script tags and their content
    private static final Pattern SCRIPT_PATTERN = Pattern.compile(
        "<script[^>]*>.*?</script>",
        Pattern.CASE_INSENSITIVE | Pattern.DOTALL
    );

    // Pattern to match event handler attributes
    private static final Pattern EVENT_HANDLER_PATTERN = Pattern.compile(
        "\\s+on\\w+\\s*=\\s*([\"'][^\"']*[\"']|[^\\s>]+)",
        Pattern.CASE_INSENSITIVE
    );

    // Pattern to match javascript: URLs
    private static final Pattern JAVASCRIPT_URL_PATTERN = Pattern.compile(
        "(href|src)\\s*=\\s*[\"']?\\s*javascript:[^\"'\\s>]*[\"']?",
        Pattern.CASE_INSENSITIVE
    );

    // Pattern to match data: URLs (potential XSS vector)
    private static final Pattern DATA_URL_PATTERN = Pattern.compile(
        "(href|src)\\s*=\\s*[\"']?\\s*data:[^\"'\\s>]*[\"']?",
        Pattern.CASE_INSENSITIVE
    );

    private HtmlSanitizer() {
        // Utility class
    }

    /**
     * Sanitize HTML by removing dangerous elements.
     * Preserves structural elements and CSS classes.
     *
     * @param html the HTML to sanitize
     * @return sanitized HTML
     */
    public static String sanitize(String html) {
        if (html == null || html.isEmpty()) {
            return html;
        }

        String result = html;

        // Remove script tags and content
        result = SCRIPT_PATTERN.matcher(result).replaceAll("");

        // Remove event handlers
        result = EVENT_HANDLER_PATTERN.matcher(result).replaceAll("");

        // Remove javascript: URLs
        result = JAVASCRIPT_URL_PATTERN.matcher(result).replaceAll("");

        // Remove data: URLs
        result = DATA_URL_PATTERN.matcher(result).replaceAll("");

        return result;
    }

    /**
     * Check if HTML contains potentially dangerous content.
     *
     * @param html the HTML to check
     * @return true if dangerous content is detected
     */
    public static boolean containsDangerousContent(String html) {
        if (html == null || html.isEmpty()) {
            return false;
        }

        return SCRIPT_PATTERN.matcher(html).find()
            || EVENT_HANDLER_PATTERN.matcher(html).find()
            || JAVASCRIPT_URL_PATTERN.matcher(html).find()
            || DATA_URL_PATTERN.matcher(html).find();
    }
}
</file>

<file path="src/main/java/com/catalogforge/util/JsonUtils.java">
package com.catalogforge.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import java.io.IOException;
import java.io.InputStream;

/**
 * Utility for JSON serialization and deserialization.
 */
public final class JsonUtils {

    private static final ObjectMapper MAPPER = createObjectMapper();

    private JsonUtils() {
        // Utility class
    }

    private static ObjectMapper createObjectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        return mapper;
    }

    /**
     * Get the shared ObjectMapper instance.
     */
    public static ObjectMapper getMapper() {
        return MAPPER;
    }

    /**
     * Serialize object to JSON string.
     */
    public static String toJson(Object obj) {
        try {
            return MAPPER.writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to serialize to JSON", e);
        }
    }

    /**
     * Serialize object to pretty-printed JSON string.
     */
    public static String toPrettyJson(Object obj) {
        try {
            return MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to serialize to JSON", e);
        }
    }

    /**
     * Deserialize JSON string to object.
     */
    public static <T> T fromJson(String json, Class<T> clazz) {
        try {
            return MAPPER.readValue(json, clazz);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to deserialize from JSON", e);
        }
    }

    /**
     * Deserialize JSON from InputStream using TypeReference for generic types.
     */
    public static <T> T fromJson(InputStream is, TypeReference<T> typeRef) throws IOException {
        return MAPPER.readValue(is, typeRef);
    }

    /**
     * Deserialize JSON string using TypeReference for generic types.
     */
    public static <T> T fromJson(String json, TypeReference<T> typeRef) {
        try {
            return MAPPER.readValue(json, typeRef);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to deserialize from JSON", e);
        }
    }

    /**
     * Convert object to another type via JSON.
     */
    public static <T> T convert(Object obj, Class<T> clazz) {
        return MAPPER.convertValue(obj, clazz);
    }
}
</file>

<file path="src/main/java/com/catalogforge/CatalogForgeApplication.java">
package com.catalogforge;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;
import org.springframework.scheduling.annotation.EnableScheduling;

/**
 * CatalogForge Backend Application.
 * 
 * A generative AI-powered platform for creating professional product catalogs and flyers.
 * Uses Google Gemini for layout generation and image analysis.
 */
@SpringBootApplication
@ConfigurationPropertiesScan
@EnableScheduling
public class CatalogForgeApplication {

    public static void main(String[] args) {
        SpringApplication.run(CatalogForgeApplication.class, args);
    }
}
</file>

<file path="src/main/resources/css/components/feature-list.css">
/**
 * Feature List Component
 */

.feature-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.feature-list__item {
    display: flex;
    align-items: flex-start;
    gap: var(--space-3);
    padding: var(--space-3) 0;
    border-bottom: 1px solid var(--color-gray-100);
}

.feature-list__item:last-child {
    border-bottom: none;
}

.feature-list__icon {
    flex-shrink: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--color-primary);
    color: var(--color-white);
    border-radius: var(--radius-full);
    font-size: var(--font-size-xs);
}

.feature-list__icon--check::before {
    content: "✓";
}

.feature-list__content {
    flex: 1;
}

.feature-list__title {
    font-weight: var(--font-weight-semibold);
    color: var(--color-gray-900);
    margin-bottom: var(--space-1);
}

.feature-list__description {
    font-size: var(--font-size-sm);
    color: var(--color-gray-600);
    line-height: var(--line-height-normal);
}

/* Compact Variant */
.feature-list--compact .feature-list__item {
    padding: var(--space-2) 0;
}

.feature-list--compact .feature-list__icon {
    width: 18px;
    height: 18px;
    font-size: 10px;
}

/* Horizontal Variant */
.feature-list--horizontal {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-4);
}

.feature-list--horizontal .feature-list__item {
    flex: 1 1 calc(50% - var(--space-4));
    border-bottom: none;
    padding: var(--space-2);
}

/* Bullet Variant */
.feature-list--bullets .feature-list__icon {
    width: 8px;
    height: 8px;
    background: var(--color-primary);
    margin-top: 6px;
}

.feature-list--bullets .feature-list__icon::before {
    content: "";
}

/* Print Styles */
@media print {
    .feature-list__item {
        padding: 2mm 0;
        page-break-inside: avoid;
    }
    
    .feature-list__icon {
        width: 4mm;
        height: 4mm;
    }
}
</file>

<file path="src/main/resources/css/components/product-card.css">
/**
 * Product Card Component
 */

.product-card {
    background: var(--color-white);
    border-radius: var(--radius-md);
    overflow: hidden;
    box-shadow: var(--shadow-sm);
    transition: box-shadow var(--transition-normal);
}

.product-card:hover {
    box-shadow: var(--shadow-md);
}

.product-card__image {
    width: 100%;
    aspect-ratio: 4/3;
    object-fit: cover;
    background: var(--color-gray-100);
}

.product-card__content {
    padding: var(--space-4);
}

.product-card__category {
    font-size: var(--font-size-xs);
    font-weight: var(--font-weight-semibold);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-primary);
    margin-bottom: var(--space-1);
}

.product-card__title {
    font-size: var(--font-size-lg);
    font-weight: var(--font-weight-semibold);
    color: var(--color-gray-900);
    margin-bottom: var(--space-2);
    line-height: var(--line-height-tight);
}

.product-card__description {
    font-size: var(--font-size-sm);
    color: var(--color-gray-600);
    line-height: var(--line-height-normal);
    margin-bottom: var(--space-3);
}

.product-card__price {
    font-size: var(--font-size-xl);
    font-weight: var(--font-weight-bold);
    color: var(--color-gray-900);
}

.product-card__price-label {
    font-size: var(--font-size-xs);
    color: var(--color-gray-500);
    font-weight: var(--font-weight-normal);
}

/* Compact Variant */
.product-card--compact .product-card__content {
    padding: var(--space-3);
}

.product-card--compact .product-card__title {
    font-size: var(--font-size-base);
}

/* Horizontal Variant */
.product-card--horizontal {
    display: flex;
    flex-direction: row;
}

.product-card--horizontal .product-card__image {
    width: 40%;
    aspect-ratio: 1/1;
}

.product-card--horizontal .product-card__content {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

/* Print Styles */
@media print {
    .product-card {
        box-shadow: none;
        border: 1px solid var(--color-gray-200);
        page-break-inside: avoid;
    }
    
    .product-card__content {
        padding: 4mm;
    }
}
</file>

<file path="src/main/resources/css/components/spec-table.css">
/**
 * Specification Table Component
 */

.spec-table {
    width: 100%;
    border-collapse: collapse;
    font-size: var(--font-size-sm);
}

.spec-table th,
.spec-table td {
    padding: var(--space-3) var(--space-4);
    text-align: left;
    border-bottom: 1px solid var(--color-gray-200);
}

.spec-table th {
    font-weight: var(--font-weight-semibold);
    color: var(--color-gray-700);
    background: var(--color-gray-50);
}

.spec-table td {
    color: var(--color-gray-900);
}

.spec-table tr:last-child td {
    border-bottom: none;
}

.spec-table tr:hover td {
    background: var(--color-gray-50);
}

/* Striped Variant */
.spec-table--striped tr:nth-child(even) td {
    background: var(--color-gray-50);
}

/* Compact Variant */
.spec-table--compact th,
.spec-table--compact td {
    padding: var(--space-2) var(--space-3);
    font-size: var(--font-size-xs);
}

/* Bordered Variant */
.spec-table--bordered {
    border: 1px solid var(--color-gray-200);
}

.spec-table--bordered th,
.spec-table--bordered td {
    border: 1px solid var(--color-gray-200);
}

/* Key-Value Layout */
.spec-table--kv th {
    width: 40%;
    background: transparent;
    font-weight: var(--font-weight-medium);
    color: var(--color-gray-500);
}

.spec-table--kv td {
    font-weight: var(--font-weight-semibold);
}

/* Print Styles */
@media print {
    .spec-table {
        font-size: 9pt;
    }
    
    .spec-table th,
    .spec-table td {
        padding: 2mm 3mm;
    }
    
    .spec-table tr {
        page-break-inside: avoid;
    }
}
</file>

<file path="src/main/resources/css/print/print-base.css">
/**
 * Print Base Styles for CatalogForge
 */

@media print {
    /* Page Setup */
    @page {
        margin: 10mm;
    }
    
    @page :first {
        margin-top: 0;
    }
    
    /* Reset for Print */
    * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        color-adjust: exact !important;
    }
    
    html, body {
        width: 100%;
        height: auto;
        margin: 0;
        padding: 0;
        font-size: 11pt;
        line-height: 1.4;
        background: white !important;
    }
    
    /* Typography for Print */
    h1 { font-size: 24pt; margin-bottom: 4mm; }
    h2 { font-size: 18pt; margin-bottom: 3mm; }
    h3 { font-size: 14pt; margin-bottom: 2mm; }
    h4 { font-size: 12pt; margin-bottom: 2mm; }
    p { margin-bottom: 3mm; }
    
    /* Links */
    a {
        color: inherit;
        text-decoration: none;
    }
    
    a[href^="http"]::after {
        content: " (" attr(href) ")";
        font-size: 8pt;
        color: #666;
    }
    
    /* Images */
    img {
        max-width: 100% !important;
        page-break-inside: avoid;
    }
    
    /* Tables */
    table {
        page-break-inside: auto;
    }
    
    tr {
        page-break-inside: avoid;
        page-break-after: auto;
    }
    
    thead {
        display: table-header-group;
    }
    
    /* Page Breaks */
    .page-break {
        page-break-after: always;
    }
    
    .page-break-before {
        page-break-before: always;
    }
    
    .avoid-break {
        page-break-inside: avoid;
    }
    
    /* Hide Screen-Only Elements */
    .no-print,
    .screen-only,
    nav,
    .navigation,
    button,
    .btn,
    video,
    audio,
    iframe {
        display: none !important;
    }
    
    /* Show Print-Only Elements */
    .print-only {
        display: block !important;
    }
    
    /* Backgrounds */
    .bg-print-white {
        background: white !important;
    }
    
    /* Shadows - Remove for Print */
    * {
        box-shadow: none !important;
        text-shadow: none !important;
    }
    
    /* Borders - Simplify */
    .border-print-simple {
        border: 0.5pt solid #ccc !important;
    }
}
</file>

<file path="src/main/resources/css/print/print-bleed.css">
/**
 * Print Bleed Styles for Professional Printing
 */

@media print {
    /* Bleed Area Setup */
    .bleed-container {
        position: relative;
        overflow: visible;
    }
    
    /* 3mm Bleed */
    .bleed-3mm {
        margin: -3mm;
        padding: 3mm;
    }
    
    /* 5mm Bleed */
    .bleed-5mm {
        margin: -5mm;
        padding: 5mm;
    }
    
    /* Bleed Background - Extends to bleed edge */
    .bleed-bg {
        position: absolute;
        top: -3mm;
        left: -3mm;
        right: -3mm;
        bottom: -3mm;
    }
    
    .bleed-bg-5mm {
        top: -5mm;
        left: -5mm;
        right: -5mm;
        bottom: -5mm;
    }
    
    /* Safe Area - Content should stay within */
    .safe-area {
        margin: 5mm;
    }
    
    .safe-area-3mm {
        margin: 3mm;
    }
    
    /* Full Bleed Image */
    .img-bleed {
        position: absolute;
        top: -3mm;
        left: -3mm;
        width: calc(100% + 6mm);
        height: calc(100% + 6mm);
        object-fit: cover;
    }
    
    .img-bleed-5mm {
        top: -5mm;
        left: -5mm;
        width: calc(100% + 10mm);
        height: calc(100% + 10mm);
    }
    
    /* Page with Bleed */
    .page-bleed {
        position: relative;
        box-sizing: border-box;
    }
    
    .page-bleed::before {
        content: "";
        position: absolute;
        top: -3mm;
        left: -3mm;
        right: -3mm;
        bottom: -3mm;
        background: inherit;
        z-index: -1;
    }
}

/* A4 with 3mm Bleed */
@page bleed-a4 {
    size: 216mm 303mm; /* A4 + 6mm */
    margin: 0;
}

/* A4 with 5mm Bleed */
@page bleed-a4-5mm {
    size: 220mm 307mm; /* A4 + 10mm */
    margin: 0;
}

/* A5 with 3mm Bleed */
@page bleed-a5 {
    size: 154mm 216mm; /* A5 + 6mm */
    margin: 0;
}

/* DL with 3mm Bleed */
@page bleed-dl {
    size: 105mm 216mm; /* DL + 6mm */
    margin: 0;
}
</file>

<file path="src/main/resources/css/print/print-crop-marks.css">
/**
 * Crop Marks for Professional Printing
 */

@media print {
    /* Crop Mark Container */
    .crop-marks {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
    }
    
    /* Individual Crop Mark */
    .crop-mark {
        position: absolute;
        background: #000;
    }
    
    /* Horizontal Marks */
    .crop-mark--h {
        width: 8mm;
        height: 0.25pt;
    }
    
    /* Vertical Marks */
    .crop-mark--v {
        width: 0.25pt;
        height: 8mm;
    }
    
    /* Top-Left Corner */
    .crop-mark--tl-h {
        top: 3mm;
        left: -10mm;
    }
    
    .crop-mark--tl-v {
        top: -10mm;
        left: 3mm;
    }
    
    /* Top-Right Corner */
    .crop-mark--tr-h {
        top: 3mm;
        right: -10mm;
    }
    
    .crop-mark--tr-v {
        top: -10mm;
        right: 3mm;
    }
    
    /* Bottom-Left Corner */
    .crop-mark--bl-h {
        bottom: 3mm;
        left: -10mm;
    }
    
    .crop-mark--bl-v {
        bottom: -10mm;
        left: 3mm;
    }
    
    /* Bottom-Right Corner */
    .crop-mark--br-h {
        bottom: 3mm;
        right: -10mm;
    }
    
    .crop-mark--br-v {
        bottom: -10mm;
        right: 3mm;
    }
    
    /* Registration Marks */
    .registration-mark {
        position: absolute;
        width: 5mm;
        height: 5mm;
    }
    
    .registration-mark::before,
    .registration-mark::after {
        content: "";
        position: absolute;
        background: #000;
    }
    
    .registration-mark::before {
        width: 100%;
        height: 0.25pt;
        top: 50%;
        transform: translateY(-50%);
    }
    
    .registration-mark::after {
        width: 0.25pt;
        height: 100%;
        left: 50%;
        transform: translateX(-50%);
    }
    
    /* Color Bars (simplified) */
    .color-bar {
        position: absolute;
        display: flex;
        gap: 1mm;
    }
    
    .color-bar__swatch {
        width: 4mm;
        height: 4mm;
    }
    
    .color-bar__cyan { background: cyan; }
    .color-bar__magenta { background: magenta; }
    .color-bar__yellow { background: yellow; }
    .color-bar__black { background: black; }
}
</file>

<file path="src/main/resources/css/.gitkeep">
# CSS templates for layout generation
</file>

<file path="src/main/resources/css/reset.css">
/**
 * CSS Reset for CatalogForge Layouts
 * Provides consistent baseline across browsers and print
 */

*, *::before, *::after {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 16px;
    line-height: 1.5;
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body {
    min-height: 100vh;
    text-rendering: optimizeLegibility;
}

img, picture, video, canvas, svg {
    display: block;
    max-width: 100%;
    height: auto;
}

input, button, textarea, select {
    font: inherit;
}

p, h1, h2, h3, h4, h5, h6 {
    overflow-wrap: break-word;
}

h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
}

ul, ol {
    list-style: none;
}

a {
    color: inherit;
    text-decoration: none;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

/* Print-specific resets */
@media print {
    * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
    }
    
    body {
        min-height: auto;
    }
}
</file>

<file path="src/main/resources/css/typography.css">
/**
 * Typography Styles for CatalogForge Layouts
 */

/* Headings */
.h1, h1 {
    font-size: var(--font-size-4xl);
    font-weight: var(--font-weight-bold);
    line-height: var(--line-height-tight);
    margin-bottom: var(--space-4);
}

.h2, h2 {
    font-size: var(--font-size-3xl);
    font-weight: var(--font-weight-semibold);
    line-height: var(--line-height-tight);
    margin-bottom: var(--space-3);
}

.h3, h3 {
    font-size: var(--font-size-2xl);
    font-weight: var(--font-weight-semibold);
    line-height: var(--line-height-tight);
    margin-bottom: var(--space-2);
}

.h4, h4 {
    font-size: var(--font-size-xl);
    font-weight: var(--font-weight-medium);
    line-height: var(--line-height-normal);
    margin-bottom: var(--space-2);
}

.h5, h5 {
    font-size: var(--font-size-lg);
    font-weight: var(--font-weight-medium);
    line-height: var(--line-height-normal);
    margin-bottom: var(--space-2);
}

.h6, h6 {
    font-size: var(--font-size-base);
    font-weight: var(--font-weight-semibold);
    line-height: var(--line-height-normal);
    margin-bottom: var(--space-1);
}

/* Body Text */
.body-lg {
    font-size: var(--font-size-lg);
    line-height: var(--line-height-relaxed);
}

.body-base {
    font-size: var(--font-size-base);
    line-height: var(--line-height-normal);
}

.body-sm {
    font-size: var(--font-size-sm);
    line-height: var(--line-height-normal);
}

.body-xs {
    font-size: var(--font-size-xs);
    line-height: var(--line-height-normal);
}

/* Paragraphs */
p {
    margin-bottom: var(--space-4);
}

p:last-child {
    margin-bottom: 0;
}

/* Lead Text */
.lead {
    font-size: var(--font-size-xl);
    font-weight: var(--font-weight-light);
    line-height: var(--line-height-relaxed);
    color: var(--color-gray-600);
}

/* Caption */
.caption {
    font-size: var(--font-size-xs);
    color: var(--color-gray-500);
    line-height: var(--line-height-normal);
}

/* Overline */
.overline {
    font-size: var(--font-size-xs);
    font-weight: var(--font-weight-semibold);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--color-gray-500);
}

/* Text Utilities */
.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }
.text-justify { text-align: justify; }

.text-uppercase { text-transform: uppercase; }
.text-lowercase { text-transform: lowercase; }
.text-capitalize { text-transform: capitalize; }

.font-light { font-weight: var(--font-weight-light); }
.font-normal { font-weight: var(--font-weight-normal); }
.font-medium { font-weight: var(--font-weight-medium); }
.font-semibold { font-weight: var(--font-weight-semibold); }
.font-bold { font-weight: var(--font-weight-bold); }

/* Lists */
.list-disc {
    list-style-type: disc;
    padding-left: var(--space-6);
}

.list-decimal {
    list-style-type: decimal;
    padding-left: var(--space-6);
}

.list-disc li,
.list-decimal li {
    margin-bottom: var(--space-2);
}

/* Print Typography */
@media print {
    .h1, h1 { font-size: 28pt; }
    .h2, h2 { font-size: 22pt; }
    .h3, h3 { font-size: 18pt; }
    .h4, h4 { font-size: 14pt; }
    .body-base { font-size: 11pt; }
    .body-sm { font-size: 9pt; }
    .caption { font-size: 8pt; }
}
</file>

<file path="src/main/resources/css/utilities.css">
/**
 * Utility Classes for CatalogForge Layouts
 */

/* Display */
.block { display: block; }
.inline-block { display: inline-block; }
.inline { display: inline; }
.flex { display: flex; }
.inline-flex { display: inline-flex; }
.grid { display: grid; }
.hidden { display: none; }

/* Flexbox */
.flex-row { flex-direction: row; }
.flex-col { flex-direction: column; }
.flex-wrap { flex-wrap: wrap; }
.flex-nowrap { flex-wrap: nowrap; }

.items-start { align-items: flex-start; }
.items-center { align-items: center; }
.items-end { align-items: flex-end; }
.items-stretch { align-items: stretch; }

.justify-start { justify-content: flex-start; }
.justify-center { justify-content: center; }
.justify-end { justify-content: flex-end; }
.justify-between { justify-content: space-between; }
.justify-around { justify-content: space-around; }

.flex-1 { flex: 1 1 0%; }
.flex-auto { flex: 1 1 auto; }
.flex-none { flex: none; }

/* Gap */
.gap-1 { gap: var(--space-1); }
.gap-2 { gap: var(--space-2); }
.gap-3 { gap: var(--space-3); }
.gap-4 { gap: var(--space-4); }
.gap-6 { gap: var(--space-6); }
.gap-8 { gap: var(--space-8); }

/* Margin */
.m-0 { margin: 0; }
.m-1 { margin: var(--space-1); }
.m-2 { margin: var(--space-2); }
.m-4 { margin: var(--space-4); }
.m-6 { margin: var(--space-6); }
.m-8 { margin: var(--space-8); }
.m-auto { margin: auto; }

.mt-0 { margin-top: 0; }
.mt-2 { margin-top: var(--space-2); }
.mt-4 { margin-top: var(--space-4); }
.mt-6 { margin-top: var(--space-6); }
.mt-8 { margin-top: var(--space-8); }

.mb-0 { margin-bottom: 0; }
.mb-2 { margin-bottom: var(--space-2); }
.mb-4 { margin-bottom: var(--space-4); }
.mb-6 { margin-bottom: var(--space-6); }
.mb-8 { margin-bottom: var(--space-8); }

.mx-auto { margin-left: auto; margin-right: auto; }

/* Padding */
.p-0 { padding: 0; }
.p-1 { padding: var(--space-1); }
.p-2 { padding: var(--space-2); }
.p-4 { padding: var(--space-4); }
.p-6 { padding: var(--space-6); }
.p-8 { padding: var(--space-8); }

.px-2 { padding-left: var(--space-2); padding-right: var(--space-2); }
.px-4 { padding-left: var(--space-4); padding-right: var(--space-4); }
.px-6 { padding-left: var(--space-6); padding-right: var(--space-6); }

.py-2 { padding-top: var(--space-2); padding-bottom: var(--space-2); }
.py-4 { padding-top: var(--space-4); padding-bottom: var(--space-4); }
.py-6 { padding-top: var(--space-6); padding-bottom: var(--space-6); }

/* Width & Height */
.w-full { width: 100%; }
.w-auto { width: auto; }
.w-1\/2 { width: 50%; }
.w-1\/3 { width: 33.333%; }
.w-2\/3 { width: 66.666%; }
.w-1\/4 { width: 25%; }
.w-3\/4 { width: 75%; }

.h-full { height: 100%; }
.h-auto { height: auto; }
.min-h-full { min-height: 100%; }

/* Position */
.relative { position: relative; }
.absolute { position: absolute; }
.fixed { position: fixed; }
.sticky { position: sticky; }

.top-0 { top: 0; }
.right-0 { right: 0; }
.bottom-0 { bottom: 0; }
.left-0 { left: 0; }
.inset-0 { top: 0; right: 0; bottom: 0; left: 0; }

/* Colors */
.text-primary { color: var(--color-primary); }
.text-secondary { color: var(--color-secondary); }
.text-white { color: var(--color-white); }
.text-gray-500 { color: var(--color-gray-500); }
.text-gray-700 { color: var(--color-gray-700); }

.bg-white { background-color: var(--color-white); }
.bg-gray-50 { background-color: var(--color-gray-50); }
.bg-gray-100 { background-color: var(--color-gray-100); }
.bg-primary { background-color: var(--color-primary); }

/* Border */
.border { border: 1px solid var(--color-gray-200); }
.border-0 { border: none; }
.border-t { border-top: 1px solid var(--color-gray-200); }
.border-b { border-bottom: 1px solid var(--color-gray-200); }

.rounded { border-radius: var(--radius-md); }
.rounded-sm { border-radius: var(--radius-sm); }
.rounded-lg { border-radius: var(--radius-lg); }
.rounded-full { border-radius: var(--radius-full); }

/* Shadow */
.shadow-sm { box-shadow: var(--shadow-sm); }
.shadow { box-shadow: var(--shadow-md); }
.shadow-lg { box-shadow: var(--shadow-lg); }
.shadow-none { box-shadow: none; }

/* Overflow */
.overflow-hidden { overflow: hidden; }
.overflow-auto { overflow: auto; }
.overflow-visible { overflow: visible; }

/* Print Utilities */
.print-only { display: none; }
.screen-only { display: block; }

@media print {
    .print-only { display: block; }
    .screen-only { display: none; }
    .no-print { display: none !important; }
    .page-break { page-break-after: always; }
    .avoid-break { page-break-inside: avoid; }
}
</file>

<file path="src/main/resources/css/variables.css">
/**
 * CSS Variables for CatalogForge Layouts
 * Design tokens for consistent styling
 */

:root {
    /* Colors - Brand */
    --color-primary: #0066CC;
    --color-primary-dark: #004C99;
    --color-primary-light: #3399FF;
    --color-secondary: #333333;
    --color-accent: #FF6B35;
    
    /* Colors - Neutral */
    --color-white: #FFFFFF;
    --color-gray-50: #FAFAFA;
    --color-gray-100: #F5F5F5;
    --color-gray-200: #EEEEEE;
    --color-gray-300: #E0E0E0;
    --color-gray-400: #BDBDBD;
    --color-gray-500: #9E9E9E;
    --color-gray-600: #757575;
    --color-gray-700: #616161;
    --color-gray-800: #424242;
    --color-gray-900: #212121;
    --color-black: #000000;
    
    /* Colors - Semantic */
    --color-success: #4CAF50;
    --color-warning: #FF9800;
    --color-error: #F44336;
    --color-info: #2196F3;
    
    /* Typography */
    --font-family-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    --font-family-serif: 'Playfair Display', Georgia, serif;
    --font-family-mono: 'JetBrains Mono', 'Fira Code', monospace;
    
    /* Font Sizes */
    --font-size-xs: 0.75rem;    /* 12px */
    --font-size-sm: 0.875rem;   /* 14px */
    --font-size-base: 1rem;     /* 16px */
    --font-size-lg: 1.125rem;   /* 18px */
    --font-size-xl: 1.25rem;    /* 20px */
    --font-size-2xl: 1.5rem;    /* 24px */
    --font-size-3xl: 1.875rem;  /* 30px */
    --font-size-4xl: 2.25rem;   /* 36px */
    --font-size-5xl: 3rem;      /* 48px */
    
    /* Font Weights */
    --font-weight-light: 300;
    --font-weight-normal: 400;
    --font-weight-medium: 500;
    --font-weight-semibold: 600;
    --font-weight-bold: 700;
    --font-weight-black: 900;
    
    /* Line Heights */
    --line-height-tight: 1.25;
    --line-height-normal: 1.5;
    --line-height-relaxed: 1.75;
    
    /* Spacing */
    --space-1: 0.25rem;   /* 4px */
    --space-2: 0.5rem;    /* 8px */
    --space-3: 0.75rem;   /* 12px */
    --space-4: 1rem;      /* 16px */
    --space-5: 1.25rem;   /* 20px */
    --space-6: 1.5rem;    /* 24px */
    --space-8: 2rem;      /* 32px */
    --space-10: 2.5rem;   /* 40px */
    --space-12: 3rem;     /* 48px */
    --space-16: 4rem;     /* 64px */
    
    /* Border Radius */
    --radius-sm: 0.25rem;
    --radius-md: 0.5rem;
    --radius-lg: 1rem;
    --radius-full: 9999px;
    
    /* Shadows */
    --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
    --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
    --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.15);
    
    /* Transitions */
    --transition-fast: 150ms ease;
    --transition-normal: 300ms ease;
    --transition-slow: 500ms ease;
    
    /* Z-Index */
    --z-base: 0;
    --z-dropdown: 100;
    --z-sticky: 200;
    --z-modal: 300;
    --z-tooltip: 400;
}

/* Print-specific variables */
@media print {
    :root {
        --space-1: 1mm;
        --space-2: 2mm;
        --space-3: 3mm;
        --space-4: 4mm;
        --space-6: 6mm;
        --space-8: 8mm;
        --space-12: 12mm;
    }
}
</file>

<file path="src/main/resources/data/.gitkeep">
# Product data files (products.json)
</file>

<file path="src/main/resources/data/products.json">
[
  {
    "id": 1,
    "name": "Mercedes-Benz Actros L 1853 LS ProCabin",
    "shortDescription": "Das Flaggschiff im Fernverkehr – maximale Effizienz trifft auf Premium-Komfort mit der revolutionären ProCabin-Kabine.",
    "description": "Der Mercedes-Benz Actros L 1853 LS ProCabin definiert den modernen Fernverkehr neu. Mit der aerodynamisch optimierten ProCabin-Kabine erreicht er Kraftstoffeinsparungen von bis zu drei Prozent. Der 530 PS starke OM 471 Motor liefert beeindruckende 2.600 Nm Drehmoment und überzeugt durch vorbildliche Effizienz.\n\nDas Sicherheitspaket mit Active Brake Assist 6 und Active Sideguard Assist 2 übertrifft alle gesetzlichen Anforderungen. Das Multimedia Cockpit Interactive 2 mit Sprachsteuerung und der Active Drive Assist 3 für teilautomatisiertes Fahren entlasten den Fahrer erheblich. Die GigaSpace ProCabin bietet mit über zwei Metern Stehöhe und durchdachtem Raumkonzept höchsten Wohnkomfort für lange Touren. Ein echtes Premium-Flaggschiff für anspruchsvolle Flottenmanager.",
    "longDescription": "Der Mercedes-Benz Actros L 1853 LS ProCabin repräsentiert die absolute Spitze dessen, was moderner Fernverkehr zu bieten hat. Mit der vollständig neu gestalteten ProCabin setzt dieses Fahrzeug neue Maßstäbe in Sachen Aerodynamik, Effizienz und Fahrerkomfort. Die um 80 Millimeter verlängerte Fahrzeugfront ist das Ergebnis intensiver Windkanalforschung und führt zu einer Kraftstoffeinsparung von bis zu drei Prozent gegenüber dem Vorgängermodell.\n\nDas Herzstück des Actros L 1853 ist der bewährte OM 471 Motor der dritten Generation mit 12,8 Litern Hubraum. Mit seinen 530 PS und einem maximalen Drehmoment von 2.600 Nm meistert er selbst anspruchsvollste Streckenprofile mühelos. In Kombination mit dem Mercedes PowerShift 3 Getriebe und der intelligenten Predictive Powertrain Control erreicht der Actros L Verbrauchswerte, die in dieser Leistungsklasse ihresgleichen suchen.\n\nBesonders beeindruckend ist das neue Sicherheitskonzept: Der Active Brake Assist 6 erkennt nicht nur vorausfahrende Fahrzeuge, sondern auch Fußgänger und Radfahrer – und kann im Notfall eine Vollbremsung einleiten. Der Active Sideguard Assist 2 warnt beim Abbiegen vor Objekten im toten Winkel und greift bei Gefahr aktiv in die Bremsung ein. Diese Systeme übertreffen die strengen Anforderungen der EU General Safety Regulation deutlich.\n\nDas Interieur der GigaSpace ProCabin ist ein rollendes Zuhause. Die Stehöhe von über zwei Metern, das durchdachte Stauraumkonzept und die ergonomisch optimierten Bedienelemente machen lange Touren zum Komforterlebnis. Das 12-Zoll-Instrumentendisplay und der verbesserte Touchscreen des Multimedia Cockpit Interactive 2 lassen sich intuitiv bedienen – viele Funktionen sind per Sprachsteuerung erreichbar. Der Active Drive Assist 3 ermöglicht teilautomatisiertes Fahren auf Level 2 und entlastet den Fahrer auf langen Autobahnabschnitten spürbar.\n\nMit dem Actros L 1853 LS ProCabin entscheiden Sie sich für ein Fahrzeug, das Wirtschaftlichkeit und Nachhaltigkeit mit höchstem Fahrerkomfort vereint – ein echtes Premiumprodukt für anspruchsvolle Transportunternehmen.",
    "category": "Fernverkehr",
    "series": "Actros L",
    "imageUrl": "https://images.unsplash.com/photo-1601584115197-04ecc0da31d7?w=800&h=600&fit=crop",
    "highlights": [
      "Multimedia Cockpit Interactive 2",
      "Active Brake Assist 6",
      "Active Sideguard Assist 2",
      "Predictive Powertrain Control",
      "Active Drive Assist 3 (Level 2)",
      "LED Matrix-Scheinwerfer",
      "Klimaautomatik mit Standheizung",
      "Kühlschrank 40L"
    ],
    "priceEur": 189500,
    "specs": {
      "motor": "OM 471 Euro VI-E",
      "hubraum_l": "12.8",
      "leistung_ps": "530",
      "leistung_kw": "390",
      "drehmoment_nm": "2600",
      "antriebsformel": "4x2",
      "getriebe": "Mercedes PowerShift 3 (12-Gang)",
      "gesamtgewicht_t": "40",
      "radstand_mm": "3700",
      "fahrerhaustyp": "GigaSpace ProCabin",
      "tankvolumen_l": "900",
      "verbrauch_l_100km": "24.5",
      "abgasnorm": "Euro VI-E",
      "hoechstgeschwindigkeit_kmh": "89"
    }
  },
  {
    "id": 2,
    "name": "Mercedes-Benz Actros L 1848 LS",
    "shortDescription": "Der vielseitige Allrounder im Fernverkehr – optimale Balance zwischen Leistung und Wirtschaftlichkeit.",
    "description": "Der Mercedes-Benz Actros L 1848 LS vereint Wirtschaftlichkeit und Zuverlässigkeit auf höchstem Niveau. Mit 480 PS und dem kraftstoffoptimierten OM 471 Motor bietet er die ideale Balance für den täglichen Fernverkehr. Die Predictive Powertrain Control sorgt automatisch für effizientes Fahren.\n\nDie komfortable BigSpace-Kabine mit knapp zwei Metern Innenhöhe macht mehrtägige Touren zum Vergnügen. Das Multimedia Cockpit Interactive 2 bietet intuitive Bedienung per Touch oder Sprache. Sicherheitssysteme wie der Active Brake Assist 5 und der Spurhalteassistent schützen Fahrer und andere Verkehrsteilnehmer. Ein ausgewogenes Gesamtpaket für anspruchsvolle Flottenbetreiber.",
    "longDescription": "Der Mercedes-Benz Actros L 1848 LS ist die perfekte Wahl für Transportunternehmen, die einen zuverlässigen und wirtschaftlichen Partner für den Fernverkehr suchen. Mit 480 PS bietet er ausreichend Kraftreserven für alle gängigen Transportaufgaben in Europa, während sein optimierter Verbrauch die Betriebskosten im Rahmen hält.\n\nDer OM 471 Motor der dritten Generation ist speziell auf kraftstoffsparendes Fahren ausgelegt. In Verbindung mit dem Mercedes PowerShift 3 Getriebe und der Predictive Powertrain Control passt sich der Antriebsstrang automatisch an das Streckenprofil an. Das System nutzt GPS-Daten und Topographieinformationen, um Schaltvorgänge und Geschwindigkeit vorausschauend zu optimieren – für maximale Effizienz auf jeder Route.\n\nDie BigSpace-Kabine bietet dem Fahrer einen komfortablen Arbeits- und Lebensraum. Mit einer Innenhöhe von 1,98 Metern und einem durchdachten Stauraumkonzept ist sie ideal für mehrtägige Touren geeignet. Das Multimedia Cockpit Interactive 2 fungiert als zentrale Kommandozentrale und ermöglicht die Steuerung aller wichtigen Funktionen per Touchscreen oder Sprachbefehl.\n\nBei der Sicherheit setzt der Actros L 1848 auf bewährte Mercedes-Benz Technologie: Der Active Brake Assist 5 erkennt vorausfahrende Fahrzeuge und kann bei Gefahr automatisch bremsen. Der Spurhalteassistent warnt bei unbeabsichtigtem Verlassen der Fahrspur und korrigiert sanft die Lenkung. Müdigkeitswarnsysteme überwachen das Fahrerverhalten und empfehlen rechtzeitig Pausen.\n\nDer Actros L 1848 LS ist das ideale Fahrzeug für Flottenbetreiber, die Zuverlässigkeit, moderate Anschaffungskosten und niedrige Betriebskosten in einem bewährten Premiumfahrzeug vereint wissen wollen. Mit seinem ausgewogenen Gesamtpaket ist er ein echter Kilometerfresser, der Tag für Tag zuverlässig seine Arbeit verrichtet.",
    "category": "Fernverkehr",
    "series": "Actros L",
    "imageUrl": "https://images.unsplash.com/photo-1586191582066-71c6bb4e6ec6?w=800&h=600&fit=crop",
    "highlights": [
      "Multimedia Cockpit Interactive 2",
      "Active Brake Assist 5",
      "Spurhalteassistent",
      "Predictive Powertrain Control",
      "LED-Hauptscheinwerfer",
      "Tempomat mit Limiter",
      "Klimaanlage",
      "Standheizung"
    ],
    "priceEur": 159800,
    "specs": {
      "motor": "OM 471 Euro VI-E",
      "hubraum_l": "12.8",
      "leistung_ps": "480",
      "leistung_kw": "353",
      "drehmoment_nm": "2400",
      "antriebsformel": "4x2",
      "getriebe": "Mercedes PowerShift 3 (12-Gang)",
      "gesamtgewicht_t": "40",
      "radstand_mm": "3700",
      "fahrerhaustyp": "BigSpace",
      "tankvolumen_l": "800",
      "verbrauch_l_100km": "25.2",
      "abgasnorm": "Euro VI-E",
      "hoechstgeschwindigkeit_kmh": "89"
    }
  },
  {
    "id": 3,
    "name": "Mercedes-Benz Actros L 1863 LS",
    "shortDescription": "Die Kraft der Superlative – unser leistungsstärkstes Fernverkehrsfahrzeug für maximale Performance.",
    "description": "Der Mercedes-Benz Actros L 1863 LS ist unser leistungsstärkstes Fernverkehrsfahrzeug. Mit 625 PS und 3.000 Nm Drehmoment aus dem OM 473 Motor meistert er selbst extreme Steigungen mühelos. Die Turbo-Retarder-Kupplung und High Performance Engine Brake liefern bis zu 750 kW Bremsleistung.\n\nDie GigaSpace-Kabine mit Premium-Fahrersitz und Massagefunktion bietet höchsten Komfort. Der Active Drive Assist 3 ermöglicht teilautomatisiertes Fahren. Die Vollluftfederung sorgt für überlegenen Fahrkomfort bei jeder Beladung. Das ideale Fahrzeug für Alpentransit und anspruchsvolle internationale Routen.",
    "longDescription": "Der Mercedes-Benz Actros L 1863 LS ist das Kraftpaket für besondere Herausforderungen. Mit seinem monumentalen OM 473 Motor und 625 PS Leistung bewältigt er selbst die anspruchsvollsten Streckenprofile souverän. Das gewaltige Drehmoment von 3.000 Nm steht bereits bei niedrigen Drehzahlen zur Verfügung und garantiert mühelose Bergfahrten mit voller Beladung.\n\nBesonders bei Fahrten über die Alpen oder durch skandinavische Gebirgslandschaften zeigt der 1863 seine wahren Stärken. Die Turbo-Retarder-Kupplung kombiniert eine verschleißfreie Anfahrkupplung mit einem integrierten Retarder. Zusammen mit der High Performance Engine Brake erreicht das System eine Bremsleistung von bis zu 750 kW – genug, um selbst bei voller Beladung lange Gefällestrecken ohne Betriebsbremse zu bewältigen.\n\nDie GigaSpace-Kabine bietet dem Fahrer eines Hochleistungsfahrzeugs den Komfort, den er verdient. Der Premium-Fahrersitz mit Massagefunktion und individuell einstellbarer Klimatisierung macht auch anstrengende Etappen erträglich. Das durchdachte Belüftungssystem mit Klimaautomatik sorgt für optimales Raumklima bei jeder Außentemperatur.\n\nDer Active Drive Assist 3 ermöglicht teilautomatisiertes Fahren und hält das Fahrzeug in der Spur, während er automatisch Abstand zum Vordermann hält. In Kombination mit dem Active Brake Assist 6 und dem Active Sideguard Assist 2 entsteht ein umfassendes Sicherheitsnetz, das den Fahrer bei seiner anspruchsvollen Aufgabe optimal unterstützt.\n\nDie Luftfederung an Vorder- und Hinterachse sorgt für überlegenen Fahrkomfort und schont gleichzeitig die Ladung. Das adaptive Dämpfungssystem passt die Fahrwerkcharakteristik automatisch an die aktuelle Straßensituation an. Für Transportunternehmen mit besonders anspruchsvollen Routen ist der Actros L 1863 LS die erste Wahl.",
    "category": "Fernverkehr/Schwerlast",
    "series": "Actros L",
    "imageUrl": "https://images.unsplash.com/photo-1519003722824-194d4455a60c?w=800&h=600&fit=crop",
    "highlights": [
      "Turbo-Retarder-Kupplung",
      "High Performance Engine Brake",
      "Multimedia Cockpit Interactive 2",
      "Active Brake Assist 6",
      "Active Drive Assist 3",
      "Luftfederung vorne und hinten",
      "Premium-Fahrersitz mit Massage",
      "Freisprechanlage mit Bluetooth"
    ],
    "priceEur": 218900,
    "specs": {
      "motor": "OM 473 Euro VI-E",
      "hubraum_l": "15.6",
      "leistung_ps": "625",
      "leistung_kw": "460",
      "drehmoment_nm": "3000",
      "antriebsformel": "4x2",
      "getriebe": "Mercedes PowerShift 3 (12-Gang)",
      "gesamtgewicht_t": "44",
      "radstand_mm": "3700",
      "fahrerhaustyp": "GigaSpace",
      "tankvolumen_l": "1000",
      "verbrauch_l_100km": "28.5",
      "abgasnorm": "Euro VI-E",
      "hoechstgeschwindigkeit_kmh": "89"
    }
  },
  {
    "id": 4,
    "name": "Mercedes-Benz Actros L Edition 3",
    "shortDescription": "Streng limitiert auf 400 Exemplare – das exklusivste Fahrerlebnis im Fernverkehr mit einzigartigen Design-Features.",
    "description": "Der Mercedes-Benz Actros L Edition 3 ist ein echtes Sammlerstück – streng limitiert auf 400 Exemplare weltweit. Die exklusive Außenlackierung in Weißaluminium Metallic, der Mercedes-Stern in Dark-Chrome und die LED-Bars in der Sonnenblende setzen unverwechselbare Akzente.\n\nDas Leder-Interieur mit Edition-Stickerei und Aluminium-Pedalen bietet höchsten Luxus. Technisch basiert die Edition 3 auf dem bewährten Actros L 1853 mit 530 PS und allen Premium-Sicherheitssystemen. Jedes Fahrzeug trägt ein individuelles Nummerierungsschild. Für Fahrer, die mehr als nur ein Arbeitsmittel suchen.",
    "longDescription": "Der Mercedes-Benz Actros L Edition 3 ist weit mehr als ein Lkw – er ist ein Statement. Streng limitiert auf nur 400 Exemplare weltweit, vereint dieses Sondermodell das Beste aus drei erfolgreichen Vorgänger-Editionen mit völlig neuen, exklusiven Designelementen. Jedes Fahrzeug trägt ein individuelles Nummerierungsschild, das seinen einzigartigen Status dokumentiert.\n\nSchon aus der Ferne fällt die markante Erscheinung auf: Die Außenlackierung in edlem Weißaluminium Metallic erstreckt sich über eine perfekt verarbeitete Karosserie. Die Fahrzeugfront mit den Edelstahl-Zierelementen und dem Mercedes-Stern in exklusivem Dark-Chrome zieht alle Blicke auf sich. Die in die Sonnenblende integrierten LED-Bars setzen auch bei Nacht ein unverwechselbares Zeichen.\n\nDas Interieur der Edition 3 ist ein Fest für die Sinne. Hochwertiges Leder mit präziser Edition-Stickerei kleidet Sitze und Verkleidungen aus. Die Materialauswahl und Verarbeitungsqualität orientieren sich an den strengsten Standards der Automobilindustrie. Jedes Detail wurde mit höchster Sorgfalt ausgewählt – von den Aluminium-Pedalen bis zu den beleuchteten Einstiegsleisten mit Edition-3-Schriftzug.\n\nTechnisch steht die Edition 3 auf dem Fundament des bewährten Actros L 1853. Der effiziente OM 471 Motor mit 530 PS und die Predictive Powertrain Control sorgen für vorbildliche Wirtschaftlichkeit. Alle Premium-Sicherheitssysteme wie Active Brake Assist 6, Active Sideguard Assist 2 und Active Drive Assist 3 sind serienmäßig an Bord.\n\nDie Edition 3 richtet sich an Fahrer und Unternehmer, für die ein Lkw mehr ist als nur ein Arbeitsmittel. Sie verkörpert die Leidenschaft für das Fahren und den Stolz auf einen der schönsten Arbeitsplätze der Welt. Ein echtes Sammlerstück für Kenner.",
    "category": "Fernverkehr/Sondermodell",
    "series": "Actros L",
    "imageUrl": "https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=800&h=600&fit=crop",
    "highlights": [
      "Exklusive Außenlackierung Weißaluminium Metallic",
      "Mercedes-Stern in Dark-Chrome",
      "LED-Bars in Sonnenblende",
      "Edelstahl-Zierteile",
      "Leder-Interieur mit Edition-Stickerei",
      "Exklusives Nummerierungsschild"
    ],
    "priceEur": 245000,
    "specs": {
      "motor": "OM 471 Euro VI-E",
      "hubraum_l": "12.8",
      "leistung_ps": "530",
      "leistung_kw": "390",
      "drehmoment_nm": "2600",
      "antriebsformel": "4x2",
      "getriebe": "Mercedes PowerShift 3 (12-Gang)",
      "gesamtgewicht_t": "40",
      "fahrerhaustyp": "GigaSpace Edition",
      "tankvolumen_l": "900"
    }
  },
  {
    "id": 5,
    "name": "Mercedes-Benz Actros F 1845",
    "shortDescription": "Der funktionale Einstieg in die Actros-Welt – bewährte Technik zum attraktiven Preis.",
    "description": "Der Mercedes-Benz Actros F 1845 ist der funktionale Einstieg in die Actros-Familie. Mit 449 PS und dem bewährten OM 471 Motor bietet er solide Leistung für den europäischen Fernverkehr. Das StreamSpace-Fahrerhaus mit Classic Cockpit konzentriert sich auf das Wesentliche.\n\nDie klassischen Außenspiegel sind robust und servicefreundlich. Der Active Brake Assist 5 sorgt für hohe Sicherheit. Die elektronische Luftfederung hinten passt sich automatisch der Beladung an. Ideal für preisbewusste Unternehmer, die auf bewährte Mercedes-Qualität nicht verzichten möchten.",
    "longDescription": "Der Mercedes-Benz Actros F 1845 macht den Einstieg in die Welt des Actros so zugänglich wie nie zuvor. Als funktionsorientiertes Modell konzentriert er sich auf das Wesentliche: bewährte Mercedes-Benz Technik, solide Verarbeitung und ein überzeugendes Preis-Leistungs-Verhältnis. Für Unternehmer, die auf das typische Actros-Erlebnis nicht verzichten möchten, aber nicht jede Innovation der neuesten Generation benötigen.\n\nDer OM 471 Motor mit 449 PS bietet ausreichend Leistungsreserven für den Standard-Fernverkehr in Europa. Die Kombination mit dem Mercedes PowerShift 3 Getriebe sorgt für komfortables und effizientes Fahren. Das Fahrzeug ist auf zuverlässigen Dauereinsatz ausgelegt und profitiert von der jahrzehntelangen Erfahrung von Mercedes-Benz im Nutzfahrzeugbau.\n\nDas StreamSpace-Fahrerhaus bietet einen funktionalen Arbeitsplatz mit ausreichend Platz für längere Touren. Das Classic Cockpit mit analogen Rundinstrumenten ist übersichtlich gestaltet und leicht zu bedienen. Die klassischen Außenspiegel bieten exzellente Sicht und sind im Service einfach zu ersetzen – ein Kostenvorteil im täglichen Betrieb.\n\nBei der Sicherheit macht der Actros F keine Kompromisse: Der Active Brake Assist 5 ist serienmäßig an Bord und erkennt vorausfahrende Fahrzeuge zuverlässig. Spurhaltewarner und Müdigkeitserkennung unterstützen den Fahrer zusätzlich.\n\nMit dem Actros F 1845 bietet Mercedes-Benz eine ehrliche Alternative für preisbewusste Unternehmer, die auf Mercedes-Qualität vertrauen.",
    "category": "Fernverkehr/Einstieg",
    "series": "Actros F",
    "imageUrl": "https://images.unsplash.com/photo-1580674684081-7617fbf3d745?w=800&h=600&fit=crop",
    "highlights": [
      "Classic Cockpit",
      "Active Brake Assist 5",
      "Klassische Außenspiegel",
      "Klimaanlage",
      "Standheizung",
      "Radio mit Bluetooth"
    ],
    "priceEur": 134500,
    "specs": {
      "motor": "OM 471 Euro VI-E",
      "hubraum_l": "12.8",
      "leistung_ps": "449",
      "leistung_kw": "330",
      "drehmoment_nm": "2200",
      "antriebsformel": "4x2",
      "getriebe": "Mercedes PowerShift 3 (12-Gang)",
      "gesamtgewicht_t": "40",
      "fahrerhaustyp": "StreamSpace",
      "tankvolumen_l": "700"
    }
  },
  {
    "id": 6,
    "name": "Mercedes-Benz eActros 600",
    "shortDescription": "Die Zukunft des Fernverkehrs ist elektrisch – 500 km Reichweite und 600 kW Spitzenleistung für emissionsfreien Gütertransport.",
    "description": "Der Mercedes-Benz eActros 600 ist der erste batterieelektrische Fernverkehrs-Lkw von Mercedes-Benz. Mit 500 km Reichweite, 621 kWh LFP-Batteriekapazität und 600 kW Spitzenleistung ist er für den harten Logistikalltag konzipiert. CCS2-Laden mit bis zu 400 kW ermöglicht schnelles Nachladen während der Lenkpausen.\n\nDie selbst entwickelte 800V-E-Antriebsachse garantiert souveräne Leistung bis 44 Tonnen Gesamtgewicht. Fünf Rekuperationsstufen maximieren die Energierückgewinnung. Die aerodynamische ProCabin reduziert den Luftwiderstand um neun Prozent. Der eActros 600 macht emissionsfreien Fernverkehr wirtschaftlich.",
    "longDescription": "Der Mercedes-Benz eActros 600 markiert den Beginn einer neuen Ära im schweren Güterverkehr. Als erster batterieelektrischer Fernverkehrs-Lkw mit Stern ist er für Zuggewichte bis 44 Tonnen und Tagesfahrleistungen von über 1.000 Kilometern konzipiert. Mit einer Reichweite von 500 Kilometern ohne Zwischenladung und blitzschnellem CCS2-Laden mit bis zu 400 kW macht er den Umstieg auf emissionsfreien Transport wirtschaftlich attraktiv.\n\nDas technische Herzstück ist die selbst entwickelte 800-Volt-E-Antriebsachse mit zwei integrierten Elektromotoren. Die Dauerleistung von 400 kW und eine Spitzenleistung von beeindruckenden 600 kW (816 PS) garantieren souveränes Fortkommen auch bei voller Beladung und in anspruchsvollem Gelände. Das speziell entwickelte 4-Gang-Elektrogetriebe optimiert die Effizienz über den gesamten Geschwindigkeitsbereich.\n\nDrei Batteriepakete mit LFP-Technologie (Lithium-Eisenphosphat) und einer Gesamtkapazität von 621 kWh speichern die Energie für lange Etappen. Die LFP-Chemie zeichnet sich durch hohe Langlebigkeit aus – nach zehn Jahren und 1,2 Millionen Kilometern soll der Batteriezustand noch über 80 Prozent betragen.\n\nDie fünf Rekuperationsstufen ermöglichen die Anpassung der Energierückgewinnung an Fahrweise und Streckenprofil. Die puristische ProCabin wurde aerodynamisch optimiert und verleiht dem eActros 600 sein unverwechselbares Erscheinungsbild. Mit dem eActros 600 beginnt die elektrische Transformation des Fernverkehrs.",
    "category": "Fernverkehr/Elektro",
    "series": "eActros",
    "imageUrl": "https://images.unsplash.com/photo-1593941707882-a5bba14938c7?w=800&h=600&fit=crop",
    "highlights": [
      "800V E-Antriebsachse",
      "Drei LFP-Batteriepakete à 207 kWh",
      "CCS2-Schnellladen bis 400 kW",
      "MCS-Vorbereitung für 1 MW Laden",
      "ProCabin Fahrerhaus",
      "Active Brake Assist 6",
      "Fünf Rekuperationsstufen"
    ],
    "priceEur": 286300,
    "specs": {
      "antrieb": "Elektrisch (2 Elektromotoren)",
      "dauerleistung_kw": "400",
      "spitzenleistung_kw": "600",
      "spitzenleistung_ps": "816",
      "drehmoment_nm": "2100",
      "batteriekapazitaet_kwh": "621",
      "batterietyp": "LFP (Lithium-Eisenphosphat)",
      "reichweite_km": "500",
      "ladeleistung_max_kw": "400",
      "antriebsformel": "4x2",
      "getriebe": "4-Gang Elektrogetriebe",
      "gesamtgewicht_t": "44",
      "nutzlast_t": "22",
      "bordspannung_v": "800"
    }
  },
  {
    "id": 7,
    "name": "Mercedes-Benz eActros 400",
    "shortDescription": "Elektrischer Verteilerverkehr auf höchstem Niveau – leise, sauber und effizient in urbanen Gebieten.",
    "description": "Der Mercedes-Benz eActros 400 definiert elektrischen Verteilerverkehr neu. Mit 400 km Reichweite und 420 kWh Batteriekapazität meistert er den urbanen Lieferalltag souverän. Die 400 kW Spitzenleistung garantiert auch bei voller Beladung zügiges Vorankommen.\n\nDC-Schnellladen mit bis zu 160 kW ermöglicht kurze Ladezeiten. Das kompakte M-Fahrerhaus ist ideal für Stop-and-Go. Die Wärmepumpen-Klimatisierung schont die Reichweite bei kalten Temperaturen. Ideal für nachhaltige City-Logistik.",
    "longDescription": "Der Mercedes-Benz eActros 400 ist die Speerspitze des elektrischen Verteilerverkehrs. Mit einer Reichweite von 400 Kilometern und einem zulässigen Gesamtgewicht von 27 Tonnen deckt er ein breites Spektrum von Anwendungen ab – von der Belieferung innerstädtischer Geschäfte bis zum regionalen Warenumschlag. Dabei fährt er lokal emissionsfrei und nahezu geräuschlos durch urbane Gebiete.\n\nVier Batteriepakete mit NMC-Technologie und einer Gesamtkapazität von 420 kWh versorgen den Elektromotor mit Energie. Die Dauerleistung von 330 kW reicht für alle typischen Verteileraufgaben mehr als aus, während die Spitzenleistung von 400 kW auch bei voller Beladung zügiges Vorankommen garantiert.\n\nDas Laden ist flexibel gestaltet: Über Nacht kann der eActros 400 an der Depot-Wechselstromstation geladen werden, unterwegs ermöglichen DC-Schnellladesäulen das schnelle Nachladen. Mit maximal 160 kW Ladeleistung ist die Batterie in überschaubarer Zeit wieder einsatzbereit.\n\nDas kompakte M-Fahrerhaus ist ideal für den Stop-and-Go-Betrieb im Verteilerverkehr. Der Active Brake Assist 5 und der Abbiege-Assistent sorgen für maximale Sicherheit im komplexen Stadtverkehr.",
    "category": "Verteilerverkehr/Elektro",
    "series": "eActros",
    "imageUrl": "https://images.unsplash.com/photo-1558618047-3c8c76ca7d13?w=800&h=600&fit=crop",
    "highlights": [
      "Vier NMC-Batteriepakete",
      "AC- und DC-Laden",
      "Kabinenheizung elektrisch",
      "Active Brake Assist 5",
      "Rekuperationsbremse",
      "Wärmepumpe"
    ],
    "priceEur": 242000,
    "specs": {
      "antrieb": "Elektrisch",
      "dauerleistung_kw": "330",
      "spitzenleistung_kw": "400",
      "batteriekapazitaet_kwh": "420",
      "reichweite_km": "400",
      "ladeleistung_max_kw": "160",
      "gesamtgewicht_t": "27",
      "fahrerhaustyp": "M-Fahrerhaus"
    }
  },
  {
    "id": 8,
    "name": "Mercedes-Benz Arocs 3251 K 8x4",
    "shortDescription": "Der robuste Kraftprotz für schwere Baustelleneinsätze – maximale Tragfähigkeit und unerschütterliche Zuverlässigkeit.",
    "description": "Der Mercedes-Benz Arocs 3251 K 8x4 ist für extremste Baustellenbedingungen konzipiert. Mit 510 PS, 8x4-Antrieb und dem verstärkten Grounder-Fahrwerk meistert er auch anspruchsvollstes Gelände. Die Turbo-Retarder-Kupplung ermöglicht präzises Manövrieren bei extremen Steigungen.\n\nDifferentialsperren an beiden Achsen garantieren Traktion auf jedem Untergrund. Das Multimedia Cockpit und der Nebenantrieb für Kipperaufbauten machen ihn zum vielseitigen Baustellen-Partner.",
    "longDescription": "Der Mercedes-Benz Arocs 3251 K 8x4 ist der unerschütterliche Partner für schwere Baustelleneinsätze. Mit seiner 8x4-Konfiguration und dem Grounder-Fahrwerk meistert er auch extremste Bedingungen – sei es auf aufgeweichten Böden, in steilem Gelände oder unter maximaler Beladung. Wo andere Fahrzeuge an ihre Grenzen stoßen, fängt der Arocs erst richtig an.\n\nDer OM 471 Motor mit 510 PS und 2.500 Nm Drehmoment liefert die Kraft, die auf der Baustelle gebraucht wird. Die Turbo-Retarder-Kupplung ermöglicht präzises Manövrieren auch bei extremen Steigungen und schwerem Kipperaufbau. Das Grounder-Fahrwerk mit Stahlfederung ist für die härtesten Einsatzbedingungen konzipiert.\n\nDas ClassicSpace-Fahrerhaus bietet dem Fahrer einen funktionalen Arbeitsplatz mit hervorragender Rundumsicht. Der Nebenantrieb ermöglicht den Betrieb von Kippern, Betonmischern und anderen Aufbauten. Der Active Brake Assist 5 und die Berganfahrhilfe sorgen für Sicherheit auf der Baustelle.",
    "category": "Baustellenverkehr",
    "series": "Arocs",
    "imageUrl": "https://images.unsplash.com/photo-1567789884554-0b844b597180?w=800&h=600&fit=crop",
    "highlights": [
      "Turbo-Retarder-Kupplung",
      "Stahlfederung Grounder",
      "Hydraulische Abstützung",
      "Active Brake Assist 5",
      "Differentialsperre vorne/hinten",
      "Robuste Stoßfänger in Stahl"
    ],
    "priceEur": 197500,
    "specs": {
      "motor": "OM 471 Euro VI-E",
      "hubraum_l": "12.8",
      "leistung_ps": "510",
      "leistung_kw": "375",
      "drehmoment_nm": "2500",
      "antriebsformel": "8x4",
      "getriebe": "Mercedes PowerShift 3 (12-Gang)",
      "gesamtgewicht_t": "41",
      "fahrerhaustyp": "ClassicSpace",
      "nebenantrieb": "True"
    }
  },
  {
    "id": 9,
    "name": "Mercedes-Benz Arocs 2653 L 6x4",
    "shortDescription": "Kraftvolle Performance für anspruchsvolle Baustellenlogistik – ideal für Betonmischer und Kipperanwendungen.",
    "description": "Der Mercedes-Benz Arocs 2653 L 6x4 ist für schwere Baustellenarbeit konzipiert. Der 530 PS starke OM 473 mit 15,6 Litern Hubraum liefert souveräne Kraft für Betonmischer und Kipper. Die Flüssigkeitskupplung ermöglicht verschleißfreies Anfahren auch auf extremen Steigungen.\n\nDas 6x4-Fahrwerk verkraftet höchste Lasten. Hydraulikanschlüsse versorgen alle gängigen Aufbauten. Der Abbiege-Assistent und Active Brake Assist 5 sorgen für Sicherheit auf der Baustelle.",
    "longDescription": "Der Mercedes-Benz Arocs 2653 L 6x4 ist das Arbeitstier für anspruchsvolle Baustofflogistik. Mit seinem mächtigen OM 473 Motor und 530 PS bewegt er schwere Betonmischer und Kipperaufbauten mühelos durch den Baustellenalltag. Der große Hubraum von 15,6 Litern garantiert souveräne Kraftentfaltung bei jeder Drehzahl.\n\nDie Flüssigkeitskupplung ermöglicht butterweiche Anfahrvorgänge auch bei voller Beladung und auf extremen Steigungen – ideal für Betonmischer. Das 6x4-Fahrwerk mit Stahlfederung ist auf maximale Belastbarkeit ausgelegt. Der Hydraulikanschluss für Aufbauten liefert Energie für Kipper, Betonmischer und Ladekrane.\n\nMit dem Abbiege-Assistenten und dem Active Brake Assist 5 setzt der Arocs 2653 auf modernste Sicherheitstechnik. Der Arocs 2653 L 6x4 ist die richtige Wahl für Unternehmen, die maximale Produktivität auf der Baustelle fordern.",
    "category": "Baustellenverkehr",
    "series": "Arocs",
    "imageUrl": "https://images.unsplash.com/photo-1504270232528-89ca5a53e0bd?w=800&h=600&fit=crop",
    "highlights": [
      "OM 473 Großmotor",
      "Flüssigkeitskupplung",
      "Stahlfederung",
      "Hydraulik für Aufbauten",
      "Active Brake Assist 5",
      "Abbiege-Assistent"
    ],
    "priceEur": 178900,
    "specs": {
      "motor": "OM 473 Euro VI-E",
      "hubraum_l": "15.6",
      "leistung_ps": "530",
      "leistung_kw": "390",
      "drehmoment_nm": "2600",
      "antriebsformel": "6x4",
      "gesamtgewicht_t": "33",
      "fahrerhaustyp": "CompactSpace"
    }
  },
  {
    "id": 10,
    "name": "Mercedes-Benz Arocs Extent 3253 K",
    "shortDescription": "Streng limitiert auf 100 Exemplare – der exklusivste Arocs aller Zeiten mit einzigartigen Design-Elementen.",
    "description": "Der Mercedes-Benz Arocs Extent ist streng auf 100 Exemplare limitiert – das exklusivste Baustellenfahrzeug von Mercedes-Benz. Der Dark-Chrome Arocs-Schriftzug, die schwarze Blende hinter dem Stern und die LED-Zusatzleuchten machen ihn unverwechselbar.\n\nTechnisch basiert er auf dem Arocs 3253 K mit 530 PS und 8x4-Antrieb. Leder-Lenkrad und Carbon-Optik Elemente werten das Interieur auf. Jedes Fahrzeug trägt eine Nummerierungsplakette. Für Profis mit Stil.",
    "longDescription": "Der Mercedes-Benz Arocs Extent ist das exklusivste Baustellenfahrzeug, das jemals einen Mercedes-Stern getragen hat. Streng limitiert auf nur 100 Exemplare weltweit, vereint dieses Sondermodell die unverwüstliche Robustheit des Arocs mit einzigartigen Design-Elementen.\n\nSchon aus der Ferne fällt das markante Design auf: Die schwarze Blende hinter dem Mercedes-Stern und der exklusive Arocs-Schriftzug in Dark-Chrome setzen kraftvolle Akzente. Die LED-Scheinwerfer werden von zusätzlichen LED-Leuchten in der Sonnenblende ergänzt. Die Carbon-Optik Zierelemente und die premium Edelstahl-Achskappen unterstreichen den exklusiven Charakter.\n\nTechnisch basiert der Extent auf dem bewährten Arocs 3253 K. Der OM 473 Motor mit 530 PS liefert die Kraft für schwerste Einsätze. Das Leder-Lenkrad liegt perfekt in der Hand. Jedes Fahrzeug trägt eine individuelle Nummerierungsplakette am Exterieur.",
    "category": "Baustellenverkehr/Sondermodell",
    "series": "Arocs",
    "imageUrl": "https://images.unsplash.com/photo-1609143739217-01b60dad1c67?w=800&h=600&fit=crop",
    "highlights": [
      "Exklusives Arocs-Schriftzug in Dark-Chrome",
      "Schwarze Blende hinter Mercedes-Stern",
      "LED-Scheinwerfer mit LED-Zusatzleuchten",
      "Carbon-Optik Zierelemente",
      "Edelstahl-Achskappen",
      "Leder-Lenkrad",
      "Nummerierungsplakette"
    ],
    "priceEur": 235000,
    "specs": {
      "motor": "OM 473 Euro VI-E",
      "hubraum_l": "15.6",
      "leistung_ps": "530",
      "leistung_kw": "390",
      "antriebsformel": "8x4",
      "gesamtgewicht_t": "41",
      "fahrerhaustyp": "BigSpace"
    }
  },
  {
    "id": 11,
    "name": "Mercedes-Benz Arocs 4145 K 8x8",
    "shortDescription": "Kompromisslose Geländefähigkeit mit Vierradantrieb – für extremste Bedingungen abseits befestigter Straßen.",
    "description": "Der Mercedes-Benz Arocs 4145 K 8x8 ist für extremstes Gelände konzipiert. Der permanente 8x8-Allradantrieb mit drei schaltbaren Differentialsperren garantiert Traktion unter allen Bedingungen. 400 mm Bodenfreiheit und 800 mm Wattiefe ermöglichen Durchfahrten durch jedes Hindernis.\n\nDer 449 PS Motor mit Off-Road-Getriebeabstimmung bietet perfekte Kontrolle. Ideal für Steinbrüche, Kieswerke und Waldwirtschaft.",
    "longDescription": "Der Mercedes-Benz Arocs 4145 K 8x8 ist für Einsätze konzipiert, bei denen herkömmliche Baustellenfahrzeuge kapitulieren. Mit seinem permanenten Allradantrieb an allen vier Achsen und drei schaltbaren Differentialsperren meistert er auch extremstes Gelände – tiefe Schlammlöcher, steile Abraumhalden oder aufgeweichte Waldwege.\n\nDer OM 470 Motor mit 449 PS ist auf den Geländeeinsatz abgestimmt. Das Mercedes PowerShift 3 Off-Road Getriebe verfügt über spezielle Abstufungen für Langsamfahrt. Das Grounder Plus Fahrwerk kombiniert maximale Robustheit mit beeindruckender Geländegängigkeit. Die erhöhte Bodenfreiheit von 400 Millimetern und eine Wattiefe von 800 Millimetern ermöglichen Durchfahrten durch tiefe Pfützen.\n\nDie drei schaltbaren Differentialsperren lassen sich einzeln oder gemeinsam aktivieren. Die Bergabfahrhilfe hält das Fahrzeug bei Gefällestrecken automatisch auf konstantem Tempo.",
    "category": "Baustellenverkehr/Allrad",
    "series": "Arocs",
    "imageUrl": "https://images.unsplash.com/photo-1611273426858-450d8e3c9fce?w=800&h=600&fit=crop",
    "highlights": [
      "Permanenter Allradantrieb 8x8",
      "Drei schaltbare Differentialsperren",
      "Off-Road Getriebeabstimmung",
      "Erhöhte Bodenfreiheit 400mm",
      "Wattiefe 800mm",
      "Unterfahrschutz Stahl"
    ],
    "priceEur": 215000,
    "specs": {
      "motor": "OM 470 Euro VI-E",
      "hubraum_l": "10.7",
      "leistung_ps": "449",
      "antriebsformel": "8x8",
      "gesamtgewicht_t": "41",
      "bodenfreiheit_mm": "400",
      "wattiefe_mm": "800"
    }
  },
  {
    "id": 12,
    "name": "Mercedes-Benz Atego 1224 L",
    "shortDescription": "Der wendige Allrounder für den leichten Verteilerverkehr – perfekt für Innenstädte und enge Zufahrten.",
    "description": "Der Mercedes-Benz Atego 1224 L ist der Spezialist für den leichten Verteilerverkehr. Mit 238 PS und kompaktem Wendekreis meistert er enge Innenstädte mühelos. Das neue 10,25-Zoll LCD-Display ersetzt die analogen Instrumente.\n\nDer Active Brake Assist 6 und Active Sideguard Assist 2 setzen auf modernste Sensorfusion für maximale Sicherheit. Die niedrige Einstiegshöhe und die Rückfahrkamera erleichtern den Stop-and-Go-Alltag. Der zuverlässige Partner für urbane Logistik.",
    "longDescription": "Der Mercedes-Benz Atego 1224 L ist seit 25 Jahren das Maß aller Dinge im leichten Verteilerverkehr. Mit der neuesten Modellgeneration setzt er diese Erfolgsgeschichte fort und kombiniert bewährte Tugenden mit modernster Technik. Das kompakte Format und der enge Wendekreis machen ihn zum idealen Partner für Lieferungen in Innenstädten.\n\nDer OM 936 Motor mit 238 PS bietet reichlich Leistung für den urbanen Einsatz. Das vollständig überarbeitete Cockpit präsentiert sich mit einem hochauflösenden 10,25-Zoll LCD-Display. Der Active Brake Assist 6 und der Active Sideguard Assist 2 entsprechen dem neuesten Stand der Technik.\n\nDas S-Fahrerhaus mit niedriger Einstiegshöhe erleichtert das häufige Ein- und Aussteigen erheblich. Die Rückfahrkamera unterstützt bei Rangiermanövern. Der Atego 1224 L ist das zuverlässige Arbeitstier für den städtischen Verteilerverkehr.",
    "category": "Verteilerverkehr",
    "series": "Atego",
    "imageUrl": "https://images.unsplash.com/photo-1586528116311-ad8dd3c8310d?w=800&h=600&fit=crop",
    "highlights": [
      "10,25-Zoll LCD-Instrumentendisplay",
      "Active Brake Assist 6",
      "Active Sideguard Assist 2",
      "Niedrige Einstiegshöhe",
      "Kompakter Wendekreis",
      "Rückfahrkamera"
    ],
    "priceEur": 78500,
    "specs": {
      "motor": "OM 936 Euro VI-E",
      "hubraum_l": "7.7",
      "leistung_ps": "238",
      "antriebsformel": "4x2",
      "gesamtgewicht_t": "12",
      "fahrerhaustyp": "S-Fahrerhaus"
    }
  },
  {
    "id": 13,
    "name": "Mercedes-Benz Atego 1530 L",
    "shortDescription": "Die leistungsstarke Variante für mittelschweren Verteilerverkehr – ideal für größere Ladevolumen.",
    "description": "Der Mercedes-Benz Atego 1530 L bietet 299 PS für mittelschwere Transportaufgaben. Das 8-Gang PowerShift Getriebe und die Luftfederung an der Hinterachse sorgen für effizientes Fahren. Der längere Radstand ermöglicht bis zu 7,2 Meter Aufbaulänge.\n\nDas verlängerte S-Fahrerhaus eignet sich für längere Touren. Die Ladebordwand-Vorbereitung ist serienmäßig. Der Active Brake Assist 6 bietet umfassende Sicherheit. Die perfekte Wahl für anspruchsvollen Verteilerverkehr.",
    "longDescription": "Der Mercedes-Benz Atego 1530 L schließt die Lücke zwischen leichtem Verteilerverkehr und schwerem Nutzfahrzeug. Mit 299 PS und 15 Tonnen zulässigem Gesamtgewicht bietet er die richtige Kombination aus Leistung und Wirtschaftlichkeit. Der längere Radstand ermöglicht Aufbaulängen bis 7,2 Meter.\n\nDas 8-Gang PowerShift Getriebe sorgt für enge Gangabstufungen. Die Luftfederung an der Hinterachse passt die Fahrzeughöhe automatisch an die Beladung an. Das verlängerte S-Fahrerhaus bietet mehr Stauraum. Die Ladebordwand-Vorbereitung ist serienmäßig verbaut.\n\nMit dem Active Brake Assist 6 und dem Spurhalteassistent verfügt der Atego 1530 über ein umfassendes Sicherheitspaket. Der ideale Partner für mittelschweren Verteilerverkehr.",
    "category": "Verteilerverkehr",
    "series": "Atego",
    "imageUrl": "https://images.unsplash.com/photo-1570793005386-838e52f1f284?w=800&h=600&fit=crop",
    "highlights": [
      "8-Gang PowerShift Getriebe",
      "Verlängertes S-Fahrerhaus",
      "Active Brake Assist 6",
      "Luftfederung Hinterachse",
      "Ladebordwand-Vorbereitung",
      "Navigationssystem"
    ],
    "priceEur": 98500,
    "specs": {
      "motor": "OM 936 Euro VI-E",
      "hubraum_l": "7.7",
      "leistung_ps": "299",
      "antriebsformel": "4x2",
      "getriebe": "PowerShift 3 (8-Gang)",
      "gesamtgewicht_t": "15",
      "ladeflaeche_m": "7.2"
    }
  },
  {
    "id": 14,
    "name": "Mercedes-Benz Atego 1630 AF",
    "shortDescription": "Der robuste Allrounder für Bau und Rettungsdienst – mit verstärkter Hinterachse für erhöhte Tragfähigkeit.",
    "description": "Der Mercedes-Benz Atego 1630 AF bietet eine verstärkte 10-Tonnen Hinterachse mit Singlebereifung für maximale Aufbau-Flexibilität. Mit 299 PS und robustem Nebenantrieb ist er ideal für Feuerwehr- und Baustellenaufbauten.\n\nDie erhöhte Bodenfreiheit und der optionale Allradantrieb ermöglichen Einsätze in schwierigem Gelände. Die Feuerwehr-Vorbereitung ist verfügbar. Die perfekte Basis für Spezialfahrzeuge.",
    "longDescription": "Der Mercedes-Benz Atego 1630 AF ist für Spezialanwendungen in Bau und Rettungswesen konzipiert. Mit seiner verstärkten 10-Tonnen Hinterachse und der Singlebereifung bietet er maximale Flexibilität bei der Gewichtsverteilung von Aufbauten. Die erhöhte Achslast ermöglicht schwerere Aggregate.\n\nDer OM 936 Motor mit 299 PS liefert die Kraft für anspruchsvolle Einsätze. Der Nebenantrieb stellt Hydraulikleistung für Feuerwehrpumpen, Ladekrane oder andere Aufbauten zur Verfügung. Die optionale Feuerwehr-Vorbereitung umfasst spezielle Elektrik und verstärkte Lichtmaschine.\n\nMit dem Active Brake Assist 6 verfügt auch dieses Spezialfahrzeug über modernste Sicherheitstechnik. Die robuste Basis für anspruchsvolle Spezialaufbauten.",
    "category": "Bauverkehr/Feuerwehr",
    "series": "Atego",
    "imageUrl": "https://images.unsplash.com/photo-1566576912321-d58ddd7a6088?w=800&h=600&fit=crop",
    "highlights": [
      "10-Tonnen Hinterachse",
      "Singlebereifung für Flexibilität",
      "Nebenantrieb für Aufbauten",
      "Active Brake Assist 6",
      "Robuste Stoßfänger",
      "Feuerwehr-Vorbereitung"
    ],
    "priceEur": 112000,
    "specs": {
      "motor": "OM 936 Euro VI-E",
      "leistung_ps": "299",
      "antriebsformel": "4x2",
      "gesamtgewicht_t": "16",
      "hinterachse_t": "10",
      "bereifung": "Singlebereifung hinten"
    }
  },
  {
    "id": 15,
    "name": "Mercedes-Benz Econic 2630 L 6x2",
    "shortDescription": "Das Low-Entry-Konzept für den urbanen Kommunaleinsatz – nur zwei Schritte bis ins Fahrerhaus.",
    "description": "Der Mercedes-Benz Econic 2630 L setzt Maßstäbe im Kommunalbereich. Mit nur 380 mm Einstiegshöhe und dem Low-Entry-Konzept sind nur zwei Schritte bis ins Fahrerhaus nötig. Die Panorama-Windschutzscheibe und niedrige Sitzposition ermöglichen beste Rundumsicht.\n\nDas Allison Automatikgetriebe ist perfekt auf Stop-and-Go abgestimmt. Der Active Sideguard Assist 2 mit 360-Grad Kameras schützt Fußgänger und Radfahrer. Das ergonomischste Kommunalfahrzeug seiner Klasse.",
    "longDescription": "Der Mercedes-Benz Econic 2630 L ist das Ergebnis konsequenten Designs für den urbanen Kommunaleinsatz. Das revolutionäre Low-Entry-Konzept ermöglicht einen Einstieg in nur zwei Schritten – die Einstiegshöhe von nur 380 Millimetern schont die Gelenke der Müllwerker bei hunderten Ein- und Ausstiegen pro Schicht.\n\nDie niedrige Fahrerposition und die Panorama-Windschutzscheibe bieten eine einzigartige Rundumsicht. Der Fahrer sitzt auf Augenhöhe mit Radfahrern und Fußgängern. Das Allison Automatikgetriebe ist speziell auf den Stop-and-Go-Betrieb abgestimmt.\n\nDer Active Sideguard Assist 2 mit 360-Grad Kamerasystem schafft ein umfassendes Sicherheitsnetz. Das Fahrerhaus bietet volle Stehöhe und beidseitige Einstiegstüren. Der Econic 2630 L ist die Referenz für ergonomisches Arbeiten im Kommunalbereich.",
    "category": "Kommunalverkehr",
    "series": "Econic",
    "imageUrl": "https://images.unsplash.com/photo-1558905586-526e4a45a526?w=800&h=600&fit=crop",
    "highlights": [
      "Einstiegshöhe nur 380mm",
      "Panorama-Windschutzscheibe",
      "Niedrige Fahrerhausposition",
      "Allison Automatikgetriebe",
      "Active Sideguard Assist 2",
      "360-Grad Kamerasystem",
      "Beidseitige Einstiegstüren"
    ],
    "priceEur": 165000,
    "specs": {
      "motor": "OM 936 Euro VI-E",
      "leistung_ps": "299",
      "antriebsformel": "6x2",
      "getriebe": "Allison Automatik (6-Gang)",
      "gesamtgewicht_t": "26",
      "einstiegshoehe_mm": "380"
    }
  },
  {
    "id": 16,
    "name": "Mercedes-Benz eEconic",
    "shortDescription": "Elektrischer Kommunaldienst – lokal emissionsfrei und nahezu geräuschlos durch die Stadt.",
    "description": "Der Mercedes-Benz eEconic bringt elektrische Mobilität in den Kommunalbereich. Mit 420 kWh Batteriekapazität und 300 km Reichweite meistert er auch lange Sammeltouren. Der nahezu geräuschlose Betrieb ermöglicht frühmorgendliche Einsätze ohne Lärmbelästigung.\n\nDas Low-Entry-Konzept mit 380 mm Einstiegshöhe bleibt erhalten. Die Wärmepumpen-Klimatisierung schont die Reichweite. Die umweltfreundliche Müllabfuhr der Zukunft – heute schon verfügbar.",
    "longDescription": "Der Mercedes-Benz eEconic ist die elektrische Evolution des bewährten Econic-Konzepts. Er kombiniert das einzigartige Low-Entry-Design mit lokal emissionsfreiem Antrieb und macht die Müllabfuhr der Zukunft zur Realität von heute. In Wohngebieten fällt vor allem seine Lautlosigkeit auf – die frühmorgendliche Müllabfuhr stört nicht mehr den Schlaf.\n\nVier Batteriepakete mit einer Gesamtkapazität von 420 kWh liefern eine Reichweite von rund 300 Kilometern. Die Rekuperationsbremse gewinnt bei den zahlreichen Bremsvorgängen Energie zurück. Das Low-Entry-Fahrerhaus mit 380 Millimetern Einstiegshöhe bleibt erhalten.\n\nDie Wärmepumpen-Klimatisierung arbeitet hocheffizient. Das 360-Grad Kamerasystem und der Active Sideguard Assist bieten ein umfassendes Sicherheitspaket. Mit dem eEconic können Kommunen ihre Klimaziele konkret umsetzen.",
    "category": "Kommunalverkehr/Elektro",
    "series": "eEconic",
    "imageUrl": "https://images.unsplash.com/photo-1617886903355-9354bb57751f?w=800&h=600&fit=crop",
    "highlights": [
      "Low-Entry Konzept",
      "Vier NMC-Batteriepakete",
      "Nahezu geräuschlos im Betrieb",
      "Rekuperationsbremse",
      "Panorama-Windschutzscheibe",
      "360-Grad Kamerasystem",
      "Wärmepumpen-Klimatisierung"
    ],
    "priceEur": 325000,
    "specs": {
      "antrieb": "Elektrisch",
      "dauerleistung_kw": "330",
      "spitzenleistung_kw": "400",
      "batteriekapazitaet_kwh": "420",
      "reichweite_km": "300",
      "antriebsformel": "6x2",
      "gesamtgewicht_t": "27",
      "einstiegshoehe_mm": "380"
    }
  },
  {
    "id": 17,
    "name": "Mercedes-Benz Econic 1830 L NGT",
    "shortDescription": "Sauberer Antrieb mit Erdgas – reduzierte Emissionen bei bewährter Zuverlässigkeit.",
    "description": "Der Mercedes-Benz Econic 1830 L NGT verbindet Erdgas-Antrieb mit dem Low-Entry-Konzept. Der M 936 G Motor mit 302 PS läuft besonders ruhig und emissionsarm. Mit Bio-CNG wird ein nahezu klimaneutraler Betrieb möglich.\n\nDie Gastanks sind platzsparend auf dem Rahmen montiert. Die niedrige Einstiegshöhe und Panorama-Windschutzscheibe bleiben erhalten. Die saubere Alternative im Kommunalbereich.",
    "longDescription": "Der Mercedes-Benz Econic 1830 L NGT bietet eine umweltfreundliche Alternative zum Dieselantrieb. Der Erdgas-Motor M 936 G liefert 302 PS und vereint kraftvolle Leistung mit deutlich reduzierten Emissionen. Bei Nutzung von Bio-CNG kann die CO2-Bilanz nahezu klimaneutral ausfallen.\n\nDer Erdgas-Antrieb zeichnet sich durch besonders ruhigen Lauf aus. Die Gastanks sind platzsparend auf dem Rahmen montiert. Das bewährte Low-Entry-Konzept bleibt vollständig erhalten. Die Panorama-Windschutzscheibe macht den Arbeitsalltag sicherer.\n\nDie Reichweite mit 80 Kilogramm CNG ist für kommunale Anwendungen mehr als ausreichend. Die Betankung dauert nur wenige Minuten. Die saubere Alternative im Kommunalbereich.",
    "category": "Kommunalverkehr/Erdgas",
    "series": "Econic",
    "imageUrl": "https://images.unsplash.com/photo-1558906096-f6ec15e85c3f?w=800&h=600&fit=crop",
    "highlights": [
      "CNG-Gastanks auf dem Rahmen",
      "Low-Entry Konzept",
      "Allison Automatikgetriebe",
      "Panorama-Windschutzscheibe",
      "Active Sideguard Assist",
      "Niedrige Geräuschemissionen",
      "Bio-CNG kompatibel"
    ],
    "priceEur": 185000,
    "specs": {
      "motor": "M 936 G NGT Euro VI",
      "leistung_ps": "302",
      "kraftstoff": "CNG (Compressed Natural Gas)",
      "tankvolumen_kg": "80",
      "antriebsformel": "4x2",
      "gesamtgewicht_t": "18",
      "einstiegshoehe_mm": "380"
    }
  },
  {
    "id": 18,
    "name": "Mercedes-Benz Unimog U 430",
    "shortDescription": "Der legendäre Geräteträger – universelles Multitalent für Kommunal, Agrar und Spezialanwendungen.",
    "description": "Der Mercedes-Benz Unimog U 430 ist das universelle Multitalent. Mit 299 PS, permanentem 4x4-Antrieb und drei Anbauräumen kann er hunderte Geräte tragen. Der Kriechgang bis 0,04 km/h ermöglicht präziseste Arbeiten.\n\nDas VarioPilot-System erlaubt wechselseitiges Fahren für mehr Sicherheit. Zapfwellen vorne und hinten versorgen alle gängigen Anbaugeräte. Der Unimog – seit 70 Jahren die Referenz für Vielseitigkeit.",
    "longDescription": "Der Mercedes-Benz Unimog U 430 ist weit mehr als ein Fahrzeug – er ist ein Konzept. Seit über 70 Jahren verkörpert der Unimog die Idee des universellen Geräteträgers. Der U 430 setzt diese Tradition fort und kombiniert legendäre Unimog-Tugenden mit modernster Technik.\n\nDer OM 936 Motor mit 299 PS liefert die Kraft für anspruchsvollste Arbeitseinsätze. Das einzigartige UG 100/8 Getriebe ermöglicht Kriechgeschwindigkeiten bis 0,04 km/h. Die drei Anbauräume ermöglichen die gleichzeitige Montage mehrerer Geräte. Die Zapfwellen an Front und Heck treiben Mähwerke, Streuer und Kehrmaschinen an.\n\nDas VarioPilot-System ermöglicht wechselseitiges Fahren: Der Bedienerplatz kann vom Fahrer zur Beifahrerseite gewechselt werden – ohne Umbau, während der Fahrt. Die legendären Portalachsen sorgen für die typische Bodenfreiheit des Unimog.",
    "category": "Geräteträger/Kommunal",
    "series": "Unimog",
    "imageUrl": "https://images.unsplash.com/photo-1533473359331-0135ef1b58bf?w=800&h=600&fit=crop",
    "highlights": [
      "Permanenter Allradantrieb",
      "VarioPilot wechselseitiges Fahren",
      "Drei Anbauräume vorne/hinten/seitlich",
      "Zapfwellen vorne und hinten",
      "EasyDrive Automatikfunktion",
      "Portalachsen für Bodenfreiheit",
      "Arbeitshydraulik bis 200 l/min"
    ],
    "priceEur": 198000,
    "specs": {
      "motor": "OM 936 Euro VI-E",
      "leistung_ps": "299",
      "antriebsformel": "4x4 permanent",
      "getriebe": "UG 100/8 (8-Gang)",
      "gesamtgewicht_t": "14.5",
      "radstand_mm": "3600",
      "kriechgang": "0.04 km/h"
    }
  },
  {
    "id": 19,
    "name": "Mercedes-Benz Unimog U 5023",
    "shortDescription": "Extrem geländegängig – für Einsätze dort, wo andere nicht mehr weiterkommen.",
    "description": "Der Mercedes-Benz Unimog U 5023 ist für extremstes Gelände konzipiert. Mit 570 mm Bodenfreiheit, 1.200 mm Wattiefe und 100% Steigfähigkeit überwindet er jedes Hindernis. Die Portalachsen und Differentialsperren garantieren legendäre Geländegängigkeit.\n\nDer 231 PS Motor mit Kriechgängen ermöglicht präzise Kontrolle. Die Reifendruckanlage passt den Druck während der Fahrt an. Für Expeditionen, Bergrettung und Forstwirtschaft.",
    "longDescription": "Der Mercedes-Benz Unimog U 5023 ist die ultimative Antwort auf extremste Geländeherausforderungen. Mit einer Bodenfreiheit von 570 Millimetern, einer Wattiefe von 1.200 Millimetern und einer Steigfähigkeit von 100 Prozent überwindet er Hindernisse, an denen jedes andere Fahrzeug scheitert.\n\nDer OM 934 Motor mit 231 PS ist auf Geländetauglichkeit optimiert. Die legendären Portalachsen sind das Geheimnis der extremen Bodenfreiheit. Die Differentialsperren an Vorder- und Hinterachse garantieren Traktion. Die optionale Reifendruckanlage ermöglicht die Anpassung während der Fahrt.\n\nDer U 5023 ist die bevorzugte Basis für Expeditionsfahrzeuge und Spezialanwendungen in Bergrettung, Forstwirtschaft und Energiewirtschaft. Ein Fahrzeug für Menschen, die das Abenteuer suchen.",
    "category": "Hochgeländegängig",
    "series": "Unimog",
    "imageUrl": "https://images.unsplash.com/photo-1503376780353-7e6692767b70?w=800&h=600&fit=crop",
    "highlights": [
      "570mm Bodenfreiheit",
      "1200mm Wattiefe",
      "100% Steigfähigkeit",
      "Reifendruckanlage",
      "Differentialsperren vorne/hinten",
      "Portalachsen",
      "Seilwinde optional",
      "Expeditionsvorbereitung"
    ],
    "priceEur": 235000,
    "specs": {
      "motor": "OM 934 Euro VI-E",
      "leistung_ps": "231",
      "antriebsformel": "4x4 permanent",
      "gesamtgewicht_t": "14.5",
      "bodenfreiheit_mm": "570",
      "wattiefe_mm": "1200",
      "steigfaehigkeit_prozent": "100"
    }
  },
  {
    "id": 20,
    "name": "Mercedes-Benz Zetros 3343 A 6x6",
    "shortDescription": "Das Extrem-Schwerlastfahrzeug für härteste Bedingungen – unaufhaltsam im Gelände.",
    "description": "Der Mercedes-Benz Zetros 3343 A 6x6 ist für extremste Einsätze konzipiert. Mit permanentem 6x6-Antrieb, drei Differentialsperren und 428 PS bewältigt er Wüste, Bergbau und Katastrophengebiete. 400 mm Bodenfreiheit und 1.000 mm Wattiefe machen ihn unaufhaltsam.\n\nDas robuste Fahrwerk verkraftet schwerste Belastungen. Mit 120 t Zuggesamtgewicht ist er auch als Schwerlastzugmaschine einsetzbar. Das kompromisslose Werkzeug für härteste Bedingungen.",
    "longDescription": "Der Mercedes-Benz Zetros 3343 A 6x6 ist für die extremsten Einsatzszenarien konzipiert. Ob Wüsteneinsatz, Bergbau oder Katastrophenhilfe – der Zetros meistert Bedingungen, unter denen herkömmliche Fahrzeuge längst kapituliert hätten. Mit seinem permanenten 6x6-Allradantrieb und drei schaltbaren Differentialsperren ist er praktisch unaufhaltsam.\n\nDer OM 460 Motor mit 428 PS liefert brachiale Kraft bei jeder Drehzahl. Das massive Drehmoment von 2.100 Nm steht bei niedrigen Drehzahlen zur Verfügung. Das robuste G 330-12 Getriebe mit Untersetzungsgruppe verdoppelt die Ganganzahl für extreme Situationen.\n\nDas Fahrwerk ist auf maximale Belastbarkeit ausgelegt. Die Klimaanlage arbeitet zuverlässig bei -30 bis +50 Grad Celsius. Mit 120 Tonnen Zuggesamtgewicht eignet sich der Zetros auch als Zugmaschine für schwerste Lasten.",
    "category": "Schwerlast/Offroad",
    "series": "Zetros",
    "imageUrl": "https://images.unsplash.com/photo-1552519507-da3b142c6e3d?w=800&h=600&fit=crop",
    "highlights": [
      "Permanenter 6x6-Allradantrieb",
      "Drei Differentialsperren",
      "Untersetzungsgetriebe",
      "Stahlfederung mit hoher Tragfähigkeit",
      "Klimaanlage -30 bis +50°C",
      "Berganfahrhilfe",
      "Seilwindenaufnahme"
    ],
    "priceEur": 285000,
    "specs": {
      "motor": "OM 460 Euro III",
      "leistung_ps": "428",
      "antriebsformel": "6x6 permanent",
      "getriebe": "Mercedes G 330-12 (12-Gang)",
      "gesamtgewicht_t": "33",
      "zuggesamtgewicht_t": "120",
      "bodenfreiheit_mm": "400",
      "wattiefe_mm": "1000"
    }
  },
  {
    "id": 21,
    "name": "Mercedes-Benz Actros SLT 4163 8x6",
    "shortDescription": "Die Schwerlastzugmaschine für außergewöhnliche Transportaufgaben – bis 250 Tonnen Gesamtzuggewicht.",
    "description": "Der Mercedes-Benz Actros SLT 4163 8x6 ist die ultimative Schwerlastzugmaschine. Mit 625 PS, 3.000 Nm und bis zu 250 t Zuggesamtgewicht bewegt er außergewöhnliche Lasten. Die Turbo-Retarder-Kupplung ermöglicht präzises Manövrieren.\n\nDas 16-Gang SLT-Getriebe mit Kriechgang und die lenkbare Hinterachse sorgen für Wendigkeit. Das GigaSpace-Fahrerhaus mit Experience Room bietet Wohnkomfort. Individuell gefertigt von Custom Tailored Trucks.",
    "longDescription": "Der Mercedes-Benz Actros SLT 4163 8x6 ist für die Königsdisziplin des Straßentransports konzipiert: den Schwerlasttransport. Mit einem zulässigen Gesamtzuggewicht von bis zu 250 Tonnen bewegt er Lasten, die für andere Fahrzeuge unmöglich sind – von Transformatoren über Windkraftanlagen bis hin zu kompletten Industrieanlagen.\n\nDer mächtige OM 473 Motor mit 625 PS und 3.000 Nm Drehmoment bildet das Kraftzentrum. Die Turbo-Retarder-Kupplung ermöglicht präzises Manövrieren mit schwerem Tiefbettanhänger. Das SLT-Getriebe mit 16 Gängen und Kriechgangstufe bietet für jede Situation die passende Übersetzung.\n\nDas GigaSpace-Fahrerhaus mit Actros Experience Room und zwei Schlafplätzen macht den SLT zum rollenden Zuhause für tagelange Transporte. Der Actros SLT 4163 wird von Custom Tailored Trucks (CTT) in Molsheim individuell gefertigt.",
    "category": "Schwerlasttransport",
    "series": "Actros SLT",
    "imageUrl": "https://images.unsplash.com/photo-1562674916-9d6f4a58e01f?w=800&h=600&fit=crop",
    "highlights": [
      "Turbo-Retarder-Kupplung",
      "SLT-Getriebe mit 16 Gängen",
      "Hinterachslift und -lenkung",
      "Telligent Niveauregelung",
      "Schwerlast-Sattelkupplung",
      "Zusatztanks 1.100 Liter",
      "Actros Experience Room"
    ],
    "priceEur": 395000,
    "specs": {
      "motor": "OM 473 Euro VI-E",
      "leistung_ps": "625",
      "drehmoment_nm": "3000",
      "antriebsformel": "8x6",
      "getriebe": "PowerShift 3 SLT (16-Gang)",
      "zuggesamtgewicht_t": "250",
      "fahrerhaustyp": "GigaSpace",
      "tankvolumen_l": "1100"
    }
  },
  {
    "id": 22,
    "name": "Mercedes-Benz Arocs SLT 4158 8x8",
    "shortDescription": "Die geländegängige Schwerlastzugmaschine – wenn extreme Lasten auch extreme Wege erfordern.",
    "description": "Der Mercedes-Benz Arocs SLT 4158 8x8 kombiniert Schwerlasttauglichkeit mit extremer Geländefähigkeit. Mit 580 PS, permanentem 8x8-Antrieb und vier Differentialsperren bewältigt er bis zu 250 t Zuggewicht auch abseits befestigter Straßen.\n\nDas Grounder-Fahrwerk mit erhöhter Bodenfreiheit und der optionale HAD-Antrieb meistern extremstes Gelände. Für Schwertransporte dorthin, wo andere nicht hinkommen.",
    "longDescription": "Der Mercedes-Benz Arocs SLT 4158 8x8 vereint die Schwerlastfähigkeit der SLT-Baureihe mit der kompromisslosen Geländetauglichkeit des Arocs. Wenn schwere Lasten nicht nur transportiert, sondern auch abseits befestigter Straßen bewegt werden müssen, ist der Arocs SLT die erste Wahl.\n\nDer OM 473 Motor mit 580 PS liefert die Kraft für Schwerlast und Gelände gleichermaßen. Der permanente 8x8-Allradantrieb mit vier schaltbaren Differentialsperren garantiert Traktion unter allen Bedingungen. Der optionale Hydraulic Auxiliary Drive (HAD) verstärkt die Antriebskraft bei extremen Steigungen.\n\nDas Grounder-Fahrwerk mit Stahlfederung ist auf maximale Belastbarkeit im Gelände ausgelegt. Die Seilwindenaufnahme ermöglicht die Montage einer Bergewinde. Mit 250 Tonnen Zuggesamtgewicht und der Geländefähigkeit eines echten Offroaders schließt der Arocs SLT eine wichtige Lücke.",
    "category": "Schwerlasttransport/Offroad",
    "series": "Arocs SLT",
    "imageUrl": "https://images.unsplash.com/photo-1592838064575-70ed626d3a0e?w=800&h=600&fit=crop",
    "highlights": [
      "Permanenter 8x8-Allradantrieb",
      "Vier Differentialsperren",
      "Stahlfederung Grounder",
      "Turbo-Retarder-Kupplung",
      "Hydraulischer Antrieb (HAD)",
      "Seilwindenaufnahme",
      "Schwerlast-Anhängerkupplung"
    ],
    "priceEur": 425000,
    "specs": {
      "motor": "OM 473 Euro VI-E",
      "leistung_ps": "580",
      "antriebsformel": "8x8",
      "zuggesamtgewicht_t": "250",
      "fahrerhaustyp": "BigSpace",
      "bodenfreiheit_mm": "320"
    }
  },
  {
    "id": 23,
    "name": "Mercedes-Benz Actros L 2653 LS 6x2 Volumer",
    "shortDescription": "Die Volumer-Variante für maximales Ladevolumen – 3 Meter lichte Höhe für optimale Raumausnutzung.",
    "description": "Der Mercedes-Benz Actros L Volumer maximiert das Ladevolumen. Mit nur 950 mm Sattelhöhe ermöglicht er drei Meter lichte Ladehöhe – ideal für voluminöse, leichte Güter. Der 530 PS starke OM 473 Motor liefert ausreichend Leistungsreserven.\n\nDie 6x2-Konfiguration mit gelenkter Nachlaufachse spart Gewicht und verbessert die Wendigkeit. Die elektronische Niveauregulierung hält die Sattelhöhe konstant. Optimale Raumausnutzung für moderne Logistik.",
    "longDescription": "Der Mercedes-Benz Actros L 2653 LS 6x2 Volumer ist speziell für Transportunternehmen entwickelt, bei denen das Ladevolumen wichtiger ist als das Gewicht. Mit einer abgesenkten Sattelhöhe von nur 950 Millimetern ermöglicht er eine lichte Ladehöhe von drei Metern – entscheidend für den Transport von voluminösen, aber leichten Gütern.\n\nDer OM 473 Motor mit 530 PS bietet auch in der Volumer-Konfiguration reichlich Leistungsreserven. Die 6x2-Achskonfiguration mit gelenkter Nachlaufachse reduziert das Leergewicht und verbessert die Wendigkeit. Die Luftfederung mit Absenkfunktion ermöglicht das Absenken an Laderampen.\n\nDie elektronische Niveauregulierung passt die Fahrzeughöhe automatisch an die Beladung an. Der Actros L Volumer ist die Wahl für Speditionen, die jedes verfügbare Kubikzentimeter Ladevolumen nutzen möchten.",
    "category": "Fernverkehr/Volumen",
    "series": "Actros L",
    "imageUrl": "https://images.unsplash.com/photo-1605705658744-45d3a9c1f9e7?w=800&h=600&fit=crop",
    "highlights": [
      "Abgesenkte Sattelhöhe 950mm",
      "3 Meter lichte Höhe möglich",
      "StreamSpace Fahrerhaus",
      "Luftfederung mit Absenkfunktion",
      "Active Brake Assist 5",
      "Predictive Powertrain Control",
      "Elektronische Niveauregulierung"
    ],
    "priceEur": 185000,
    "specs": {
      "motor": "OM 473 Euro VI-E",
      "leistung_ps": "530",
      "antriebsformel": "6x2",
      "gesamtgewicht_t": "44",
      "fahrerhaustyp": "StreamSpace Volumer",
      "sattelhoehe_mm": "950",
      "lichte_hoehe_m": "3.0"
    }
  },
  {
    "id": 24,
    "name": "Mercedes-Benz Actros L 1843 LS Loader",
    "shortDescription": "Die Leichtbau-Variante für maximale Nutzlast – bis zu 350 kg weniger Leergewicht.",
    "description": "Der Mercedes-Benz Actros L Loader maximiert die Nutzlast durch konsequenten Leichtbau. Bis zu 350 kg weniger Leergewicht durch Aluminium-Räder, kompakteren Tank und optimierte Komponenten. Der 428 PS Motor bietet effiziente Leistung.\n\nJedes Fahrzeug erhält ein Gewichtszertifikat mit exaktem Leergewicht. Alle wichtigen Sicherheitssysteme sind an Bord. Ideal für Anwendungen, bei denen jedes Kilogramm Nutzlast zählt.",
    "longDescription": "Der Mercedes-Benz Actros L 1843 LS Loader ist für Transportunternehmen konzipiert, bei denen jedes Kilogramm Nutzlast zählt. Durch konsequenten Leichtbau und den Verzicht auf nicht essenzielle Komponenten spart der Loader bis zu 350 Kilogramm Leergewicht – Gewicht, das direkt der Nutzlast zugutekommen.\n\nDer OM 471 Motor mit 428 PS bietet eine optimale Balance aus Leistung und Gewicht. Die Leichtbau-Maßnahmen umfassen Aluminium-Räder, einen kompakteren 600-Liter-Tank und den Entfall der Kühlerjalousie. Jedes Loader-Fahrzeug wird mit einem Gewichtszertifikat ausgeliefert.\n\nTrotz des Fokus auf Leichtbau erfüllt der Loader alle Sicherheitsstandards. Der Active Brake Assist 5 ist serienmäßig. Der clevere Weg zur maximalen Nutzlast.",
    "category": "Fernverkehr/Leichtbau",
    "series": "Actros L",
    "imageUrl": "https://images.unsplash.com/photo-1616432043562-3671ea2e5242?w=800&h=600&fit=crop",
    "highlights": [
      "Leichtbau-Optimierungen",
      "Aluminium-Räder",
      "Entfall Kühlerjalousie",
      "Kompakter Tank 600L",
      "Active Brake Assist 5",
      "Optimierte Ausstattung",
      "Gewichtszertifikat"
    ],
    "priceEur": 152000,
    "specs": {
      "motor": "OM 471 Euro VI-E",
      "leistung_ps": "428",
      "antriebsformel": "4x2",
      "gesamtgewicht_t": "40",
      "fahrerhaustyp": "BigSpace Loader",
      "tankvolumen_l": "600",
      "leergewicht_reduzierung_kg": "350"
    }
  },
  {
    "id": 25,
    "name": "Mercedes-Benz eArocs 400",
    "shortDescription": "Elektrischer Baustellen-Einsatz – emissionsfrei und leise auf urbanen Baustellen.",
    "description": "Der Mercedes-Benz eArocs 400 elektrifiziert die Baustelle. Mit 414 kWh LFP-Batteriekapazität und 400 kW Spitzenleistung meistert er urbane Baustellenlogistik emissionsfrei. Die Reichweite von 200 km deckt typische Tagestouren ab.\n\nDer elektrische Nebenantrieb versorgt Kipperaufbauten. CCS2-Schnellladen mit bis zu 400 kW ermöglicht kurze Ladezeiten. Für emissionssensible Bauprojekte ab 2026.",
    "longDescription": "Der Mercedes-Benz eArocs 400 bringt den elektrischen Antrieb auf die Baustelle. Als elektrische Variante des bewährten Arocs ist er speziell für urbane Baustelleneinsätze konzipiert, bei denen Emissionsfreiheit und geringe Lärmbelästigung gefordert sind.\n\nZwei LFP-Batteriepakete mit einer Gesamtkapazität von 414 kWh versorgen die E-Motoren mit Energie. Die Spitzenleistung von 400 kW garantiert auch bei voller Beladung zügiges Vorankommen. Die Reichweite von rund 200 Kilometern ist für urbane Baustellenlogistik mehr als ausreichend.\n\nDer elektrische Nebenantrieb versorgt Kipperaufbauten und andere Aggregate mit Energie. Der eArocs 400 macht den emissionsfreien Baustellenbetrieb zur Realität.",
    "category": "Baustellenverkehr/Elektro",
    "series": "eArocs",
    "imageUrl": "https://images.unsplash.com/photo-1630650231841-9dc7e3568bde?w=800&h=600&fit=crop",
    "highlights": [
      "Zwei LFP-Batteriepakete",
      "800V Bordspannung",
      "CCS2-Schnellladen",
      "Nebenantrieb für Aufbauten",
      "Active Brake Assist 6",
      "Active Sideguard Assist 2",
      "Niedrige Geräuschemission"
    ],
    "priceEur": 295000,
    "specs": {
      "antrieb": "Elektrisch (2 Elektromotoren)",
      "dauerleistung_kw": "300",
      "spitzenleistung_kw": "400",
      "batteriekapazitaet_kwh": "414",
      "batterietyp": "LFP",
      "reichweite_km": "200",
      "antriebsformel": "6x2",
      "gesamtgewicht_t": "27"
    }
  },
  {
    "id": 26,
    "name": "Mercedes-Benz Actros L 1858 LS Hydraulic Trailer",
    "shortDescription": "Die optimierte Sattelzugmaschine mit hydraulischem Anhängersystem für effizientes Rangieren.",
    "description": "Der Mercedes-Benz Actros L 1858 LS mit hydraulischem Anhängersystem optimiert den Sattelzugbetrieb. Mit 578 PS und hydraulischer Fernbedienung für Auflieger-Funktionen spart er Zeit bei jedem Kupplungsvorgang.\n\nTrailer Stability Control und Active Brake Assist 6 schützen das Gespann. Der Active Drive Assist 3 ermöglicht teilautomatisiertes Fahren. Die professionelle Wahl für Sattelzugprofis.",
    "longDescription": "Der Mercedes-Benz Actros L 1858 LS mit hydraulischem Anhängersystem ist für den professionellen Sattelzugbetrieb optimiert. Die integrierte Hydraulikversorgung ermöglicht die Steuerung von Auflieger-Funktionen wie Stützen, Achsen und Ladungssicherung direkt vom Fahrerhaus aus.\n\nDer OM 471 Motor mit 578 PS liegt im oberen Leistungsbereich und bietet reichlich Kraftreserven für schwere Transporte. Die hydraulische Fernbedienung ermöglicht das Absenken der Stützfüße und die Steuerung liftbarer Achsen ohne Aussteigen.\n\nDie automatische Sattelkupplungserkennung überprüft die korrekte Verriegelung des Aufliegers. Der Trailer Stability Control erkennt instabile Fahrzustände. Mit der Predictive Powertrain Control nutzt der Actros L GPS-Daten für vorausschauendes Fahren.",
    "category": "Fernverkehr/Sattelzug",
    "series": "Actros L",
    "imageUrl": "https://images.unsplash.com/photo-1591768793355-74d04bb6608f?w=800&h=600&fit=crop",
    "highlights": [
      "Hydraulisches Anhängersystem",
      "Fernbedienung für Auflieger",
      "Automatische Sattelkupplungserkennung",
      "Active Brake Assist 6",
      "Active Drive Assist 3",
      "Trailer Stability Control",
      "Predictive Powertrain Control"
    ],
    "priceEur": 198500,
    "specs": {
      "motor": "OM 471 Euro VI-E",
      "leistung_ps": "578",
      "drehmoment_nm": "2800",
      "antriebsformel": "4x2",
      "gesamtgewicht_t": "40",
      "fahrerhaustyp": "GigaSpace",
      "tankvolumen_l": "800"
    }
  },
  {
    "id": 27,
    "name": "Mercedes-Benz Atego 823 K",
    "shortDescription": "Der kompakte Kipper für den Bauhof – wendig, robust und vielseitig einsetzbar.",
    "description": "Der Mercedes-Benz Atego 823 K ist der kompakte Kipper für Bauhöfe und kleine Baufirmen. Mit 231 PS, Dreiseitenkipper und 5 m³ Volumen ist er vielseitig einsetzbar. Der enge Wendekreis meistert verwinkelte Zufahrten.\n\nDie hydraulische Bordwand und die optionale Plane erweitern die Einsatzmöglichkeiten. Active Brake Assist 5 und Rückfahrkamera sorgen für Sicherheit. Wirtschaftlich und robust.",
    "longDescription": "Der Mercedes-Benz Atego 823 K ist der ideale Partner für kommunale Bauhöfe, Garten- und Landschaftsbauer sowie kleine Bauunternehmen. Mit seinem kompakten Format und dem engen Wendekreis manövriert er auch durch enge Hofeinfahrten. Der Dreiseitenkipper-Aufbau ermöglicht das Entladen zu drei Seiten.\n\nDer OM 934 Motor mit 231 PS bietet für die typischen Einsätze reichlich Leistung. Der 5-Kubikmeter Kipperaufbau mit hydraulischer Bordwand ist auf häufiges Be- und Entladen ausgelegt. Die optionale Plane mit Spriegel schützt die Ladung.\n\nMit dem Active Brake Assist 5 verfügt auch dieses kompakte Nutzfahrzeug über modernste Sicherheitstechnik. Die Rückfahrkamera erleichtert das präzise Rangieren. Die wirtschaftliche Lösung für den täglichen Einsatz.",
    "category": "Verteilerverkehr/Kipper",
    "series": "Atego",
    "imageUrl": "https://images.unsplash.com/photo-1581092160607-ee22621dd758?w=800&h=600&fit=crop",
    "highlights": [
      "Dreiseitenkipper-Aufbau",
      "Hydraulische Bordwand",
      "Niedriger Einstieg",
      "Kompakter Wendekreis",
      "Active Brake Assist 5",
      "Rückfahrkamera",
      "Anhängerkupplung",
      "Plane und Spriegel"
    ],
    "priceEur": 72000,
    "specs": {
      "motor": "OM 934 Euro VI-E",
      "leistung_ps": "231",
      "antriebsformel": "4x2",
      "gesamtgewicht_t": "8.5",
      "fahrerhaustyp": "S-Fahrerhaus kurz",
      "kipper_volumen_m3": "5"
    }
  },
  {
    "id": 28,
    "name": "Mercedes-Benz Unimog U 218",
    "shortDescription": "Der kompakte Geräteträger – volle Unimog-Vielseitigkeit in stadtfreundlichen Abmessungen.",
    "description": "Der Mercedes-Benz Unimog U 218 bringt Unimog-Vielseitigkeit in kompakte Abmessungen. Mit 2.900 mm Radstand meistert er auch engste Altstadtgassen. Der 177 PS Motor und Kriechgänge bis 0,05 km/h ermöglichen präzises Arbeiten.\n\nDrei Anbauräume, Zapfwellen vorne/hinten und Arbeitshydraulik bieten volle Geräteträger-Funktionalität. Der wendige Unimog für kommunale Aufgaben in beengten Bereichen.",
    "longDescription": "Der Mercedes-Benz Unimog U 218 bringt die legendäre Vielseitigkeit des Unimog in ein kompaktes Format. Mit einem Radstand von nur 2.900 Millimetern passt er auch durch enge Straßen und Parkanlagen, in denen größere Geräteträger nicht mehr weiterkommen.\n\nDer OM 934 Motor mit 177 PS bietet ausreichend Leistung für alle typischen Geräteträger-Anwendungen. Das UG 80/8 Getriebe mit Kriechgängen bis 0,05 km/h ermöglicht präzises Arbeiten. Trotz seiner kompakten Abmessungen bietet der U 218 drei Anbauräume, Zapfwellen vorne und hinten und eine leistungsfähige Arbeitshydraulik.\n\nDer permanente Allradantrieb mit Differentialsperren garantiert Traktion auch auf rutschigem Untergrund. Der U 218 ist die clevere Wahl für volle Unimog-Vielseitigkeit in kompaktem Format.",
    "category": "Geräteträger/Kompakt",
    "series": "Unimog",
    "imageUrl": "https://images.unsplash.com/photo-1494976388531-d1058494cdd8?w=800&h=600&fit=crop",
    "highlights": [
      "Kompakte Abmessungen",
      "Permanenter Allradantrieb",
      "Drei Anbauräume",
      "Zapfwellen vorne/hinten",
      "Arbeitshydraulik",
      "Portalachsen",
      "Wendiger Radstand"
    ],
    "priceEur": 155000,
    "specs": {
      "motor": "OM 934 Euro VI-E",
      "leistung_ps": "177",
      "antriebsformel": "4x4 permanent",
      "getriebe": "UG 80/8 (8-Gang)",
      "gesamtgewicht_t": "10",
      "radstand_mm": "2900",
      "kriechgang": "0.05 km/h"
    }
  },
  {
    "id": 29,
    "name": "Mercedes-Benz Econic 1824 L Feuerwehr",
    "shortDescription": "Das Low-Entry-Fahrzeug für die Feuerwehr – schneller Einstieg und beste Übersicht im Einsatz.",
    "description": "Der Mercedes-Benz Econic 1824 L Feuerwehr verbindet das Low-Entry-Konzept mit Feuerwehr-Anforderungen. Der Ein- und Ausstieg in nur zwei Schritten spart kostbare Sekunden. Die Doppelkabine bietet Platz für sechs Einsatzkräfte.\n\nDas Allison Automatikgetriebe ermöglicht volle Konzentration auf die Einsatzfahrt. Die verstärkte Elektrik versorgt alle Sondersignalanlagen. Die moderne Basis für HLF, TLF und DLK.",
    "longDescription": "Der Mercedes-Benz Econic 1824 L in Feuerwehr-Ausführung verbindet das bewährte Low-Entry-Konzept mit den spezifischen Anforderungen von Rettungseinsätzen. Das ultraschnelle Ein- und Aussteigen in nur zwei Schritten kann im Ernstfall kostbare Sekunden sparen.\n\nDer OM 936 Motor mit 238 PS ist zuverlässig und wartungsarm. Das Allison Automatikgetriebe ermöglicht die volle Konzentration auf die Einsatzfahrt. Die Doppelkabine bietet Platz für bis zu sechs Einsatzkräfte in voller Schutzausrüstung. Die beidseitigen Einstiegstüren ermöglichen schnelles Verlassen des Fahrzeugs.\n\nDer Econic Feuerwehr wird in enger Abstimmung mit führenden Feuerwehr-Aufbauherstellern wie Rosenbauer, Ziegler und Magirus entwickelt. Die moderne Basis für Feuerwehrfahrzeuge der neuen Generation.",
    "category": "Feuerwehr",
    "series": "Econic",
    "imageUrl": "https://images.unsplash.com/photo-1578662996442-48f60103fc96?w=800&h=600&fit=crop",
    "highlights": [
      "Feuerwehr-Vorbereitung",
      "Sondersignal-Anlage",
      "Doppelkabine 6 Sitzplätze",
      "Low-Entry Konzept",
      "Allison Automatik",
      "Panorama-Windschutzscheibe",
      "Verstärkte Elektrik",
      "Active Sideguard Assist"
    ],
    "priceEur": 178000,
    "specs": {
      "motor": "OM 936 Euro VI-E",
      "leistung_ps": "238",
      "antriebsformel": "4x2",
      "getriebe": "Allison Automatik (6-Gang)",
      "gesamtgewicht_t": "18",
      "einstiegshoehe_mm": "380"
    }
  },
  {
    "id": 30,
    "name": "Mercedes-Benz Actros L 1851 LS LNG",
    "shortDescription": "Der Fernverkehrs-Actros mit Flüssiggas-Antrieb – reduzierte Emissionen bei hoher Reichweite.",
    "description": "Der Mercedes-Benz Actros L LNG reduziert CO2-Emissionen um bis zu 20 Prozent gegenüber Diesel. Der 302 PS Gasmotor läuft besonders ruhig und leise. Mit 600 Litern LNG-Tankvolumen erreicht er über 1.100 km Reichweite.\n\nBio-LNG ermöglicht nahezu klimaneutralen Betrieb. Das GigaSpace-Fahrerhaus bietet vollen Fernverkehrskomfort. Die Brückentechnologie für umweltbewusste Transportunternehmen.",
    "longDescription": "Der Mercedes-Benz Actros L 1851 LS LNG bietet eine überzeugende Alternative zum Diesel-Fernverkehr. Mit Flüssigerdgas (LNG) als Kraftstoff reduziert er die CO2-Emissionen um bis zu 20 Prozent gegenüber dem Diesel-Pendant. Bei Nutzung von Bio-LNG kann die CO2-Bilanz nahezu klimaneutral ausfallen.\n\nDer M 936 G Motor mit 302 PS ist speziell für den Gas-Betrieb entwickelt. Er arbeitet nach dem Otto-Prinzip und zeichnet sich durch besonders ruhigen Lauf aus. Die beiden LNG-Kryotanks mit insgesamt 600 Litern Volumen ermöglichen eine beeindruckende Reichweite von über 1.100 Kilometern.\n\nDie Betankung erfolgt über einen speziellen Niedertemperatur-Anschluss und dauert etwa 10-15 Minuten. Das GigaSpace-Fahrerhaus bietet den gewohnten Actros-Komfort. Der Actros L LNG ist die Brückentechnologie auf dem Weg zur Elektrifizierung.",
    "category": "Fernverkehr/Alternative Antriebe",
    "series": "Actros L",
    "imageUrl": "https://images.unsplash.com/photo-1532408840957-031d8034aeef?w=800&h=600&fit=crop",
    "highlights": [
      "LNG-Kryotanks",
      "Hohe Reichweite 1.100 km",
      "CO2-Reduktion bis 20%",
      "Bio-LNG kompatibel",
      "GigaSpace Fahrerhaus",
      "Active Brake Assist 5",
      "Predictive Powertrain Control",
      "Niedertemperatur-Betankung"
    ],
    "priceEur": 195000,
    "specs": {
      "motor": "M 936 G LNG Euro VI",
      "leistung_ps": "302",
      "kraftstoff": "LNG (Liquefied Natural Gas)",
      "tankvolumen_l": "600",
      "reichweite_km": "1100",
      "antriebsformel": "4x2",
      "gesamtgewicht_t": "40",
      "fahrerhaustyp": "GigaSpace"
    }
  }
]
</file>

<file path="src/main/resources/prompts/.gitkeep">
# Prompt templates and examples
</file>

<file path="src/main/resources/prompts/example-prompts.json">
{
  "examples": [
    {
      "id": "product-page-simple",
      "name": "Einfache Produktseite",
      "description": "Erstellt eine übersichtliche Produktseite mit Bild und Spezifikationen",
      "prompt": "Erstelle eine professionelle Produktseite für den eActros 600. Zeige das Hauptbild prominent, liste die wichtigsten technischen Daten übersichtlich auf und hebe die Umweltvorteile hervor.",
      "options": {
        "pageFormat": "A4",
        "style": "modern",
        "variantCount": 1,
        "includeSpecs": true
      }
    },
    {
      "id": "product-comparison",
      "name": "Produktvergleich",
      "description": "Vergleicht mehrere Produkte nebeneinander",
      "prompt": "Erstelle eine Vergleichsübersicht für die Actros-Baureihe. Zeige die Modelle nebeneinander mit ihren wichtigsten Unterschieden in Leistung, Verbrauch und Ausstattung.",
      "options": {
        "pageFormat": "A4",
        "style": "technical",
        "variantCount": 1,
        "includeSpecs": true
      }
    },
    {
      "id": "flyer-eco",
      "name": "Umwelt-Flyer",
      "description": "Kompakter Flyer mit Fokus auf Nachhaltigkeit",
      "prompt": "Gestalte einen kompakten Flyer für den eActros 600 mit Fokus auf Nachhaltigkeit und CO2-Einsparung. Verwende grüne Akzente und zeige die Umweltvorteile prominent.",
      "options": {
        "pageFormat": "DL",
        "style": "eco",
        "variantCount": 1,
        "includeSpecs": false
      }
    },
    {
      "id": "premium-brochure",
      "name": "Premium-Broschüre",
      "description": "Hochwertige Broschüre für Premiumfahrzeuge",
      "prompt": "Erstelle eine elegante Broschürenseite für den Actros L mit ProCabin. Betone den Komfort und die Premium-Ausstattung. Verwende großzügige Weißräume und hochwertige Typografie.",
      "options": {
        "pageFormat": "A4",
        "style": "premium",
        "variantCount": 2,
        "includeSpecs": true
      }
    },
    {
      "id": "technical-datasheet",
      "name": "Technisches Datenblatt",
      "description": "Detailliertes technisches Datenblatt",
      "prompt": "Erstelle ein technisches Datenblatt mit allen Spezifikationen. Strukturiere die Daten in übersichtliche Kategorien: Motor, Fahrwerk, Abmessungen, Gewichte. Verwende Tabellen für bessere Lesbarkeit.",
      "options": {
        "pageFormat": "A4",
        "style": "technical",
        "variantCount": 1,
        "includeSpecs": true,
        "complexStrategy": true
      }
    },
    {
      "id": "overview-grid",
      "name": "Produktübersicht Grid",
      "description": "Übersicht mehrerer Produkte im Grid-Layout",
      "prompt": "Erstelle eine Übersichtsseite mit allen Elektro-LKW im Grid-Layout. Zeige für jedes Fahrzeug ein Bild, den Namen und die wichtigsten Eckdaten (Reichweite, Nutzlast).",
      "options": {
        "pageFormat": "A4",
        "style": "modern",
        "variantCount": 1,
        "includeSpecs": false
      }
    },
    {
      "id": "dynamic-action",
      "name": "Dynamische Aktionsseite",
      "description": "Energiegeladene Seite für Baufahrzeuge",
      "prompt": "Gestalte eine dynamische Seite für den Arocs Kipper. Verwende kräftige Farben und diagonale Elemente. Betone Kraft und Zuverlässigkeit für den Baustelleneinsatz.",
      "options": {
        "pageFormat": "A4",
        "style": "dynamic",
        "variantCount": 2,
        "includeSpecs": true
      }
    },
    {
      "id": "postcard-promo",
      "name": "Werbe-Postkarte",
      "description": "Kompakte Werbepostkarte",
      "prompt": "Erstelle eine Werbepostkarte für den Atego. Fokussiere auf ein starkes Bild und einen prägnanten Slogan. Minimaler Text, maximale Wirkung.",
      "options": {
        "pageFormat": "A6",
        "style": "modern",
        "variantCount": 3,
        "includeSpecs": false
      }
    },
    {
      "id": "square-social",
      "name": "Social Media Format",
      "description": "Quadratisches Format für Social Media Print",
      "prompt": "Erstelle ein quadratisches Layout für den Econic. Modern und auffällig, geeignet für Social Media und Print. Zeige das Fahrzeug im urbanen Einsatz.",
      "options": {
        "pageFormat": "square",
        "style": "modern",
        "variantCount": 2,
        "includeSpecs": false
      }
    },
    {
      "id": "multi-variant-test",
      "name": "Multi-Varianten Test",
      "description": "Generiert mehrere Designvarianten zum Vergleich",
      "prompt": "Erstelle verschiedene Designvarianten für eine Produktseite des Actros. Experimentiere mit unterschiedlichen Layouts, Farbschemata und Bildplatzierungen.",
      "options": {
        "pageFormat": "A4",
        "style": "modern",
        "variantCount": 4,
        "includeSpecs": true,
        "complexStrategy": true
      }
    }
  ]
}
</file>

<file path="src/main/resources/skills/core/COLOR_THEORY.md">
---
name: COLOR_THEORY
category: core
priority: 30
dependencies: [MASTER_SKILL]
---

# Color Theory for Catalog Design

## Color Harmony Principles

### Primary Color Usage
- Use brand colors consistently throughout the layout
- Primary color for headlines, CTAs, and key elements
- Limit primary color to 10-20% of the design

### Secondary and Accent Colors
- Secondary colors for supporting elements
- Accent colors for highlights and emphasis
- Maintain 60-30-10 color ratio

### Neutral Colors
- Use neutrals for body text and backgrounds
- Light neutrals (#F5F5F5 - #FFFFFF) for backgrounds
- Dark neutrals (#1A1A1A - #333333) for text

## Color Contrast Requirements

### WCAG Compliance
- Normal text: minimum 4.5:1 contrast ratio
- Large text (18pt+): minimum 3:1 contrast ratio
- UI components: minimum 3:1 contrast ratio

### Print Considerations
- Avoid pure black (#000000) - use rich black (#1A1A1A)
- Ensure sufficient contrast for print reproduction
- Consider paper color when selecting backgrounds

## Color Application

### Product Images
- Use neutral backgrounds to highlight products
- Avoid competing colors near product images
- Consider color temperature consistency

### Technical Data
- Use subtle color coding for categories
- Maintain readability with high contrast
- Avoid color as the only differentiator
</file>

<file path="src/main/resources/skills/core/GRID_SYSTEMS.md">
---
name: GRID_SYSTEMS
category: core
priority: 25
dependencies: [MASTER_SKILL, LAYOUT_PRINCIPLES]
---

# Grid Systems for Catalog Layouts

## 12-Column Grid

### Structure
- 12 equal columns with consistent gutters
- Gutter width: 16px (screen) / 5mm (print)
- Margin: 24px (screen) / 10mm (print)

### Column Spans
- Full width: 12 columns
- Half width: 6 columns
- Third width: 4 columns
- Quarter width: 3 columns

## Modular Grid

### For Product Catalogs
- Use modular grid for product card layouts
- Consistent module size for visual rhythm
- Allow flexible content within modules

### Module Sizing
- Small module: 80x80mm
- Medium module: 120x120mm
- Large module: 160x160mm

## Baseline Grid

### Typography Alignment
- Base unit: 8px
- Line height multiples of base unit
- Vertical spacing in base unit increments

### Implementation
```css
.baseline-grid {
    line-height: 1.5; /* 24px at 16px base */
    margin-bottom: 24px;
}
```

## Print-Specific Grids

### Bleed Area
- Extend backgrounds to bleed edge
- Keep text within safe margin
- Safe margin: 5mm from trim

### Fold Considerations
- Account for fold lines in multi-page layouts
- Avoid critical content near folds
- Consider gutter width for bound documents
</file>

<file path="src/main/resources/skills/core/LAYOUT_PRINCIPLES.md">
---
priority: 10
dependencies: [MASTER_SKILL]
---

## Layout Principles

### Grid Systems
- Use a 12-column grid for flexible layouts
- Maintain consistent gutters (typically 20-24px)
- Align elements to grid lines

### Whitespace
- Use generous margins (minimum 15mm for print)
- Create breathing room around key elements
- Group related content with proximity

### Visual Flow
- Guide the eye from top-left to bottom-right
- Use size and color to create focal points
- Maintain logical reading order
</file>

<file path="src/main/resources/skills/core/MASTER_SKILL.md">
---
priority: 0
dependencies: []
---

You are an expert layout designer for professional product catalogs and marketing materials.

## Core Principles

1. **Visual Hierarchy**: Establish clear visual hierarchy using size, weight, and spacing
2. **Consistency**: Maintain consistent styling throughout the layout
3. **Readability**: Ensure all text is legible with appropriate contrast
4. **Brand Alignment**: Respect brand guidelines and color schemes
5. **Print-Ready**: Generate layouts suitable for professional printing

## Output Format

Generate valid HTML with embedded CSS. The output must be:
- Self-contained (no external dependencies)
- Print-optimized with proper page breaks
- Using CSS Grid or Flexbox for layout
- Responsive within the target format dimensions

## Quality Standards

- Use semantic HTML elements
- Include proper spacing and margins
- Ensure WCAG AA contrast compliance
- Optimize for the specified page format
</file>

<file path="src/main/resources/skills/core/SPACING.md">
---
name: SPACING
category: core
priority: 35
dependencies: [MASTER_SKILL, GRID_SYSTEMS]
---

# Spacing System for Catalog Design

## Spacing Scale

### Base Unit: 8px
- xs: 4px (0.5 units)
- sm: 8px (1 unit)
- md: 16px (2 units)
- lg: 24px (3 units)
- xl: 32px (4 units)
- 2xl: 48px (6 units)
- 3xl: 64px (8 units)

## Component Spacing

### Cards and Containers
- Internal padding: md (16px)
- Card gap: lg (24px)
- Section gap: 2xl (48px)

### Text Elements
- Paragraph spacing: md (16px)
- Heading margin-top: xl (32px)
- Heading margin-bottom: md (16px)

### Lists
- List item gap: sm (8px)
- Nested list indent: lg (24px)

## Print Spacing (mm)

### Margins
- Page margin: 10mm
- Safe area: 5mm from trim
- Bleed extension: 3-5mm

### Element Spacing
- Section gap: 8mm
- Paragraph gap: 4mm
- Line spacing: 1.4-1.6

## Whitespace Principles

### Visual Hierarchy
- More space around important elements
- Group related items with less space
- Use space to create visual breaks

### Breathing Room
- Don't crowd elements
- Allow images to breathe
- Balance density with readability

## CSS Variables
```css
:root {
    --space-xs: 4px;
    --space-sm: 8px;
    --space-md: 16px;
    --space-lg: 24px;
    --space-xl: 32px;
    --space-2xl: 48px;
    --space-3xl: 64px;
}
```
</file>

<file path="src/main/resources/skills/core/TYPOGRAPHY.md">
---
priority: 15
dependencies: [MASTER_SKILL]
---

## Typography Guidelines

### Font Selection
- Use sans-serif fonts for headings (modern, clean)
- Consider serif fonts for body text (improved readability)
- Limit to 2-3 font families maximum

### Type Scale
- Headlines: 24-48pt
- Subheadings: 18-24pt
- Body text: 10-12pt
- Captions: 8-10pt

### Line Height
- Body text: 1.4-1.6
- Headlines: 1.1-1.3
- Ensure adequate spacing for readability
</file>

<file path="src/main/resources/skills/formats/FORMAT_A4.md">
---
priority: 60
dependencies: []
---

## A4 Format Specifications

### Dimensions
- Width: 210mm
- Height: 297mm
- Aspect ratio: 1:1.414

### Safe Margins
- Top: 15mm
- Bottom: 15mm
- Left: 15mm
- Right: 15mm

### Print Bleed
- Add 3mm bleed on all sides for full-bleed printing
- Total with bleed: 216mm x 303mm

### CSS Setup
```css
@page {
  size: A4;
  margin: 15mm;
}

.page {
  width: 210mm;
  height: 297mm;
  box-sizing: border-box;
}
```
</file>

<file path="src/main/resources/skills/formats/FORMAT_A5.md">
---
name: FORMAT_A5
category: formats
priority: 60
dependencies: [MASTER_SKILL, GRID_SYSTEMS]
---

# A5 Format Guidelines (148mm × 210mm)

## Page Dimensions

### Size
- Width: 148mm
- Height: 210mm
- Aspect ratio: ~1:1.41

### Margins
- Top: 12mm
- Bottom: 15mm
- Inside: 15mm (for binding)
- Outside: 12mm

### Safe Area
- 5mm from trim edge
- Content area: 126mm × 185mm

## Grid System

### Columns
- 2-column layout recommended
- Column width: ~58mm each
- Gutter: 10mm

### Baseline
- 6mm baseline grid
- Line height: 14-16pt

## Typography Scale

### Headlines
- H1: 24-28pt
- H2: 18-22pt
- H3: 14-16pt

### Body Text
- Body: 10-11pt
- Captions: 8-9pt
- Footnotes: 7-8pt

## Use Cases

### Ideal For
- Compact product brochures
- Quick reference guides
- Pocket catalogs
- Handouts

### Content Density
- Medium density
- Focus on key information
- Concise descriptions

## CSS Example
```css
@page {
    size: A5;
    margin: 12mm 12mm 15mm 15mm;
}

.a5-layout {
    max-width: 126mm;
    font-size: 10pt;
    line-height: 1.5;
}

.a5-headline {
    font-size: 24pt;
    margin-bottom: 8mm;
}
```
</file>

<file path="src/main/resources/skills/formats/FORMAT_A6.md">
---
name: FORMAT_A6
category: formats
priority: 60
dependencies: [MASTER_SKILL, GRID_SYSTEMS]
---

# A6 Format Guidelines (105mm × 148mm)

## Page Dimensions

### Size
- Width: 105mm
- Height: 148mm
- Aspect ratio: ~1:1.41

### Margins
- All sides: 8mm
- Safe area: 5mm from trim

### Content Area
- Usable width: 89mm
- Usable height: 132mm

## Grid System

### Columns
- Single column recommended
- Full width for impact
- Optional 2-column for lists

### Baseline
- 5mm baseline grid
- Compact line spacing

## Typography Scale

### Headlines
- H1: 18-22pt
- H2: 14-16pt
- H3: 11-12pt

### Body Text
- Body: 9-10pt
- Captions: 7-8pt
- Minimum: 7pt

## Use Cases

### Ideal For
- Postcards
- Flyers
- Quick info cards
- Product tags
- Event invitations

### Content Strategy
- Minimal text
- Strong visuals
- Single message focus
- Clear CTA

## Design Tips

### Hierarchy
- One dominant element
- Limited text blocks
- Bold headlines

### Imagery
- Large product image
- Simple backgrounds
- High impact visuals

## CSS Example
```css
@page {
    size: A6;
    margin: 8mm;
}

.a6-layout {
    max-width: 89mm;
    font-size: 9pt;
    line-height: 1.4;
}

.a6-headline {
    font-size: 18pt;
    font-weight: 700;
    margin-bottom: 4mm;
}

.a6-image {
    width: 100%;
    height: auto;
    margin-bottom: 4mm;
}
```
</file>

<file path="src/main/resources/skills/formats/FORMAT_DL.md">
---
priority: 60
dependencies: []
---

## DL Format Specifications (Flyer)

### Dimensions
- Width: 99mm
- Height: 210mm
- Aspect ratio: 1:2.12

### Safe Margins
- Top: 8mm
- Bottom: 8mm
- Left: 8mm
- Right: 8mm

### Print Bleed
- Add 3mm bleed on all sides
- Total with bleed: 105mm x 216mm

### CSS Setup
```css
@page {
  size: 99mm 210mm;
  margin: 8mm;
}

.page {
  width: 99mm;
  height: 210mm;
  box-sizing: border-box;
}
```

### Design Notes
- Compact format requires concise content
- Focus on key selling points
- Large, impactful imagery
- Clear call-to-action
</file>

<file path="src/main/resources/skills/formats/FORMAT_SQUARE.md">
---
name: FORMAT_SQUARE
category: formats
priority: 60
dependencies: [MASTER_SKILL, GRID_SYSTEMS]
---

# Square Format Guidelines (210mm × 210mm)

## Page Dimensions

### Size
- Width: 210mm
- Height: 210mm
- Aspect ratio: 1:1

### Margins
- All sides: 15mm
- Safe area: 5mm from trim

### Content Area
- Usable: 180mm × 180mm

## Grid System

### Columns
- 3-column or 4-column grid
- Modular grid works well
- Symmetrical layouts

### Baseline
- 8mm baseline grid
- Balanced spacing

## Typography Scale

### Headlines
- H1: 32-40pt
- H2: 22-28pt
- H3: 16-18pt

### Body Text
- Body: 11-12pt
- Captions: 9-10pt

## Use Cases

### Ideal For
- Social media print materials
- Modern brochures
- Product showcases
- Lookbooks
- Instagram-style layouts

### Design Approach
- Centered compositions
- Symmetrical balance
- Strong visual focus

## Layout Patterns

### Centered
- Central focal point
- Radial balance
- Equal margins

### Quadrant
- 4 equal sections
- Grid-based content
- Modular approach

### Diagonal
- Dynamic tension
- Corner-to-corner flow
- Modern feel

## CSS Example
```css
@page {
    size: 210mm 210mm;
    margin: 15mm;
}

.square-layout {
    width: 180mm;
    height: 180mm;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10mm;
}

.square-centered {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
}

.square-headline {
    font-size: 36pt;
    font-weight: 700;
    margin-bottom: 10mm;
}
```
</file>

<file path="src/main/resources/skills/styles/STYLE_DYNAMIC.md">
---
name: STYLE_DYNAMIC
category: styles
priority: 50
dependencies: [MASTER_SKILL, TYPOGRAPHY, COLOR_THEORY]
---

# Dynamic Style Guide

## Visual Characteristics

### Overall Aesthetic
- Bold and energetic
- Strong visual impact
- Dynamic angles and shapes
- Action-oriented

### Color Palette
- Primary: Vibrant red (#E63946) or orange (#FF6B35)
- Secondary: Electric blue (#0077B6) or purple (#7B2CBF)
- Accent: Bright yellow (#FFD60A) or lime (#AAFF00)
- Background: Dark (#1A1A2E) or white (#FFFFFF)
- Text: High contrast

## Typography

### Font Choices
- Headlines: Bold, impactful (Montserrat Black, Oswald)
- Body: Strong, readable (Roboto, Source Sans Pro)
- Numbers: Tabular, prominent

### Sizing
- Headlines: Large, commanding (40-56pt)
- Subheads: Strong presence (20-28pt)
- Body: Clear and direct (11-12pt)

## Layout Elements

### Spacing
- Tight, energetic spacing
- Dynamic asymmetry
- Bold section breaks

### Visual Elements
- Diagonal lines and angles
- Bold geometric shapes
- High-contrast borders
- Motion-suggesting elements

### Imagery
- Action shots
- Dynamic angles
- High contrast
- Motion blur effects

## CSS Example
```css
.dynamic-layout {
    font-family: 'Montserrat', sans-serif;
    background: #1A1A2E;
    color: #FFFFFF;
}

.dynamic-headline {
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #E63946;
}

.dynamic-accent {
    background: linear-gradient(135deg, #E63946, #FF6B35);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.dynamic-card {
    border-left: 4px solid #E63946;
    transform: skewX(-2deg);
}

.dynamic-stat {
    font-size: 48px;
    font-weight: 900;
    color: #FFD60A;
}
```
</file>

<file path="src/main/resources/skills/styles/STYLE_ECO.md">
---
name: STYLE_ECO
category: styles
priority: 50
dependencies: [MASTER_SKILL, TYPOGRAPHY, COLOR_THEORY]
---

# Eco-Friendly Style Guide

## Visual Characteristics

### Overall Aesthetic
- Natural and organic
- Clean and sustainable
- Earth-inspired colors
- Minimal environmental impact messaging

### Color Palette
- Primary: Forest green (#2D5A3D) or sage (#7D9B76)
- Secondary: Earth brown (#8B7355) or sand (#D4C4A8)
- Accent: Sky blue (#5B9BD5) or leaf green (#4CAF50)
- Background: Natural white (#FFFEF7) or recycled paper (#F5F2EB)
- Text: Deep brown (#3D3D3D)

## Typography

### Font Choices
- Headlines: Organic sans-serif (Nunito, Quicksand)
- Body: Readable, friendly (Open Sans, Lato)
- Eco badges: Bold, impactful

### Sizing
- Headlines: Confident but not aggressive (28-36pt)
- Body: Easy reading (11-12pt)
- Eco stats: Highlighted (14-16pt)

## Layout Elements

### Spacing
- Balanced margins
- Organic flow
- Natural groupings

### Imagery
- Nature backgrounds
- Green technology highlights
- Sustainability icons

### Eco Elements
- Leaf motifs
- Recycling symbols
- CO2 reduction badges
- Energy efficiency ratings

## CSS Example
```css
.eco-layout {
    font-family: 'Nunito', sans-serif;
    background: #FFFEF7;
    color: #3D3D3D;
}

.eco-headline {
    color: #2D5A3D;
    font-weight: 600;
}

.eco-badge {
    background: #4CAF50;
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
}

.eco-stat {
    color: #2D5A3D;
    font-size: 24px;
    font-weight: 700;
}
```
</file>

<file path="src/main/resources/skills/styles/STYLE_MODERN.md">
---
priority: 50
dependencies: [LAYOUT_PRINCIPLES, TYPOGRAPHY]
---

## Modern Style

### Characteristics
- Clean, minimalist design
- Bold typography with strong contrast
- Generous whitespace
- Geometric shapes and sharp edges
- Monochromatic or limited color palette

### Color Approach
- Primary: Bold accent color
- Secondary: Neutral grays
- Background: White or light gray
- Text: Dark gray (#333) or black

### Layout Features
- Asymmetric layouts
- Large hero images
- Bold headlines
- Minimal decorative elements
</file>

<file path="src/main/resources/skills/styles/STYLE_PREMIUM.md">
---
name: STYLE_PREMIUM
category: styles
priority: 50
dependencies: [MASTER_SKILL, TYPOGRAPHY, COLOR_THEORY]
---

# Premium Style Guide

## Visual Characteristics

### Overall Aesthetic
- Elegant and sophisticated
- Generous whitespace
- Refined typography
- Subtle luxury cues

### Color Palette
- Primary: Deep navy (#1A2744) or charcoal (#2D2D2D)
- Accent: Gold (#C9A962) or silver (#A8A8A8)
- Background: Off-white (#FAFAFA) or cream (#F8F6F3)
- Text: Rich black (#1A1A1A)

## Typography

### Font Choices
- Headlines: Serif fonts (Playfair Display, Cormorant)
- Body: Clean sans-serif (Inter, Helvetica Neue)
- Accents: Light weight variations

### Sizing
- Headlines: Large, commanding (36-48pt)
- Subheads: Elegant spacing (18-24pt)
- Body: Comfortable reading (11-12pt)

## Layout Elements

### Spacing
- Generous margins (15-20mm)
- Ample breathing room
- Asymmetric balance

### Imagery
- High-quality product photography
- Lifestyle context shots
- Subtle shadows and reflections

### Details
- Thin elegant borders
- Subtle drop shadows
- Refined iconography

## CSS Example
```css
.premium-layout {
    font-family: 'Inter', sans-serif;
    background: #FAFAFA;
    color: #1A1A1A;
}

.premium-headline {
    font-family: 'Playfair Display', serif;
    font-weight: 400;
    letter-spacing: 0.02em;
    color: #1A2744;
}

.premium-accent {
    color: #C9A962;
    border-bottom: 1px solid #C9A962;
}
```
</file>

<file path="src/main/resources/skills/styles/STYLE_TECHNICAL.md">
---
priority: 50
dependencies: [LAYOUT_PRINCIPLES, TYPOGRAPHY]
---

## Technical Style

### Characteristics
- Data-focused presentation
- Structured tables and specifications
- Technical diagrams and schematics
- Precise measurements and units
- Professional, engineering aesthetic

### Color Approach
- Primary: Corporate blue or gray
- Accent: Orange or green for highlights
- Background: White
- Text: Dark gray for readability

### Layout Features
- Specification tables
- Technical callouts
- Dimension annotations
- Comparison charts
</file>

<file path="src/main/resources/skills/.gitkeep">
# Skill markdown files for prompt engineering
</file>

<file path="src/main/resources/templates/.gitkeep">
# HTML templates for layout generation
</file>

<file path="src/main/resources/application.yml">
server:
  port: 8080

spring:
  config:
    import: "optional:file:.env[.properties]"
  application:
    name: catalog-forge-backend
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB

catalogforge:
  data:
    products-path: classpath:data/products.json
  
  skills:
    base-path: classpath:skills/
    cache-enabled: true
  
  gemini:
    api-key: ${GEMINI_API_KEY:}
    base-url: https://generativelanguage.googleapis.com/v1beta
    model-default: gemini-3-flash-preview
    model-vision: gemini-3-flash-preview
    model-complex: gemini-3-flash-preview
    timeout-seconds: 60
    max-retries: 3
  
  puppeteer:
    node-path: node
    script-path: ./scripts/pdf-generator.js
    temp-dir: /tmp/catalogforge/pdf
    default-dpi: 300
    image-timeout-seconds: 10
  
  layout:
    variant-count-default: 2
    max-variant-count: 5
    fallback-enabled: true
  
  images:
    temp-dir: /tmp/catalogforge/images
    url-validation-timeout-ms: 5000
    expiration-hours: 24
    placeholder-enabled: true
  
  logging:
    llm:
      enabled: true
      directory: ./logs/llm
      file-pattern: "{date}_llm.jsonl"

logging:
  level:
    com.catalogforge: DEBUG
    org.springframework.web: INFO
  file:
    name: ./logs/application/catalogforge.log
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
</file>

<file path="src/test/java/com/catalogforge/agent/AgentFrameworkTest.java">
package com.catalogforge.agent;

import com.catalogforge.model.*;
import com.catalogforge.model.request.LayoutOptions;
import net.jqwik.api.*;
import net.jqwik.api.constraints.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Property-based and unit tests for Agent Framework.
 */
class AgentFrameworkTest {

    @Nested
    @DisplayName("Property 6: Pipeline Selection Logic")
    class PipelineSelectionTests {

        @Property(tries = 50)
        @Label("Simple options should select LinearPipeline")
        void simpleOptionsShouldSelectLinearPipeline(
                @ForAll("simpleStyle") String style,
                @ForAll("pageFormat") String format
        ) {
            LayoutOptions options = new LayoutOptions(format, style, 1, true, false);
            
            AgentContext context = AgentContext.forTextGeneration(
                    List.of(createTestProduct()),
                    options,
                    "Create a simple layout"
            );
            
            // Simple options = not multi-variant
            assertThat(context.isMultiVariant()).isFalse();
        }

        @Property(tries = 30)
        @Label("Multi-variant options should be detected")
        void multiVariantOptionsShouldBeDetected(
                @ForAll @IntRange(min = 2, max = 5) int variantCount
        ) {
            LayoutOptions options = new LayoutOptions("A4", "modern", variantCount, true, false);
            
            AgentContext context = AgentContext.forTextGeneration(
                    List.of(createTestProduct()),
                    options,
                    "Create multiple variants"
            );
            
            assertThat(context.isMultiVariant()).isTrue();
        }

        @Property(tries = 30)
        @Label("Image context should be detected")
        void imageContextShouldBeDetected(
                @ForAll @StringLength(min = 100, max = 500) String imageBase64
        ) {
            LayoutOptions options = new LayoutOptions("A4", "modern", 1, true, false);
            
            AgentContext context = AgentContext.forImageGeneration(
                    List.of(createTestProduct()),
                    options,
                    "Match this style",
                    imageBase64,
                    "image/jpeg"
            );
            
            assertThat(context.hasImage()).isTrue();
        }

        @Provide
        Arbitrary<String> simpleStyle() {
            return Arbitraries.of("modern", "technical", "premium", "eco", "dynamic");
        }

        @Provide
        Arbitrary<String> pageFormat() {
            return Arbitraries.of("A4", "A5", "DL", "A6", "square");
        }
    }

    @Nested
    @DisplayName("AgentContext Unit Tests")
    class AgentContextUnitTests {

        @Test
        @DisplayName("forTextGeneration should create valid context")
        void forTextGenerationShouldCreateValidContext() {
            Product product = createTestProduct();
            LayoutOptions options = new LayoutOptions("A4", "modern", 1, true, false);
            
            AgentContext context = AgentContext.forTextGeneration(
                    List.of(product),
                    options,
                    "Create a product page"
            );
            
            assertThat(context.pipelineId()).isNotBlank();
            assertThat(context.requestId()).isNotBlank();
            assertThat(context.products()).hasSize(1);
            assertThat(context.options()).isEqualTo(options);
            assertThat(context.userPrompt()).isEqualTo("Create a product page");
            assertThat(context.hasImage()).isFalse();
            assertThat(context.isValid()).isTrue();
        }

        @Test
        @DisplayName("forImageGeneration should include image data")
        void forImageGenerationShouldIncludeImageData() {
            Product product = createTestProduct();
            LayoutOptions options = new LayoutOptions("A4", "modern", 1, true, false);
            
            AgentContext context = AgentContext.forImageGeneration(
                    List.of(product),
                    options,
                    "Match this style",
                    "base64data",
                    "image/png"
            );
            
            assertThat(context.hasImage()).isTrue();
            assertThat(context.imageBase64()).isEqualTo("base64data");
            assertThat(context.imageMimeType()).isEqualTo("image/png");
        }

        @Test
        @DisplayName("withAssembledPrompt should return new context")
        void withAssembledPromptShouldReturnNewContext() {
            AgentContext original = AgentContext.forTextGeneration(
                    List.of(createTestProduct()),
                    null,
                    "Test"
            );
            
            AgentContext updated = original.withAssembledPrompt("Assembled prompt content");
            
            assertThat(updated.assembledPrompt()).isEqualTo("Assembled prompt content");
            assertThat(original.assembledPrompt()).isNull(); // Original unchanged
            assertThat(updated.pipelineId()).isEqualTo(original.pipelineId());
        }

        @Test
        @DisplayName("withValidationErrors should track errors")
        void withValidationErrorsShouldTrackErrors() {
            AgentContext context = AgentContext.forTextGeneration(
                    List.of(createTestProduct()),
                    null,
                    "Test"
            );
            
            assertThat(context.isValid()).isTrue();
            
            AgentContext withErrors = context.withValidationErrors(List.of("Error 1", "Error 2"));
            
            assertThat(withErrors.isValid()).isFalse();
            assertThat(withErrors.validationErrors()).containsExactly("Error 1", "Error 2");
        }

        @Test
        @DisplayName("withIncrementedRetry should increment counter")
        void withIncrementedRetryShouldIncrementCounter() {
            AgentContext context = AgentContext.forTextGeneration(
                    List.of(createTestProduct()),
                    null,
                    "Test"
            );
            
            assertThat(context.retryCount()).isEqualTo(0);
            
            AgentContext retry1 = context.withIncrementedRetry();
            AgentContext retry2 = retry1.withIncrementedRetry();
            
            assertThat(retry1.retryCount()).isEqualTo(1);
            assertThat(retry2.retryCount()).isEqualTo(2);
        }

        @Test
        @DisplayName("withMetadata should add metadata")
        void withMetadataShouldAddMetadata() {
            AgentContext context = AgentContext.forTextGeneration(
                    List.of(createTestProduct()),
                    null,
                    "Test"
            );
            
            AgentContext withMeta = context
                    .withMetadata("key1", "value1")
                    .withMetadata("key2", 42);
            
            assertThat(withMeta.metadata()).containsEntry("key1", "value1");
            assertThat(withMeta.metadata()).containsEntry("key2", 42);
        }

        @Test
        @DisplayName("withImageAnalysis should set analysis result")
        void withImageAnalysisShouldSetAnalysisResult() {
            AgentContext context = AgentContext.forImageGeneration(
                    List.of(createTestProduct()),
                    null,
                    "Test",
                    "base64",
                    "image/jpeg"
            );
            
            ImageAnalysisResult analysis = new ImageAnalysisResult(
                    new ColorPalette("#111", "#222", "#333", "#EEE", "#000"),
                    new MoodAnalysis("professional", 0.9, List.of("clean")),
                    new LayoutHints("modular", "medium", "center", 2)
            );
            
            AgentContext withAnalysis = context.withImageAnalysis(analysis);
            
            assertThat(withAnalysis.imageAnalysis()).isEqualTo(analysis);
            assertThat(context.imageAnalysis()).isNull(); // Original unchanged
        }
    }

    private static Product createTestProduct() {
        return new Product(
                1L,
                "Test Product",
                "Short desc",
                "Description",
                "Long description",
                "Test Category",
                "Test Series",
                new TechnicalData(Map.of("power", "500kW")),
                List.of("Highlight 1"),
                "http://example.com/image.jpg",
                99999
        );
    }
}
</file>

<file path="src/test/java/com/catalogforge/controller/ProductControllerTest.java">
package com.catalogforge.controller;

import com.catalogforge.model.Product;
import com.catalogforge.service.ProductService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.util.List;
import java.util.Set;

import static org.hamcrest.Matchers.*;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * Integration tests for ProductController.
 * Tests REST endpoints with mocked ProductService.
 */
@WebMvcTest(ProductController.class)
class ProductControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ProductService productService;

    private Product createTestProduct(Long id, String name, String category, String series) {
        return new Product(
                id,
                name,
                "Short description",
                "Medium description",
                "Long description",
                category,
                series,
                null,
                List.of("Feature 1", "Feature 2"),
                "https://example.com/image.jpg",
                100000
        );
    }

    @Nested
    @DisplayName("GET /api/v1/products")
    class GetProductsTests {

        @Test
        @DisplayName("should return all products")
        void shouldReturnAllProducts() throws Exception {
            List<Product> products = List.of(
                    createTestProduct(1L, "Actros L 1853", "Fernverkehr", "Actros L"),
                    createTestProduct(2L, "Arocs 3251", "Baustellenverkehr", "Arocs")
            );
            when(productService.getAllProducts()).thenReturn(products);

            mockMvc.perform(get("/api/v1/products"))
                    .andExpect(status().isOk())
                    .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                    .andExpect(jsonPath("$", hasSize(2)))
                    .andExpect(jsonPath("$[0].name", is("Actros L 1853")))
                    .andExpect(jsonPath("$[1].name", is("Arocs 3251")));
        }

        @Test
        @DisplayName("should filter by category")
        void shouldFilterByCategory() throws Exception {
            List<Product> filtered = List.of(
                    createTestProduct(1L, "Actros L 1853", "Fernverkehr", "Actros L")
            );
            when(productService.filterProducts("Fernverkehr", null)).thenReturn(filtered);

            mockMvc.perform(get("/api/v1/products")
                            .param("category", "Fernverkehr"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(1)))
                    .andExpect(jsonPath("$[0].category", is("Fernverkehr")));
        }

        @Test
        @DisplayName("should filter by series")
        void shouldFilterBySeries() throws Exception {
            List<Product> filtered = List.of(
                    createTestProduct(1L, "Actros L 1853", "Fernverkehr", "Actros L")
            );
            when(productService.filterProducts(null, "Actros L")).thenReturn(filtered);

            mockMvc.perform(get("/api/v1/products")
                            .param("series", "Actros L"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(1)))
                    .andExpect(jsonPath("$[0].series", is("Actros L")));
        }

        @Test
        @DisplayName("should filter by category and series")
        void shouldFilterByCategoryAndSeries() throws Exception {
            List<Product> filtered = List.of(
                    createTestProduct(1L, "Actros L 1853", "Fernverkehr", "Actros L")
            );
            when(productService.filterProducts("Fernverkehr", "Actros L")).thenReturn(filtered);

            mockMvc.perform(get("/api/v1/products")
                            .param("category", "Fernverkehr")
                            .param("series", "Actros L"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(1)));
        }
    }

    @Nested
    @DisplayName("GET /api/v1/products/{id}")
    class GetProductByIdTests {

        @Test
        @DisplayName("should return product by ID")
        void shouldReturnProductById() throws Exception {
            Product product = createTestProduct(1L, "Actros L 1853", "Fernverkehr", "Actros L");
            when(productService.getProductById(1L)).thenReturn(product);

            mockMvc.perform(get("/api/v1/products/1"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.id", is(1)))
                    .andExpect(jsonPath("$.name", is("Actros L 1853")))
                    .andExpect(jsonPath("$.category", is("Fernverkehr")))
                    .andExpect(jsonPath("$.series", is("Actros L")));
        }
    }

    @Nested
    @DisplayName("GET /api/v1/products/categories")
    class GetCategoriesTests {

        @Test
        @DisplayName("should return all categories sorted")
        void shouldReturnAllCategories() throws Exception {
            Set<String> categories = Set.of("Baustellenverkehr", "Fernverkehr", "Verteilerverkehr");
            when(productService.getAllCategories()).thenReturn(categories);

            mockMvc.perform(get("/api/v1/products/categories"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(3)))
                    .andExpect(jsonPath("$", containsInAnyOrder("Baustellenverkehr", "Fernverkehr", "Verteilerverkehr")));
        }
    }

    @Nested
    @DisplayName("GET /api/v1/products/series")
    class GetSeriesTests {

        @Test
        @DisplayName("should return all series sorted")
        void shouldReturnAllSeries() throws Exception {
            Set<String> series = Set.of("Actros L", "Arocs", "Atego");
            when(productService.getAllSeries()).thenReturn(series);

            mockMvc.perform(get("/api/v1/products/series"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(3)))
                    .andExpect(jsonPath("$", containsInAnyOrder("Actros L", "Arocs", "Atego")));
        }
    }

    @Nested
    @DisplayName("GET /api/v1/products/search")
    class SearchProductsTests {

        @Test
        @DisplayName("should search products by query")
        void shouldSearchProducts() throws Exception {
            List<Product> results = List.of(
                    createTestProduct(1L, "Actros L 1853", "Fernverkehr", "Actros L"),
                    createTestProduct(2L, "Actros L 1848", "Fernverkehr", "Actros L")
            );
            when(productService.searchProducts("Actros")).thenReturn(results);

            mockMvc.perform(get("/api/v1/products/search")
                            .param("q", "Actros"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(2)))
                    .andExpect(jsonPath("$[0].name", containsString("Actros")));
        }

        @Test
        @DisplayName("should return empty list for no matches")
        void shouldReturnEmptyForNoMatches() throws Exception {
            when(productService.searchProducts("nonexistent")).thenReturn(List.of());

            mockMvc.perform(get("/api/v1/products/search")
                            .param("q", "nonexistent"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(0)));
        }
    }
}
</file>

<file path="src/test/java/com/catalogforge/controller/SkillsControllerTest.java">
package com.catalogforge.controller;

import com.catalogforge.model.Skill;
import com.catalogforge.service.SkillsService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.util.List;
import java.util.Set;

import static org.hamcrest.Matchers.*;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * Integration tests for SkillsController.
 */
@WebMvcTest(SkillsController.class)
class SkillsControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private SkillsService skillsService;

    @Nested
    @DisplayName("GET /api/v1/skills")
    class GetAllSkillsTests {

        @Test
        @DisplayName("should return all skills")
        void shouldReturnAllSkills() throws Exception {
            List<Skill> skills = List.of(
                    new Skill("MASTER_SKILL", "core", "content", List.of(), 0),
                    new Skill("TYPOGRAPHY", "core", "content", List.of("MASTER_SKILL"), 15)
            );
            when(skillsService.getAllSkills()).thenReturn(skills);

            mockMvc.perform(get("/api/v1/skills"))
                    .andExpect(status().isOk())
                    .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                    .andExpect(jsonPath("$", hasSize(2)))
                    .andExpect(jsonPath("$[0].name", is("MASTER_SKILL")))
                    .andExpect(jsonPath("$[1].name", is("TYPOGRAPHY")));
        }
    }

    @Nested
    @DisplayName("GET /api/v1/skills/categories")
    class GetCategoriesTests {

        @Test
        @DisplayName("should return all categories")
        void shouldReturnAllCategories() throws Exception {
            Set<String> categories = Set.of("core", "styles", "formats");
            when(skillsService.getAllCategories()).thenReturn(categories);

            mockMvc.perform(get("/api/v1/skills/categories"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(3)))
                    .andExpect(jsonPath("$", containsInAnyOrder("core", "styles", "formats")));
        }
    }

    @Nested
    @DisplayName("GET /api/v1/skills/{category}")
    class GetSkillsByCategoryTests {

        @Test
        @DisplayName("should return skills by category")
        void shouldReturnSkillsByCategory() throws Exception {
            List<Skill> coreSkills = List.of(
                    new Skill("MASTER_SKILL", "core", "content", List.of(), 0),
                    new Skill("LAYOUT_PRINCIPLES", "core", "content", List.of("MASTER_SKILL"), 10)
            );
            when(skillsService.getSkillsByCategory("core")).thenReturn(coreSkills);

            mockMvc.perform(get("/api/v1/skills/core"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(2)))
                    .andExpect(jsonPath("$[0].category", is("core")));
        }
    }

    @Nested
    @DisplayName("GET /api/v1/skills/prompts/examples")
    class GetExamplePromptsTests {

        @Test
        @DisplayName("should return example prompts")
        void shouldReturnExamplePrompts() throws Exception {
            mockMvc.perform(get("/api/v1/skills/prompts/examples"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$", hasSize(3)))
                    .andExpect(jsonPath("$[0].id", is("product-page-modern")))
                    .andExpect(jsonPath("$[0].title", notNullValue()))
                    .andExpect(jsonPath("$[0].prompt", notNullValue()))
                    .andExpect(jsonPath("$[0].skills", isA(List.class)))
                    .andExpect(jsonPath("$[0].style", notNullValue()))
                    .andExpect(jsonPath("$[0].format", notNullValue()));
        }
    }

    @Nested
    @DisplayName("POST /api/v1/skills/reload")
    class ReloadSkillsTests {

        @Test
        @DisplayName("should reload skills")
        void shouldReloadSkills() throws Exception {
            mockMvc.perform(post("/api/v1/skills/reload"))
                    .andExpect(status().isOk());

            verify(skillsService).reloadSkills();
        }
    }
}
</file>

<file path="src/test/java/com/catalogforge/exception/ErrorResponsePropertyTest.java">
package com.catalogforge.exception;

import static org.assertj.core.api.Assertions.assertThat;

import java.time.Instant;

import org.junit.jupiter.api.Tag;

import com.catalogforge.model.response.ErrorResponse;

import net.jqwik.api.ForAll;
import net.jqwik.api.Label;
import net.jqwik.api.Property;
import net.jqwik.api.constraints.IntRange;
import net.jqwik.api.constraints.NotBlank;

/**
 * Property-based tests for ErrorResponse structure.
 * 
 * Property 19: Error Response Structure
 * For any error response, the body must contain: timestamp, status, error, message, and path fields.
 * 
 * Validates: Requirements 14.6
 */
@Tag("property")
@Tag("unit")
class ErrorResponsePropertyTest {

    @Property(tries = 100)
    @Label("Property 19: Error Response Structure - all fields present")
    void errorResponseContainsAllRequiredFields(
            @ForAll @IntRange(min = 400, max = 599) int status,
            @ForAll @NotBlank String error,
            @ForAll @NotBlank String message,
            @ForAll @NotBlank String path) {
        
        // When creating an error response
        ErrorResponse response = ErrorResponse.of(status, error, message, path);
        
        // Then all required fields are present and correct
        assertThat(response.timestamp()).isNotNull();
        assertThat(response.timestamp()).isBeforeOrEqualTo(Instant.now());
        assertThat(response.status()).isEqualTo(status);
        assertThat(response.error()).isEqualTo(error);
        assertThat(response.message()).isEqualTo(message);
        assertThat(response.path()).isEqualTo(path);
    }

    @Property(tries = 100)
    @Label("Property 19: Error Response Structure - timestamp is recent")
    void errorResponseTimestampIsRecent(
            @ForAll @IntRange(min = 400, max = 599) int status) {
        
        Instant before = Instant.now();
        ErrorResponse response = ErrorResponse.of(status, "Error", "Message", "/api/test");
        Instant after = Instant.now();
        
        // Timestamp should be between before and after
        assertThat(response.timestamp())
            .isAfterOrEqualTo(before)
            .isBeforeOrEqualTo(after);
    }

    @Property(tries = 50)
    @Label("Property 19: Error Response Structure - HTTP status codes valid")
    void errorResponseStatusCodesAreValid(
            @ForAll @IntRange(min = 400, max = 599) int status) {
        
        ErrorResponse response = ErrorResponse.of(status, "Error", "Message", "/api/test");
        
        // Status should be a valid HTTP error code (4xx or 5xx)
        assertThat(response.status()).isBetween(400, 599);
    }
}
</file>

<file path="src/test/java/com/catalogforge/gemini/GeminiModelSelectorTest.java">
package com.catalogforge.gemini;

import net.jqwik.api.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for GeminiModelSelector including property-based tests.
 * 
 * Property Tests validate:
 * - Property 12: Gemini Model Selection (Requirements 8.2, 8.3, 8.4)
 */
class GeminiModelSelectorTest {

    @Nested
    @DisplayName("Property 12: Gemini Model Selection")
    class GeminiModelSelectionTests {

        @Test
        @DisplayName("Simple layout should use flash model")
        void simpleLayoutShouldUseFlashModel() {
            String model = GeminiModelSelector.selectModel(false, false);
            assertThat(model).isEqualTo(GeminiModelSelector.MODEL_FLASH);
        }

        @Test
        @DisplayName("Complex layout should use pro model")
        void complexLayoutShouldUseProModel() {
            String model = GeminiModelSelector.selectModel(true, false);
            assertThat(model).isEqualTo(GeminiModelSelector.MODEL_PRO);
        }

        @Test
        @DisplayName("Image analysis should use vision model")
        void imageAnalysisShouldUseVisionModel() {
            String model = GeminiModelSelector.selectModel(false, true);
            assertThat(model).isEqualTo(GeminiModelSelector.MODEL_VISION);
        }

        @Test
        @DisplayName("Image with complex layout should prioritize vision model")
        void imageWithComplexLayoutShouldPrioritizeVision() {
            String model = GeminiModelSelector.selectModel(true, true);
            assertThat(model).isEqualTo(GeminiModelSelector.MODEL_VISION);
        }

        @Property
        @Label("Model selection should always return a valid model")
        void modelSelectionShouldAlwaysReturnValidModel(
                @ForAll boolean isComplex,
                @ForAll boolean hasImage) {
            
            String model = GeminiModelSelector.selectModel(isComplex, hasImage);
            
            assertThat(model).isNotNull();
            assertThat(model).isNotBlank();
            assertThat(model).isIn(
                    GeminiModelSelector.MODEL_FLASH,
                    GeminiModelSelector.MODEL_PRO,
                    GeminiModelSelector.MODEL_VISION
            );
        }

        @Property
        @Label("Image requests should always use vision-capable model")
        void imageRequestsShouldUseVisionModel(@ForAll boolean isComplex) {
            String model = GeminiModelSelector.selectModel(isComplex, true);
            assertThat(model).isEqualTo(GeminiModelSelector.MODEL_VISION);
        }
    }

    @Nested
    @DisplayName("Convenience Methods")
    class ConvenienceMethodsTests {

        @Test
        @DisplayName("forSimpleLayout should return flash model")
        void forSimpleLayoutShouldReturnFlash() {
            assertThat(GeminiModelSelector.forSimpleLayout())
                    .isEqualTo(GeminiModelSelector.MODEL_FLASH);
        }

        @Test
        @DisplayName("forComplexLayout should return pro model")
        void forComplexLayoutShouldReturnPro() {
            assertThat(GeminiModelSelector.forComplexLayout())
                    .isEqualTo(GeminiModelSelector.MODEL_PRO);
        }

        @Test
        @DisplayName("forImageAnalysis should return vision model")
        void forImageAnalysisShouldReturnVision() {
            assertThat(GeminiModelSelector.forImageAnalysis())
                    .isEqualTo(GeminiModelSelector.MODEL_VISION);
        }
    }
}
</file>

<file path="src/test/java/com/catalogforge/gemini/GeminiRequestTest.java">
package com.catalogforge.gemini;

import net.jqwik.api.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for GeminiRequest including property-based tests.
 * 
 * Property Tests validate:
 * - Property 11: Gemini Request Structure (Requirements 8.1, 8.5)
 */
class GeminiRequestTest {

    @Nested
    @DisplayName("Property 11: Gemini Request Structure")
    class GeminiRequestStructureTests {

        @Test
        @DisplayName("Builder should create valid request with user prompt")
        void builderShouldCreateValidRequest() {
            GeminiRequest request = GeminiRequest.builder()
                    .userPrompt("Generate a product layout")
                    .build();

            assertThat(request.contents()).hasSize(1);
            assertThat(request.contents().get(0).role()).isEqualTo("user");
            assertThat(request.contents().get(0).parts()).hasSize(1);
            assertThat(request.contents().get(0).parts().get(0).text())
                    .isEqualTo("Generate a product layout");
        }

        @Test
        @DisplayName("Builder should include system instruction when provided")
        void builderShouldIncludeSystemInstruction() {
            GeminiRequest request = GeminiRequest.builder()
                    .userPrompt("Generate layout")
                    .systemInstruction("You are a layout designer")
                    .build();

            assertThat(request.systemInstruction()).isNotNull();
            assertThat(request.systemInstruction().parts()).hasSize(1);
            assertThat(request.systemInstruction().parts().get(0).text())
                    .isEqualTo("You are a layout designer");
        }

        @Test
        @DisplayName("Builder should include generation config")
        void builderShouldIncludeGenerationConfig() {
            GeminiRequest request = GeminiRequest.builder()
                    .userPrompt("Generate layout")
                    .temperature(0.5)
                    .maxOutputTokens(4096)
                    .responseMimeType("application/json")
                    .build();

            assertThat(request.generationConfig()).isNotNull();
            assertThat(request.generationConfig().temperature()).isEqualTo(0.5);
            assertThat(request.generationConfig().maxOutputTokens()).isEqualTo(4096);
            assertThat(request.generationConfig().responseMimeType()).isEqualTo("application/json");
        }

        @Test
        @DisplayName("Builder should include response schema when provided")
        void builderShouldIncludeResponseSchema() {
            Map<String, Object> schema = Map.of(
                    "type", "object",
                    "properties", Map.of("html", Map.of("type", "string"))
            );

            GeminiRequest request = GeminiRequest.builder()
                    .userPrompt("Generate layout")
                    .responseSchema(schema)
                    .build();

            assertThat(request.generationConfig().responseSchema()).isEqualTo(schema);
        }

        @Test
        @DisplayName("Builder should include image data when provided")
        void builderShouldIncludeImageData() {
            GeminiRequest request = GeminiRequest.builder()
                    .userPrompt("Analyze this image")
                    .image("base64data", "image/jpeg")
                    .build();

            assertThat(request.contents().get(0).parts()).hasSize(2);
            
            // First part should be image
            GeminiRequest.Part imagePart = request.contents().get(0).parts().get(0);
            assertThat(imagePart.inlineData()).isNotNull();
            assertThat(imagePart.inlineData().mimeType()).isEqualTo("image/jpeg");
            assertThat(imagePart.inlineData().data()).isEqualTo("base64data");
            
            // Second part should be text
            GeminiRequest.Part textPart = request.contents().get(0).parts().get(1);
            assertThat(textPart.text()).isEqualTo("Analyze this image");
        }

        @Property
        @Label("Request should always have contents")
        void requestShouldAlwaysHaveContents(
                @ForAll("userPrompts") String prompt) {
            
            GeminiRequest request = GeminiRequest.builder()
                    .userPrompt(prompt)
                    .build();

            assertThat(request.contents()).isNotNull();
            assertThat(request.contents()).isNotEmpty();
        }

        @Provide
        Arbitrary<String> userPrompts() {
            return Arbitraries.strings()
                    .withCharRange('a', 'z')
                    .ofMinLength(1)
                    .ofMaxLength(100);
        }
    }

    @Nested
    @DisplayName("Part Factory Methods")
    class PartFactoryMethodsTests {

        @Test
        @DisplayName("Part.text should create text part")
        void partTextShouldCreateTextPart() {
            GeminiRequest.Part part = GeminiRequest.Part.text("Hello");
            
            assertThat(part.text()).isEqualTo("Hello");
            assertThat(part.inlineData()).isNull();
        }

        @Test
        @DisplayName("Part.image should create image part")
        void partImageShouldCreateImagePart() {
            GeminiRequest.Part part = GeminiRequest.Part.image("image/png", "base64data");
            
            assertThat(part.text()).isNull();
            assertThat(part.inlineData()).isNotNull();
            assertThat(part.inlineData().mimeType()).isEqualTo("image/png");
            assertThat(part.inlineData().data()).isEqualTo("base64data");
        }
    }
}
</file>

<file path="src/test/java/com/catalogforge/gemini/GeminiVisionAnalyzerTest.java">
package com.catalogforge.gemini;

import com.catalogforge.model.ColorPalette;
import com.catalogforge.model.ImageAnalysisResult;
import com.catalogforge.model.LayoutHints;
import com.catalogforge.model.MoodAnalysis;
import net.jqwik.api.*;
import net.jqwik.api.constraints.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Property-based tests for GeminiVisionAnalyzer and Image Analysis models.
 */
class GeminiVisionAnalyzerTest {

    @Nested
    @DisplayName("Property 9: Image Analysis Extraction")
    class ImageAnalysisExtractionTests {

        @Property(tries = 50)
        @Label("ColorPalette should contain valid hex colors")
        void colorPaletteShouldContainValidHexColors(
                @ForAll("validHexColor") String primary,
                @ForAll("validHexColor") String secondary,
                @ForAll("validHexColor") String accent,
                @ForAll("validHexColor") String neutralLight,
                @ForAll("validHexColor") String neutralDark
        ) {
            ColorPalette palette = new ColorPalette(primary, secondary, accent, neutralLight, neutralDark);
            
            assertThat(palette.primary()).matches("^#[0-9A-Fa-f]{6}$");
            assertThat(palette.secondary()).matches("^#[0-9A-Fa-f]{6}$");
            assertThat(palette.accent()).matches("^#[0-9A-Fa-f]{6}$");
            assertThat(palette.neutralLight()).matches("^#[0-9A-Fa-f]{6}$");
            assertThat(palette.neutralDark()).matches("^#[0-9A-Fa-f]{6}$");
        }

        @Property(tries = 50)
        @Label("MoodAnalysis confidence should be between 0 and 1")
        void moodAnalysisConfidenceShouldBeValid(
                @ForAll("moodType") String type,
                @ForAll @DoubleRange(min = 0.0, max = 1.0) double confidence,
                @ForAll("moodKeywords") List<String> keywords
        ) {
            MoodAnalysis mood = new MoodAnalysis(type, confidence, keywords);
            
            assertThat(mood.type()).isNotBlank();
            assertThat(mood.confidence()).isBetween(0.0, 1.0);
            assertThat(mood.keywords()).isNotNull();
        }

        @Property(tries = 50)
        @Label("LayoutHints suggestedColumns should be positive")
        void layoutHintsSuggestedColumnsShouldBePositive(
                @ForAll("gridType") String gridType,
                @ForAll("density") String density,
                @ForAll("focusArea") String focusArea,
                @ForAll @IntRange(min = 1, max = 12) int suggestedColumns
        ) {
            LayoutHints hints = new LayoutHints(gridType, density, focusArea, suggestedColumns);
            
            assertThat(hints.gridType()).isNotBlank();
            assertThat(hints.density()).isNotBlank();
            assertThat(hints.focusArea()).isNotBlank();
            assertThat(hints.suggestedColumns()).isBetween(1, 12);
        }

        @Property(tries = 30)
        @Label("ImageAnalysisResult should contain all components")
        void imageAnalysisResultShouldContainAllComponents(
                @ForAll("validHexColor") String primary,
                @ForAll("moodType") String moodType,
                @ForAll @DoubleRange(min = 0.0, max = 1.0) double confidence,
                @ForAll("gridType") String gridType,
                @ForAll @IntRange(min = 1, max = 6) int columns
        ) {
            ColorPalette palette = new ColorPalette(primary, "#666666", "#0066CC", "#F5F5F5", "#1A1A1A");
            MoodAnalysis mood = new MoodAnalysis(moodType, confidence, List.of("clean"));
            LayoutHints hints = new LayoutHints(gridType, "medium", "center", columns);
            
            ImageAnalysisResult result = new ImageAnalysisResult(palette, mood, hints);
            
            assertThat(result.colorPalette()).isNotNull();
            assertThat(result.mood()).isNotNull();
            assertThat(result.layoutHints()).isNotNull();
            assertThat(result.colorPalette().primary()).isEqualTo(primary);
            assertThat(result.mood().type()).isEqualTo(moodType);
            assertThat(result.layoutHints().suggestedColumns()).isEqualTo(columns);
        }

        @Property(tries = 30)
        @Label("MoodAnalysis keywords should be immutable")
        void moodAnalysisKeywordsShouldBeImmutable(
                @ForAll("moodKeywords") List<String> keywords
        ) {
            MoodAnalysis mood = new MoodAnalysis("professional", 0.8, keywords);
            
            // Keywords should be a defensive copy
            assertThat(mood.keywords()).isNotNull();
            assertThat(mood.keywords()).containsExactlyElementsOf(
                    keywords != null ? keywords : List.of()
            );
        }

        @Provide
        Arbitrary<String> validHexColor() {
            return Arbitraries.strings()
                    .withCharRange('0', '9')
                    .withCharRange('A', 'F')
                    .ofLength(6)
                    .map(s -> "#" + s);
        }

        @Provide
        Arbitrary<String> moodType() {
            return Arbitraries.of(
                    "professional", "dynamic", "elegant", "technical", 
                    "eco-friendly", "premium", "modern", "classic"
            );
        }

        @Provide
        Arbitrary<List<String>> moodKeywords() {
            return Arbitraries.of(
                    "clean", "modern", "sleek", "powerful", "efficient",
                    "innovative", "sustainable", "robust", "elegant"
            ).list().ofMinSize(0).ofMaxSize(5);
        }

        @Provide
        Arbitrary<String> gridType() {
            return Arbitraries.of("modular", "columnar", "hierarchical", "free-form", "grid");
        }

        @Provide
        Arbitrary<String> density() {
            return Arbitraries.of("low", "medium", "high");
        }

        @Provide
        Arbitrary<String> focusArea() {
            return Arbitraries.of("center", "top", "bottom", "left", "right", "top-left", "top-right");
        }
    }

    @Nested
    @DisplayName("Unit Tests for Image Analysis Models")
    class ImageAnalysisModelTests {

        @Test
        @DisplayName("ColorPalette should store all five colors")
        void colorPaletteShouldStoreAllFiveColors() {
            ColorPalette palette = new ColorPalette("#111111", "#222222", "#333333", "#EEEEEE", "#000000");
            
            assertThat(palette.primary()).isEqualTo("#111111");
            assertThat(palette.secondary()).isEqualTo("#222222");
            assertThat(palette.accent()).isEqualTo("#333333");
            assertThat(palette.neutralLight()).isEqualTo("#EEEEEE");
            assertThat(palette.neutralDark()).isEqualTo("#000000");
        }

        @Test
        @DisplayName("MoodAnalysis should handle null keywords")
        void moodAnalysisShouldHandleNullKeywords() {
            MoodAnalysis mood = new MoodAnalysis("professional", 0.9, null);
            
            assertThat(mood.keywords()).isNotNull();
            assertThat(mood.keywords()).isEmpty();
        }

        @Test
        @DisplayName("LayoutHints should store grid configuration")
        void layoutHintsShouldStoreGridConfiguration() {
            LayoutHints hints = new LayoutHints("modular", "high", "center", 3);
            
            assertThat(hints.gridType()).isEqualTo("modular");
            assertThat(hints.density()).isEqualTo("high");
            assertThat(hints.focusArea()).isEqualTo("center");
            assertThat(hints.suggestedColumns()).isEqualTo(3);
        }

        @Test
        @DisplayName("ImageAnalysisResult should compose all analysis components")
        void imageAnalysisResultShouldComposeAllComponents() {
            ColorPalette palette = new ColorPalette("#333333", "#666666", "#0066CC", "#F5F5F5", "#1A1A1A");
            MoodAnalysis mood = new MoodAnalysis("dynamic", 0.85, List.of("powerful", "modern"));
            LayoutHints hints = new LayoutHints("columnar", "medium", "top", 2);
            
            ImageAnalysisResult result = new ImageAnalysisResult(palette, mood, hints);
            
            assertThat(result.colorPalette()).isEqualTo(palette);
            assertThat(result.mood()).isEqualTo(mood);
            assertThat(result.layoutHints()).isEqualTo(hints);
        }
    }
}
</file>

<file path="src/test/java/com/catalogforge/logging/LlmLoggingTest.java">
package com.catalogforge.logging;

import com.catalogforge.util.JsonUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import net.jqwik.api.*;
import net.jqwik.api.constraints.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Property-based and unit tests for LLM logging system.
 */
class LlmLoggingTest {

    @Nested
    @DisplayName("Property 14: LLM Log Correlation")
    class LlmLogCorrelationTests {

        @Property(tries = 50)
        @Label("Request and response should share the same requestId")
        void requestAndResponseShouldShareRequestId(
                @ForAll("validRequestId") String requestId,
                @ForAll("modelName") String model
        ) {
            LlmLogEntry request = LlmLogEntry.request(requestId, model, "/v1/generate", "Test prompt");
            LlmLogEntry response = LlmLogEntry.successResponse(requestId, model, 100, 50, 1000, "Response");
            
            assertThat(request.requestId()).isEqualTo(response.requestId());
            assertThat(request.direction()).isEqualTo(LlmLogEntry.Direction.REQUEST);
            assertThat(response.direction()).isEqualTo(LlmLogEntry.Direction.RESPONSE);
        }

        @Property(tries = 50)
        @Label("Error responses should preserve requestId")
        void errorResponsesShouldPreserveRequestId(
                @ForAll("validRequestId") String requestId,
                @ForAll("modelName") String model,
                @ForAll @StringLength(min = 1, max = 200) String errorMessage
        ) {
            LlmLogEntry request = LlmLogEntry.request(requestId, model, "/v1/generate", "Test");
            LlmLogEntry error = LlmLogEntry.errorResponse(requestId, model, 500, errorMessage);
            
            assertThat(request.requestId()).isEqualTo(error.requestId());
            assertThat(error.status()).isEqualTo(LlmLogEntry.Status.ERROR);
            assertThat(error.errorMessage()).isEqualTo(errorMessage);
        }

        @Property(tries = 30)
        @Label("Timeout responses should have TIMEOUT status")
        void timeoutResponsesShouldHaveTimeoutStatus(
                @ForAll("validRequestId") String requestId,
                @ForAll("modelName") String model,
                @ForAll @LongRange(min = 1000, max = 120000) long durationMs
        ) {
            LlmLogEntry timeout = LlmLogEntry.timeoutResponse(requestId, model, durationMs);
            
            assertThat(timeout.status()).isEqualTo(LlmLogEntry.Status.TIMEOUT);
            assertThat(timeout.durationMs()).isEqualTo(durationMs);
            assertThat(timeout.errorMessage()).contains("timeout");
        }

        @Provide
        Arbitrary<String> validRequestId() {
            return Arbitraries.create(() -> UUID.randomUUID().toString());
        }

        @Provide
        Arbitrary<String> modelName() {
            return Arbitraries.of(
                    "gemini-2.0-flash", "gemini-2.5-flash", 
                    "gemini-2.5-pro", "gemini-2.5-pro-vision"
            );
        }
    }

    @Nested
    @DisplayName("Property 15: Log File Format")
    class LogFileFormatTests {

        @TempDir
        Path tempDir;

        @Property(tries = 20)
        @Label("Log entries should serialize to valid JSON lines")
        void logEntriesShouldSerializeToValidJsonLines(
                @ForAll("validRequestId") String requestId,
                @ForAll("modelName") String model,
                @ForAll @IntRange(min = 1, max = 10000) int inputTokens,
                @ForAll @IntRange(min = 1, max = 5000) int outputTokens
        ) {
            LlmLogEntry entry = LlmLogEntry.successResponse(
                    requestId, model, inputTokens, outputTokens, 1000, "Test response"
            );
            
            String json = JsonUtils.toJson(entry);
            
            // Should be valid JSON
            assertThat(json).isNotBlank();
            assertThat(json).doesNotContain("\n"); // Single line
            
            // Should be parseable back
            Map<String, Object> parsed = JsonUtils.fromJson(json, new TypeReference<>() {});
            assertThat(parsed).containsKey("requestId");
            assertThat(parsed.get("requestId")).isEqualTo(requestId);
        }

        @Test
        @DisplayName("LlmLogWriter should create daily log files")
        void llmLogWriterShouldCreateDailyLogFiles() throws IOException {
            LlmLogWriter writer = new LlmLogWriter(tempDir.toString());
            
            String requestId = UUID.randomUUID().toString();
            LlmLogEntry entry = LlmLogEntry.request(requestId, "gemini-2.0-flash", "/v1/generate", "Test");
            
            writer.write(entry);
            writer.shutdown();
            
            // Check file was created with correct name
            String expectedFileName = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd")) + "_llm.jsonl";
            Path logFile = tempDir.resolve(expectedFileName);
            
            assertThat(Files.exists(logFile)).isTrue();
            
            // Check content is valid JSONL
            List<String> lines = Files.readAllLines(logFile);
            assertThat(lines).hasSize(1);
            
            Map<String, Object> parsed = JsonUtils.fromJson(lines.get(0), new TypeReference<>() {});
            assertThat(parsed.get("requestId")).isEqualTo(requestId);
        }

        @Test
        @DisplayName("Multiple entries should append to same file")
        void multipleEntriesShouldAppendToSameFile() throws IOException {
            LlmLogWriter writer = new LlmLogWriter(tempDir.toString());
            
            // Write multiple entries
            for (int i = 0; i < 5; i++) {
                String requestId = UUID.randomUUID().toString();
                LlmLogEntry entry = LlmLogEntry.request(requestId, "gemini-2.0-flash", "/v1/generate", "Test " + i);
                writer.write(entry);
            }
            writer.shutdown();
            
            // Check all entries are in the file
            Path logFile = writer.getCurrentLogFile();
            List<String> lines = Files.readAllLines(logFile);
            
            assertThat(lines).hasSize(5);
            
            // Each line should be valid JSON
            for (String line : lines) {
                Map<String, Object> parsed = JsonUtils.fromJson(line, new TypeReference<>() {});
                assertThat(parsed).containsKey("requestId");
                assertThat(parsed).containsKey("timestamp");
                assertThat(parsed).containsKey("direction");
            }
        }

        @Provide
        Arbitrary<String> validRequestId() {
            return Arbitraries.create(() -> UUID.randomUUID().toString());
        }

        @Provide
        Arbitrary<String> modelName() {
            return Arbitraries.of("gemini-2.0-flash", "gemini-2.5-flash", "gemini-2.5-pro");
        }
    }

    @Nested
    @DisplayName("LlmLogEntry Unit Tests")
    class LlmLogEntryUnitTests {

        @Test
        @DisplayName("Request entry should have correct direction")
        void requestEntryShouldHaveCorrectDirection() {
            LlmLogEntry entry = LlmLogEntry.request("req-1", "gemini-2.0-flash", "/v1/generate", "Hello");
            
            assertThat(entry.direction()).isEqualTo(LlmLogEntry.Direction.REQUEST);
            assertThat(entry.status()).isNull();
            assertThat(entry.promptSummary()).isEqualTo("Hello");
        }

        @Test
        @DisplayName("Success response should have token counts")
        void successResponseShouldHaveTokenCounts() {
            LlmLogEntry entry = LlmLogEntry.successResponse("req-1", "gemini-2.0-flash", 100, 50, 1500, "Response text");
            
            assertThat(entry.direction()).isEqualTo(LlmLogEntry.Direction.RESPONSE);
            assertThat(entry.status()).isEqualTo(LlmLogEntry.Status.SUCCESS);
            assertThat(entry.inputTokens()).isEqualTo(100);
            assertThat(entry.outputTokens()).isEqualTo(50);
            assertThat(entry.durationMs()).isEqualTo(1500);
        }

        @Test
        @DisplayName("Error response should have error message")
        void errorResponseShouldHaveErrorMessage() {
            LlmLogEntry entry = LlmLogEntry.errorResponse("req-1", "gemini-2.0-flash", 500, "API rate limit exceeded");
            
            assertThat(entry.status()).isEqualTo(LlmLogEntry.Status.ERROR);
            assertThat(entry.errorMessage()).isEqualTo("API rate limit exceeded");
        }

        @Test
        @DisplayName("Timestamp should be set automatically")
        void timestampShouldBeSetAutomatically() {
            Instant before = Instant.now();
            LlmLogEntry entry = LlmLogEntry.request("req-1", "gemini-2.0-flash", "/v1/generate", "Test");
            Instant after = Instant.now();
            
            assertThat(entry.timestamp()).isAfterOrEqualTo(before);
            assertThat(entry.timestamp()).isBeforeOrEqualTo(after);
        }

        @Test
        @DisplayName("withMetadata should create new entry with metadata")
        void withMetadataShouldCreateNewEntryWithMetadata() {
            LlmLogEntry original = LlmLogEntry.request("req-1", "gemini-2.0-flash", "/v1/generate", "Test");
            LlmLogEntry withMeta = original.withMetadata(Map.of("pipelineId", "pipe-123", "step", "layout"));
            
            assertThat(withMeta.requestId()).isEqualTo(original.requestId());
            assertThat(withMeta.metadata()).containsEntry("pipelineId", "pipe-123");
            assertThat(original.metadata()).isNull(); // Original unchanged
        }
    }

    @Nested
    @DisplayName("LlmInteractionLogger Unit Tests")
    class LlmInteractionLoggerUnitTests {

        @TempDir
        Path tempDir;

        private LlmInteractionLogger logger;
        private LlmLogWriter writer;

        @BeforeEach
        void setUp() {
            writer = new LlmLogWriter(tempDir.toString());
            logger = new LlmInteractionLogger(writer);
        }

        @Test
        @DisplayName("generateRequestId should return unique UUIDs")
        void generateRequestIdShouldReturnUniqueUuids() {
            String id1 = logger.generateRequestId();
            String id2 = logger.generateRequestId();
            
            assertThat(id1).isNotEqualTo(id2);
            assertThat(id1).matches("[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}");
        }

        @Test
        @DisplayName("logRequest and logResponse should correlate")
        void logRequestAndLogResponseShouldCorrelate() throws IOException {
            String requestId = logger.generateRequestId();
            
            logger.logRequest(requestId, "gemini-2.0-flash", "/v1/generate", "Test prompt");
            
            // Simulate some processing time
            try { Thread.sleep(10); } catch (InterruptedException ignored) {}
            
            logger.logResponse(requestId, "gemini-2.0-flash", "Response text", 100, 50);
            
            writer.shutdown();
            
            // Verify log file
            List<String> lines = Files.readAllLines(writer.getCurrentLogFile());
            assertThat(lines).hasSize(2);
            
            Map<String, Object> request = JsonUtils.fromJson(lines.get(0), new TypeReference<>() {});
            Map<String, Object> response = JsonUtils.fromJson(lines.get(1), new TypeReference<>() {});
            
            assertThat(request.get("requestId")).isEqualTo(requestId);
            assertThat(response.get("requestId")).isEqualTo(requestId);
            assertThat(request.get("direction")).isEqualTo("REQUEST");
            assertThat(response.get("direction")).isEqualTo("RESPONSE");
        }

        @Test
        @DisplayName("logError should record error details")
        void logErrorShouldRecordErrorDetails() throws IOException {
            String requestId = logger.generateRequestId();
            
            logger.logRequest(requestId, "gemini-2.0-flash", "/v1/generate", "Test");
            logger.logError(requestId, "gemini-2.0-flash", new RuntimeException("Connection failed"));
            
            writer.shutdown();
            
            List<String> lines = Files.readAllLines(writer.getCurrentLogFile());
            Map<String, Object> error = JsonUtils.fromJson(lines.get(1), new TypeReference<>() {});
            
            assertThat(error.get("status")).isEqualTo("ERROR");
            assertThat(error.get("errorMessage")).isEqualTo("Connection failed");
        }
    }
}
</file>

<file path="src/test/java/com/catalogforge/service/ImageServiceTest.java">
package com.catalogforge.service;

import com.catalogforge.exception.ImageUploadException;
import com.catalogforge.exception.ResourceNotFoundException;
import net.jqwik.api.*;
import net.jqwik.api.constraints.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.Base64;

import static org.assertj.core.api.Assertions.*;

/**
 * Property-based and unit tests for ImageService.
 */
class ImageServiceTest {

    private ImageService imageService;

    @BeforeEach
    void setUp() {
        imageService = new ImageService("http://localhost:8080");
    }

    @Nested
    @DisplayName("Property 10: Image Upload Round-Trip")
    class ImageUploadRoundTripTests {

        @Property(tries = 30)
        @Label("Uploaded image should be retrievable")
        void uploadedImageShouldBeRetrievable(
                @ForAll @ByteRange(min = 1, max = 127) byte[] data,
                @ForAll("validMimeType") String mimeType
        ) {
            // Ensure minimum data size
            if (data.length < 10) return;
            
            String base64 = Base64.getEncoder().encodeToString(data);
            
            String imageId = imageService.upload(base64, mimeType, "test.jpg");
            
            assertThat(imageId).isNotBlank();
            assertThat(imageService.exists(imageId)).isTrue();
            
            ImageService.StoredImage retrieved = imageService.getImage(imageId);
            assertThat(retrieved.data()).isEqualTo(data);
            assertThat(retrieved.mimeType()).isEqualTo(mimeType);
        }

        @Property(tries = 20)
        @Label("Generated URL should contain image ID")
        void generatedUrlShouldContainImageId(
                @ForAll @ByteRange(min = 1, max = 127) byte[] data
        ) {
            if (data.length < 10) return;
            
            String base64 = Base64.getEncoder().encodeToString(data);
            String imageId = imageService.upload(base64, "image/jpeg", "test.jpg");
            
            String url = imageService.generateUrl(imageId);
            
            assertThat(url).contains(imageId);
            assertThat(url).startsWith("http://localhost:8080/api/v1/images/");
        }

        @Property(tries = 20)
        @Label("Deleted image should not be retrievable")
        void deletedImageShouldNotBeRetrievable(
                @ForAll @ByteRange(min = 1, max = 127) byte[] data
        ) {
            if (data.length < 10) return;
            
            String base64 = Base64.getEncoder().encodeToString(data);
            String imageId = imageService.upload(base64, "image/png", "test.png");
            
            assertThat(imageService.exists(imageId)).isTrue();
            
            imageService.delete(imageId);
            
            assertThat(imageService.exists(imageId)).isFalse();
            assertThatThrownBy(() -> imageService.getImage(imageId))
                    .isInstanceOf(ResourceNotFoundException.class);
        }

        @Provide
        Arbitrary<String> validMimeType() {
            return Arbitraries.of("image/jpeg", "image/png", "image/webp");
        }
    }

    @Nested
    @DisplayName("Image Validation Tests")
    class ImageValidationTests {

        @Test
        @DisplayName("Should reject invalid MIME types")
        void shouldRejectInvalidMimeTypes() {
            String base64 = Base64.getEncoder().encodeToString(new byte[100]);
            
            assertThatThrownBy(() -> imageService.upload(base64, "image/gif", "test.gif"))
                    .isInstanceOf(ImageUploadException.class)
                    .hasMessageContaining("Invalid image type");
            
            assertThatThrownBy(() -> imageService.upload(base64, "application/pdf", "test.pdf"))
                    .isInstanceOf(ImageUploadException.class);
        }

        @Test
        @DisplayName("Should accept valid MIME types")
        void shouldAcceptValidMimeTypes() {
            String base64 = Base64.getEncoder().encodeToString(new byte[100]);
            
            assertThatCode(() -> imageService.upload(base64, "image/jpeg", "test.jpg"))
                    .doesNotThrowAnyException();
            
            assertThatCode(() -> imageService.upload(base64, "image/png", "test.png"))
                    .doesNotThrowAnyException();
            
            assertThatCode(() -> imageService.upload(base64, "image/webp", "test.webp"))
                    .doesNotThrowAnyException();
        }

        @Test
        @DisplayName("Should generate unique IDs for each upload")
        void shouldGenerateUniqueIds() {
            String base64 = Base64.getEncoder().encodeToString(new byte[100]);
            
            String id1 = imageService.upload(base64, "image/jpeg", "test1.jpg");
            String id2 = imageService.upload(base64, "image/jpeg", "test2.jpg");
            String id3 = imageService.upload(base64, "image/jpeg", "test3.jpg");
            
            assertThat(id1).isNotEqualTo(id2);
            assertThat(id2).isNotEqualTo(id3);
            assertThat(id1).isNotEqualTo(id3);
        }
    }

    @Nested
    @DisplayName("Image Retrieval Tests")
    class ImageRetrievalTests {

        @Test
        @DisplayName("Should return image as Base64")
        void shouldReturnImageAsBase64() {
            byte[] originalData = "test image data".getBytes();
            String base64 = Base64.getEncoder().encodeToString(originalData);
            
            String imageId = imageService.upload(base64, "image/jpeg", "test.jpg");
            String retrievedBase64 = imageService.getImageBase64(imageId);
            
            assertThat(retrievedBase64).isEqualTo(base64);
        }

        @Test
        @DisplayName("Should throw for non-existent image")
        void shouldThrowForNonExistentImage() {
            assertThatThrownBy(() -> imageService.getImage("non-existent-id"))
                    .isInstanceOf(ResourceNotFoundException.class);
        }

        @Test
        @DisplayName("Should track image count")
        void shouldTrackImageCount() {
            String base64 = Base64.getEncoder().encodeToString(new byte[100]);
            
            int initialCount = imageService.getImageCount();
            
            imageService.upload(base64, "image/jpeg", "test1.jpg");
            imageService.upload(base64, "image/png", "test2.png");
            
            assertThat(imageService.getImageCount()).isEqualTo(initialCount + 2);
        }
    }
}
</file>

<file path="src/test/java/com/catalogforge/service/ProductServiceTest.java">
package com.catalogforge.service;

import com.catalogforge.exception.ResourceNotFoundException;
import com.catalogforge.model.Product;
import net.jqwik.api.*;
import net.jqwik.api.constraints.NotBlank;
import net.jqwik.api.constraints.Size;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Set;

import static org.assertj.core.api.Assertions.*;

/**
 * Tests for ProductService including property-based tests.
 * 
 * Property Tests validate:
 * - Property 1: Product Data Integrity (Requirements 1.1, 1.3)
 * - Property 2: Product Filtering Correctness (Requirements 1.2)
 * - Property 3: Search Result Relevance (Requirements 1.5)
 * - Property 4: Categories and Series Uniqueness (Requirements 1.6, 1.7)
 */
class ProductServiceTest {

    private ProductService productService;

    @BeforeEach
    void setUp() {
        productService = new ProductService();
        productService.init();
    }

    @Nested
    @DisplayName("Product Loading Tests")
    class ProductLoadingTests {

        @Test
        @DisplayName("should load all 30 products from JSON file")
        void shouldLoadAllProducts() {
            assertThat(productService.getProductCount()).isEqualTo(30);
        }

        @Test
        @DisplayName("should have products with valid IDs")
        void shouldHaveValidIds() {
            List<Product> products = productService.getAllProducts();
            assertThat(products)
                    .extracting(Product::id)
                    .doesNotContainNull()
                    .doesNotHaveDuplicates();
        }

        @Test
        @DisplayName("should have products with required fields")
        void shouldHaveRequiredFields() {
            List<Product> products = productService.getAllProducts();
            assertThat(products).allSatisfy(product -> {
                assertThat(product.id()).isNotNull();
                assertThat(product.name()).isNotBlank();
                assertThat(product.category()).isNotBlank();
                assertThat(product.series()).isNotBlank();
                assertThat(product.shortDescription()).isNotBlank();
                assertThat(product.description()).isNotBlank();
            });
        }
    }

    @Nested
    @DisplayName("Product Lookup Tests")
    class ProductLookupTests {

        @Test
        @DisplayName("should find product by valid ID")
        void shouldFindProductById() {
            Product product = productService.getProductById(1L);
            assertThat(product).isNotNull();
            assertThat(product.id()).isEqualTo(1L);
            assertThat(product.name()).contains("Actros");
        }

        @Test
        @DisplayName("should throw ResourceNotFoundException for invalid ID")
        void shouldThrowForInvalidId() {
            assertThatThrownBy(() -> productService.getProductById(999L))
                    .isInstanceOf(ResourceNotFoundException.class)
                    .hasMessageContaining("Product")
                    .hasMessageContaining("999");
        }

        @Test
        @DisplayName("should return empty optional for non-existent ID")
        void shouldReturnEmptyOptional() {
            assertThat(productService.findProductById(999L)).isEmpty();
        }

        @Test
        @DisplayName("should return present optional for existing ID")
        void shouldReturnPresentOptional() {
            assertThat(productService.findProductById(1L)).isPresent();
        }
    }

    @Nested
    @DisplayName("Property 1: Product Data Integrity")
    class ProductDataIntegrityPropertyTests {

        @Property
        @Label("All product IDs should be unique")
        void allProductIdsShouldBeUnique() {
            List<Product> products = productService.getAllProducts();
            Set<Long> ids = Set.copyOf(products.stream().map(Product::id).toList());
            assertThat(ids).hasSize(products.size());
        }

        @Property
        @Label("All products should have non-empty names")
        void allProductsShouldHaveNames() {
            List<Product> products = productService.getAllProducts();
            assertThat(products)
                    .extracting(Product::name)
                    .allMatch(name -> name != null && !name.isBlank());
        }

        @Property
        @Label("All products should have valid categories")
        void allProductsShouldHaveCategories() {
            List<Product> products = productService.getAllProducts();
            Set<String> validCategories = productService.getAllCategories();
            
            assertThat(products)
                    .extracting(Product::category)
                    .allMatch(validCategories::contains);
        }

        @Property
        @Label("All products should have valid series")
        void allProductsShouldHaveSeries() {
            List<Product> products = productService.getAllProducts();
            Set<String> validSeries = productService.getAllSeries();
            
            assertThat(products)
                    .extracting(Product::series)
                    .allMatch(validSeries::contains);
        }
    }

    @Nested
    @DisplayName("Property 2: Product Filtering Correctness")
    class ProductFilteringPropertyTests {

        @Property
        @Label("Filtering by category should return only products with that category")
        void filteringByCategoryShouldBeCorrect() {
            Set<String> categories = productService.getAllCategories();
            
            for (String category : categories) {
                List<Product> filtered = productService.filterProducts(category, null);
                assertThat(filtered)
                        .isNotEmpty()
                        .allMatch(p -> p.category().equalsIgnoreCase(category));
            }
        }

        @Property
        @Label("Filtering by series should return only products with that series")
        void filteringBySeriesShouldBeCorrect() {
            Set<String> seriesList = productService.getAllSeries();
            
            for (String series : seriesList) {
                List<Product> filtered = productService.filterProducts(null, series);
                assertThat(filtered)
                        .isNotEmpty()
                        .allMatch(p -> p.series().equalsIgnoreCase(series));
            }
        }

        @Property
        @Label("Filtering with null parameters should return all products")
        void filteringWithNullShouldReturnAll() {
            List<Product> filtered = productService.filterProducts(null, null);
            assertThat(filtered).hasSize(productService.getProductCount());
        }

        @Property
        @Label("Combined filtering should be intersection of both filters")
        void combinedFilteringShouldBeIntersection() {
            // Get a category and series that exist together
            Product firstProduct = productService.getAllProducts().get(0);
            String category = firstProduct.category();
            String series = firstProduct.series();
            
            List<Product> filtered = productService.filterProducts(category, series);
            
            assertThat(filtered)
                    .allMatch(p -> p.category().equalsIgnoreCase(category))
                    .allMatch(p -> p.series().equalsIgnoreCase(series));
        }
    }

    @Nested
    @DisplayName("Property 3: Search Result Relevance")
    class SearchRelevancePropertyTests {

        @Property
        @Label("Search results should contain query in searchable fields")
        void searchResultsShouldContainQuery() {
            // Search for "Actros" - should find multiple products
            List<Product> results = productService.searchProducts("Actros");
            
            assertThat(results)
                    .isNotEmpty()
                    .allMatch(p -> 
                            containsIgnoreCase(p.name(), "Actros") ||
                            containsIgnoreCase(p.shortDescription(), "Actros") ||
                            containsIgnoreCase(p.description(), "Actros") ||
                            containsIgnoreCase(p.series(), "Actros") ||
                            containsIgnoreCase(p.category(), "Actros")
                    );
        }

        @Property
        @Label("Search should be case-insensitive")
        void searchShouldBeCaseInsensitive() {
            List<Product> upperResults = productService.searchProducts("ACTROS");
            List<Product> lowerResults = productService.searchProducts("actros");
            List<Product> mixedResults = productService.searchProducts("AcTrOs");
            
            assertThat(upperResults).hasSameElementsAs(lowerResults);
            assertThat(lowerResults).hasSameElementsAs(mixedResults);
        }

        @Property
        @Label("Empty search should return all products")
        void emptySearchShouldReturnAll() {
            assertThat(productService.searchProducts("")).hasSize(productService.getProductCount());
            assertThat(productService.searchProducts(null)).hasSize(productService.getProductCount());
            assertThat(productService.searchProducts("   ")).hasSize(productService.getProductCount());
        }

        @Property
        @Label("Search for non-existent term should return empty list")
        void searchForNonExistentShouldReturnEmpty() {
            List<Product> results = productService.searchProducts("xyznonexistent123");
            assertThat(results).isEmpty();
        }

        @Test
        @DisplayName("Search should find products by series name")
        void searchShouldFindBySeries() {
            List<Product> results = productService.searchProducts("Unimog");
            assertThat(results)
                    .isNotEmpty()
                    .allMatch(p -> p.series().contains("Unimog") || 
                                   p.name().contains("Unimog") ||
                                   p.description().contains("Unimog"));
        }

        @Test
        @DisplayName("Search should find products by category")
        void searchShouldFindByCategory() {
            List<Product> results = productService.searchProducts("Elektro");
            assertThat(results).isNotEmpty();
        }
    }

    @Nested
    @DisplayName("Property 4: Categories and Series Uniqueness")
    class CategoriesSeriesUniquenessPropertyTests {

        @Property
        @Label("Categories should be unique and sorted")
        void categoriesShouldBeUniqueAndSorted() {
            Set<String> categories = productService.getAllCategories();
            
            assertThat(categories)
                    .isNotEmpty()
                    .doesNotContainNull()
                    .allMatch(c -> !c.isBlank());
            
            // Verify sorted
            List<String> categoryList = List.copyOf(categories);
            assertThat(categoryList).isSorted();
        }

        @Property
        @Label("Series should be unique and sorted")
        void seriesShouldBeUniqueAndSorted() {
            Set<String> series = productService.getAllSeries();
            
            assertThat(series)
                    .isNotEmpty()
                    .doesNotContainNull()
                    .allMatch(s -> !s.isBlank());
            
            // Verify sorted
            List<String> seriesList = List.copyOf(series);
            assertThat(seriesList).isSorted();
        }

        @Property
        @Label("Every product category should be in getAllCategories")
        void everyProductCategoryShouldBeInGetAllCategories() {
            Set<String> categories = productService.getAllCategories();
            List<Product> products = productService.getAllProducts();
            
            for (Product product : products) {
                assertThat(categories).contains(product.category());
            }
        }

        @Property
        @Label("Every product series should be in getAllSeries")
        void everyProductSeriesShouldBeInGetAllSeries() {
            Set<String> series = productService.getAllSeries();
            List<Product> products = productService.getAllProducts();
            
            for (Product product : products) {
                assertThat(series).contains(product.series());
            }
        }
    }

    @Nested
    @DisplayName("Specific Product Data Tests")
    class SpecificProductDataTests {

        @Test
        @DisplayName("should have Actros L 1853 LS ProCabin as first product")
        void shouldHaveActrosAsFirstProduct() {
            Product product = productService.getProductById(1L);
            assertThat(product.name()).isEqualTo("Mercedes-Benz Actros L 1853 LS ProCabin");
            assertThat(product.series()).isEqualTo("Actros L");
            assertThat(product.category()).isEqualTo("Fernverkehr");
            assertThat(product.priceEur()).isEqualTo(189500);
        }

        @Test
        @DisplayName("should have eActros 600 as electric truck")
        void shouldHaveEActros600() {
            Product product = productService.getProductById(6L);
            assertThat(product.name()).contains("eActros 600");
            assertThat(product.category()).contains("Elektro");
            assertThat(product.specs().specifications()).containsKey("batteriekapazitaet_kwh");
        }

        @Test
        @DisplayName("should have highlights for products")
        void shouldHaveHighlights() {
            Product product = productService.getProductById(1L);
            assertThat(product.highlights())
                    .isNotEmpty()
                    .contains("Active Brake Assist 6");
        }

        @Test
        @DisplayName("should have technical specs")
        void shouldHaveTechnicalSpecs() {
            Product product = productService.getProductById(1L);
            assertThat(product.specs().specifications())
                    .containsKey("motor")
                    .containsKey("leistung_ps")
                    .containsKey("gesamtgewicht_t");
        }
    }

    private boolean containsIgnoreCase(String text, String query) {
        return text != null && text.toLowerCase().contains(query.toLowerCase());
    }
}
</file>

<file path="src/test/java/com/catalogforge/skill/SkillAssemblerTest.java">
package com.catalogforge.skill;

import com.catalogforge.model.Skill;
import net.jqwik.api.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for SkillAssembler including property-based tests.
 * 
 * Property Tests validate:
 * - Property 7: Skill Assembly Ordering (Requirements 6.1, 6.2, 6.3, 6.4)
 * - Property 8: Style and Format Skill Inclusion (Requirements 2.3, 2.4, 6.5, 6.6)
 */
class SkillAssemblerTest {

    private SkillAssembler assembler;
    private Map<String, Skill> testSkills;

    @BeforeEach
    void setUp() {
        assembler = new SkillAssembler();
        testSkills = createTestSkills();
    }

    private Map<String, Skill> createTestSkills() {
        Map<String, Skill> skills = new HashMap<>();
        
        skills.put("MASTER_SKILL", new Skill(
                "MASTER_SKILL", "core", "Master skill content", List.of(), Skill.MASTER_PRIORITY));
        
        skills.put("LAYOUT_PRINCIPLES", new Skill(
                "LAYOUT_PRINCIPLES", "core", "Layout principles content", 
                List.of("MASTER_SKILL"), 10));
        
        skills.put("TYPOGRAPHY", new Skill(
                "TYPOGRAPHY", "core", "Typography content", 
                List.of("MASTER_SKILL"), 15));
        
        skills.put("STYLE_MODERN", new Skill(
                "STYLE_MODERN", "styles", "Modern style content", 
                List.of("LAYOUT_PRINCIPLES", "TYPOGRAPHY"), 50));
        
        skills.put("STYLE_TECHNICAL", new Skill(
                "STYLE_TECHNICAL", "styles", "Technical style content", 
                List.of("LAYOUT_PRINCIPLES"), 50));
        
        skills.put("FORMAT_A4", new Skill(
                "FORMAT_A4", "formats", "A4 format content", List.of(), 60));
        
        skills.put("FORMAT_DL", new Skill(
                "FORMAT_DL", "formats", "DL format content", List.of(), 60));
        
        return skills;
    }

    @Nested
    @DisplayName("Property 7: Skill Assembly Ordering")
    class SkillAssemblyOrderingTests {

        @Test
        @DisplayName("MASTER_SKILL should always be first")
        void masterSkillShouldBeFirst() {
            List<String> order = assembler.getOrderedSkillNames(
                    testSkills, List.of("TYPOGRAPHY"), null, null);
            
            assertThat(order).isNotEmpty();
            assertThat(order.get(0)).isEqualTo("MASTER_SKILL");
        }

        @Test
        @DisplayName("Dependencies should come before dependent skills")
        void dependenciesShouldComeBefore() {
            List<String> order = assembler.getOrderedSkillNames(
                    testSkills, List.of("STYLE_MODERN"), null, null);
            
            int masterIdx = order.indexOf("MASTER_SKILL");
            int layoutIdx = order.indexOf("LAYOUT_PRINCIPLES");
            int typographyIdx = order.indexOf("TYPOGRAPHY");
            int styleIdx = order.indexOf("STYLE_MODERN");
            
            assertThat(masterIdx).isLessThan(layoutIdx);
            assertThat(masterIdx).isLessThan(typographyIdx);
            assertThat(layoutIdx).isLessThan(styleIdx);
            assertThat(typographyIdx).isLessThan(styleIdx);
        }

        @Test
        @DisplayName("Skills should be sorted by priority")
        void skillsShouldBeSortedByPriority() {
            List<String> order = assembler.getOrderedSkillNames(
                    testSkills, List.of("STYLE_MODERN", "FORMAT_A4"), null, null);
            
            // Verify priority order: MASTER(0) < LAYOUT(10) < TYPOGRAPHY(15) < STYLE(50) < FORMAT(60)
            int masterIdx = order.indexOf("MASTER_SKILL");
            int layoutIdx = order.indexOf("LAYOUT_PRINCIPLES");
            int typographyIdx = order.indexOf("TYPOGRAPHY");
            int styleIdx = order.indexOf("STYLE_MODERN");
            int formatIdx = order.indexOf("FORMAT_A4");
            
            assertThat(masterIdx).isLessThan(layoutIdx);
            assertThat(layoutIdx).isLessThan(typographyIdx);
            assertThat(typographyIdx).isLessThan(styleIdx);
            assertThat(styleIdx).isLessThan(formatIdx);
        }

        @Property
        @Label("Assembly should include all dependencies recursively")
        void assemblyShouldIncludeAllDependencies() {
            // STYLE_MODERN depends on LAYOUT_PRINCIPLES and TYPOGRAPHY
            // LAYOUT_PRINCIPLES depends on MASTER_SKILL
            // TYPOGRAPHY depends on MASTER_SKILL
            List<String> order = assembler.getOrderedSkillNames(
                    testSkills, List.of("STYLE_MODERN"), null, null);
            
            assertThat(order).contains("MASTER_SKILL", "LAYOUT_PRINCIPLES", "TYPOGRAPHY", "STYLE_MODERN");
        }

        @Property
        @Label("No duplicate skills in assembly")
        void noDuplicateSkillsInAssembly() {
            List<String> order = assembler.getOrderedSkillNames(
                    testSkills, List.of("STYLE_MODERN", "LAYOUT_PRINCIPLES", "TYPOGRAPHY"), null, null);
            
            assertThat(order).doesNotHaveDuplicates();
        }
    }

    @Nested
    @DisplayName("Property 8: Style and Format Skill Inclusion")
    class StyleFormatInclusionTests {

        @Test
        @DisplayName("Style skill should be included when specified")
        void styleSkillShouldBeIncluded() {
            List<String> order = assembler.getOrderedSkillNames(
                    testSkills, List.of(), "modern", null);
            
            assertThat(order).contains("STYLE_MODERN");
        }

        @Test
        @DisplayName("Format skill should be included when specified")
        void formatSkillShouldBeIncluded() {
            List<String> order = assembler.getOrderedSkillNames(
                    testSkills, List.of(), null, "A4");
            
            assertThat(order).contains("FORMAT_A4");
        }

        @Test
        @DisplayName("Both style and format should be included")
        void bothStyleAndFormatShouldBeIncluded() {
            List<String> order = assembler.getOrderedSkillNames(
                    testSkills, List.of(), "technical", "DL");
            
            assertThat(order).contains("STYLE_TECHNICAL", "FORMAT_DL");
        }

        @Test
        @DisplayName("Style name normalization should work")
        void styleNameNormalizationShouldWork() {
            assertThat(assembler.normalizeStyleName("modern")).isEqualTo("STYLE_MODERN");
            assertThat(assembler.normalizeStyleName("MODERN")).isEqualTo("STYLE_MODERN");
            assertThat(assembler.normalizeStyleName("STYLE_MODERN")).isEqualTo("STYLE_MODERN");
        }

        @Test
        @DisplayName("Format name normalization should work")
        void formatNameNormalizationShouldWork() {
            assertThat(assembler.normalizeFormatName("a4")).isEqualTo("FORMAT_A4");
            assertThat(assembler.normalizeFormatName("A4")).isEqualTo("FORMAT_A4");
            assertThat(assembler.normalizeFormatName("FORMAT_A4")).isEqualTo("FORMAT_A4");
        }

        @Property
        @Label("Style dependencies should be resolved")
        void styleDependenciesShouldBeResolved() {
            // STYLE_MODERN depends on LAYOUT_PRINCIPLES and TYPOGRAPHY
            List<String> order = assembler.getOrderedSkillNames(
                    testSkills, List.of(), "modern", null);
            
            assertThat(order).contains("LAYOUT_PRINCIPLES", "TYPOGRAPHY");
        }
    }

    @Nested
    @DisplayName("Assembly Content Tests")
    class AssemblyContentTests {

        @Test
        @DisplayName("Assembled content should contain skill headers")
        void assembledContentShouldContainHeaders() {
            String content = assembler.assemble(
                    testSkills, List.of("TYPOGRAPHY"), null, null);
            
            assertThat(content).contains("# MASTER_SKILL");
            assertThat(content).contains("# TYPOGRAPHY");
        }

        @Test
        @DisplayName("Assembled content should contain skill content")
        void assembledContentShouldContainContent() {
            String content = assembler.assemble(
                    testSkills, List.of("TYPOGRAPHY"), null, null);
            
            assertThat(content).contains("Master skill content");
            assertThat(content).contains("Typography content");
        }

        @Test
        @DisplayName("Skills should be separated by dividers")
        void skillsShouldBeSeparatedByDividers() {
            String content = assembler.assemble(
                    testSkills, List.of("TYPOGRAPHY"), null, null);
            
            assertThat(content).contains("---");
        }
    }
}
</file>

<file path="src/test/java/com/catalogforge/skill/SkillLoaderTest.java">
package com.catalogforge.skill;

import com.catalogforge.model.Skill;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for SkillLoader.
 */
class SkillLoaderTest {

    private SkillLoader loader;

    @BeforeEach
    void setUp() {
        loader = new SkillLoader();
    }

    @Nested
    @DisplayName("Skill Loading Tests")
    class SkillLoadingTests {

        @Test
        @DisplayName("should load skills from resources")
        void shouldLoadSkillsFromResources() {
            Map<String, Skill> skills = loader.loadAllSkills();
            
            assertThat(skills).isNotEmpty();
            assertThat(skills).containsKey("MASTER_SKILL");
        }

        @Test
        @DisplayName("should load MASTER_SKILL with priority 0")
        void shouldLoadMasterSkillWithPriorityZero() {
            Map<String, Skill> skills = loader.loadAllSkills();
            
            Skill master = skills.get("MASTER_SKILL");
            assertThat(master).isNotNull();
            assertThat(master.priority()).isEqualTo(Skill.MASTER_PRIORITY);
        }

        @Test
        @DisplayName("should extract category from path")
        void shouldExtractCategoryFromPath() {
            Map<String, Skill> skills = loader.loadAllSkills();
            
            Skill master = skills.get("MASTER_SKILL");
            assertThat(master.category()).isEqualTo("core");
            
            if (skills.containsKey("STYLE_MODERN")) {
                Skill style = skills.get("STYLE_MODERN");
                assertThat(style.category()).isEqualTo("styles");
            }
        }

        @Test
        @DisplayName("should parse dependencies from metadata")
        void shouldParseDependencies() {
            Map<String, Skill> skills = loader.loadAllSkills();
            
            Skill layout = skills.get("LAYOUT_PRINCIPLES");
            if (layout != null) {
                assertThat(layout.dependencies()).contains("MASTER_SKILL");
            }
        }
    }

    @Nested
    @DisplayName("Metadata Parsing Tests")
    class MetadataParsingTests {

        @Test
        @DisplayName("should parse dependencies list")
        void shouldParseDependenciesList() {
            String metadata = "dependencies: [DEP1, DEP2, DEP3]";
            List<String> deps = loader.parseDependencies(metadata);
            
            assertThat(deps).containsExactly("DEP1", "DEP2", "DEP3");
        }

        @Test
        @DisplayName("should handle empty dependencies")
        void shouldHandleEmptyDependencies() {
            String metadata = "dependencies: []";
            List<String> deps = loader.parseDependencies(metadata);
            
            assertThat(deps).isEmpty();
        }

        @Test
        @DisplayName("should parse priority")
        void shouldParsePriority() {
            String metadata = "priority: 42";
            int priority = loader.parsePriority(metadata);
            
            assertThat(priority).isEqualTo(42);
        }

        @Test
        @DisplayName("should return default priority when not specified")
        void shouldReturnDefaultPriority() {
            String metadata = "other: value";
            int priority = loader.parsePriority(metadata);
            
            assertThat(priority).isEqualTo(Skill.DEFAULT_PRIORITY);
        }

        @Test
        @DisplayName("should extract name from filename")
        void shouldExtractNameFromFilename() {
            assertThat(loader.extractName("MASTER_SKILL.md")).isEqualTo("MASTER_SKILL");
            assertThat(loader.extractName("STYLE_MODERN.md")).isEqualTo("STYLE_MODERN");
        }
    }
}
</file>

<file path="src/test/java/com/catalogforge/util/ColorUtilsPropertyTest.java">
package com.catalogforge.util;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

import net.jqwik.api.ForAll;
import net.jqwik.api.Label;
import net.jqwik.api.Property;
import net.jqwik.api.constraints.CharRange;
import net.jqwik.api.constraints.StringLength;

/**
 * Property-based tests for color validation and contrast calculation.
 * 
 * Property 18: Color Validation and Contrast
 * For any string:
 * - Valid hex codes (#RGB, #RRGGBB) return isValid=true
 * - Invalid formats return isValid=false
 * For any two valid colors, WCAG contrast ratio is calculated correctly
 * (verified against known values: #000/#FFF = 21.0).
 * 
 * Validates: Requirements 12.6, 12.7
 */
@Tag("property")
@Tag("unit")
class ColorUtilsPropertyTest {

    @Property(tries = 100)
    @Label("Property 18: Color Validation - valid 6-digit hex codes")
    void valid6DigitHexCodesAccepted(
            @ForAll @CharRange(from = '0', to = '9') char c1,
            @ForAll @CharRange(from = 'a', to = 'f') char c2,
            @ForAll @CharRange(from = 'A', to = 'F') char c3,
            @ForAll @CharRange(from = '0', to = '9') char c4,
            @ForAll @CharRange(from = 'a', to = 'f') char c5,
            @ForAll @CharRange(from = '0', to = '9') char c6) {
        
        String color = "#" + c1 + c2 + c3 + c4 + c5 + c6;
        
        assertThat(ColorUtils.isValidHexColor(color)).isTrue();
    }

    @Property(tries = 100)
    @Label("Property 18: Color Validation - valid 3-digit hex codes")
    void valid3DigitHexCodesAccepted(
            @ForAll @CharRange(from = '0', to = '9') char c1,
            @ForAll @CharRange(from = 'a', to = 'f') char c2,
            @ForAll @CharRange(from = 'A', to = 'F') char c3) {
        
        String color = "#" + c1 + c2 + c3;
        
        assertThat(ColorUtils.isValidHexColor(color)).isTrue();
    }

    @Property(tries = 100)
    @Label("Property 18: Color Validation - invalid formats rejected")
    void invalidFormatsRejected(@ForAll @StringLength(min = 1, max = 10) String random) {
        // Skip if it accidentally matches valid format
        if (random.matches("#[0-9A-Fa-f]{3}") || random.matches("#[0-9A-Fa-f]{6}")) {
            return;
        }
        
        assertThat(ColorUtils.isValidHexColor(random)).isFalse();
    }

    @Test
    @Tag("unit")
    @Label("Property 18: Color Contrast - black/white = 21.0")
    void blackWhiteContrastIs21() {
        double contrast = ColorUtils.calculateContrastRatio("#000000", "#FFFFFF");
        
        assertThat(contrast).isCloseTo(21.0, within(0.1));
    }

    @Test
    @Tag("unit")
    @Label("Property 18: Color Contrast - same color = 1.0")
    void sameColorContrastIs1() {
        double contrast = ColorUtils.calculateContrastRatio("#FF0000", "#FF0000");
        
        assertThat(contrast).isCloseTo(1.0, within(0.01));
    }

    @Test
    @Tag("unit")
    @Label("Property 18: Color Contrast - 3-digit hex works")
    void threeDigitHexWorks() {
        // #FFF should equal #FFFFFF
        double contrast1 = ColorUtils.calculateContrastRatio("#000", "#FFF");
        double contrast2 = ColorUtils.calculateContrastRatio("#000000", "#FFFFFF");
        
        assertThat(contrast1).isCloseTo(contrast2, within(0.01));
    }

    @Property(tries = 50)
    @Label("Property 18: Color Contrast - ratio always between 1 and 21")
    void contrastRatioInValidRange(
            @ForAll @CharRange(from = '0', to = '9') char r1,
            @ForAll @CharRange(from = '0', to = '9') char g1,
            @ForAll @CharRange(from = '0', to = '9') char b1,
            @ForAll @CharRange(from = '0', to = '9') char r2,
            @ForAll @CharRange(from = '0', to = '9') char g2,
            @ForAll @CharRange(from = '0', to = '9') char b2) {
        
        String color1 = "#" + r1 + r1 + g1 + g1 + b1 + b1;
        String color2 = "#" + r2 + r2 + g2 + g2 + b2 + b2;
        
        double contrast = ColorUtils.calculateContrastRatio(color1, color2);
        
        assertThat(contrast).isBetween(1.0, 21.0);
    }

    @Property(tries = 50)
    @Label("Property 18: Color Contrast - symmetric")
    void contrastRatioIsSymmetric(
            @ForAll @CharRange(from = '0', to = '9') char c1,
            @ForAll @CharRange(from = '0', to = '9') char c2) {
        
        String color1 = "#" + c1 + c1 + c1 + c1 + c1 + c1;
        String color2 = "#" + c2 + c2 + c2 + c2 + c2 + c2;
        
        double contrast1 = ColorUtils.calculateContrastRatio(color1, color2);
        double contrast2 = ColorUtils.calculateContrastRatio(color2, color1);
        
        assertThat(contrast1).isCloseTo(contrast2, within(0.001));
    }
}
</file>

<file path="src/test/java/com/catalogforge/util/CssValidatorPropertyTest.java">
package com.catalogforge.util;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.Tag;

import net.jqwik.api.ForAll;
import net.jqwik.api.Label;
import net.jqwik.api.Property;
import net.jqwik.api.constraints.IntRange;

/**
 * Property-based tests for CSS validation.
 * 
 * Property 17: CSS Validation
 * For any CSS input:
 * - Unbalanced brackets are detected as invalid
 * - Print units (mm, cm, pt, in) are accepted as valid
 * 
 * Validates: Requirements 12.4, 12.5
 */
@Tag("property")
@Tag("unit")
class CssValidatorPropertyTest {

    @Property(tries = 100)
    @Label("Property 17: CSS Validation - balanced brackets valid")
    void balancedBracketsAreValid(@ForAll @IntRange(min = 1, max = 5) int depth) {
        StringBuilder css = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            css.append(".class").append(i).append(" { ");
        }
        css.append("color: red;");
        for (int i = 0; i < depth; i++) {
            css.append(" }");
        }
        
        var result = CssValidator.validate(css.toString());
        
        assertThat(result.isValid()).isTrue();
    }

    @Property(tries = 100)
    @Label("Property 17: CSS Validation - unbalanced brackets invalid")
    void unbalancedBracketsAreInvalid(@ForAll @IntRange(min = 1, max = 5) int extraOpen) {
        StringBuilder css = new StringBuilder();
        css.append(".page { width: 210mm;");
        for (int i = 0; i < extraOpen; i++) {
            css.append(" {");
        }
        // Missing closing brackets
        
        var result = CssValidator.validate(css.toString());
        
        assertThat(result.isValid()).isFalse();
        assertThat(result.errors()).isNotEmpty();
    }

    @Property(tries = 50)
    @Label("Property 17: CSS Validation - print units accepted (mm)")
    void printUnitsMmAccepted(@ForAll @IntRange(min = 1, max = 1000) int value) {
        String css = ".page { width: " + value + "mm; }";
        
        var result = CssValidator.validate(css);
        
        assertThat(result.isValid()).isTrue();
        assertThat(CssValidator.containsPrintUnits(value + "mm")).isTrue();
    }

    @Property(tries = 50)
    @Label("Property 17: CSS Validation - print units accepted (cm)")
    void printUnitsCmAccepted(@ForAll @IntRange(min = 1, max = 100) int value) {
        String css = ".page { height: " + value + "cm; }";
        
        var result = CssValidator.validate(css);
        
        assertThat(result.isValid()).isTrue();
        assertThat(CssValidator.containsPrintUnits(value + "cm")).isTrue();
    }

    @Property(tries = 50)
    @Label("Property 17: CSS Validation - print units accepted (pt)")
    void printUnitsPtAccepted(@ForAll @IntRange(min = 1, max = 1000) int value) {
        String css = ".text { font-size: " + value + "pt; }";
        
        var result = CssValidator.validate(css);
        
        assertThat(result.isValid()).isTrue();
        assertThat(CssValidator.containsPrintUnits(value + "pt")).isTrue();
    }

    @Property(tries = 50)
    @Label("Property 17: CSS Validation - balanced parentheses valid")
    void balancedParenthesesAreValid(@ForAll @IntRange(min = 1, max = 3) int depth) {
        StringBuilder css = new StringBuilder(".page { background: ");
        for (int i = 0; i < depth; i++) {
            css.append("rgb(");
        }
        css.append("255, 0, 0");
        for (int i = 0; i < depth; i++) {
            css.append(")");
        }
        css.append("; }");
        
        var result = CssValidator.validate(css.toString());
        
        assertThat(result.isValid()).isTrue();
    }
}
</file>

<file path="src/test/java/com/catalogforge/util/HtmlSanitizerPropertyTest.java">
package com.catalogforge.util;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.Tag;

import net.jqwik.api.ForAll;
import net.jqwik.api.Label;
import net.jqwik.api.Property;
import net.jqwik.api.constraints.NotBlank;

/**
 * Property-based tests for HTML sanitization.
 * 
 * Property 16: HTML Sanitization
 * For any HTML input:
 * - Output contains no script tags
 * - Output contains no event handler attributes (onclick, onload, onerror, etc.)
 * - Structural elements (div, span, p, h1-h6, img, table) are preserved
 * - CSS classes are preserved
 * 
 * Validates: Requirements 12.1, 12.2, 12.3
 */
@Tag("property")
@Tag("unit")
class HtmlSanitizerPropertyTest {

    @Property(tries = 100)
    @Label("Property 16: HTML Sanitization - script tags removed")
    void scriptTagsAreRemoved(@ForAll @NotBlank String content) {
        String html = "<div><script>" + content + "</script></div>";
        
        String sanitized = HtmlSanitizer.sanitize(html);
        
        assertThat(sanitized).doesNotContainIgnoringCase("<script");
        assertThat(sanitized).doesNotContainIgnoringCase("</script>");
    }

    @Property(tries = 100)
    @Label("Property 16: HTML Sanitization - event handlers removed")
    void eventHandlersAreRemoved(@ForAll @NotBlank String handler) {
        String html = "<div onclick=\"" + handler + "\">Content</div>";
        
        String sanitized = HtmlSanitizer.sanitize(html);
        
        assertThat(sanitized).doesNotContainIgnoringCase("onclick");
    }

    @Property(tries = 50)
    @Label("Property 16: HTML Sanitization - structural elements preserved")
    void structuralElementsPreserved(@ForAll @NotBlank String content) {
        String html = "<div class=\"container\"><p>" + escapeHtml(content) + "</p></div>";
        
        String sanitized = HtmlSanitizer.sanitize(html);
        
        assertThat(sanitized).contains("<div");
        assertThat(sanitized).contains("<p>");
        assertThat(sanitized).contains("</p>");
        assertThat(sanitized).contains("</div>");
    }

    @Property(tries = 50)
    @Label("Property 16: HTML Sanitization - CSS classes preserved")
    void cssClassesPreserved(@ForAll @NotBlank String className) {
        // Sanitize class name to be valid CSS
        String validClass = className.replaceAll("[^a-zA-Z0-9-_]", "");
        if (validClass.isEmpty()) validClass = "test";
        
        String html = "<div class=\"" + validClass + "\">Content</div>";
        
        String sanitized = HtmlSanitizer.sanitize(html);
        
        assertThat(sanitized).contains("class=\"" + validClass + "\"");
    }

    @Property(tries = 50)
    @Label("Property 16: HTML Sanitization - javascript URLs removed")
    void javascriptUrlsRemoved(@ForAll @NotBlank String code) {
        String html = "<a href=\"javascript:" + code + "\">Link</a>";
        
        String sanitized = HtmlSanitizer.sanitize(html);
        
        assertThat(sanitized).doesNotContainIgnoringCase("javascript:");
    }

    private String escapeHtml(String text) {
        return text.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;");
    }
}
</file>

<file path="src/test/java/com/catalogforge/CatalogForgeApplicationTest.java">
package com.catalogforge;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

/**
 * Smoke test to verify the application context loads successfully.
 */
@SpringBootTest
@ActiveProfiles("test")
@Tag("integration")
class CatalogForgeApplicationTest {

    @Test
    void contextLoads() {
        // Application context should load without errors
    }
}
</file>

<file path="src/test/resources/fixtures/gemini/error-response.json">
{
  "error": {
    "code": 429,
    "message": "Resource has been exhausted (e.g. check quota).",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.ErrorInfo",
        "reason": "RATE_LIMIT_EXCEEDED",
        "domain": "googleapis.com",
        "metadata": {
          "quota_metric": "generativelanguage.googleapis.com/generate_content_requests",
          "quota_limit": "GenerateContentRequestsPerMinutePerProject"
        }
      }
    ]
  }
}
</file>

<file path="src/test/resources/fixtures/gemini/image-analysis-dynamic.json">
{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "{\"colorPalette\":{\"primary\":\"#E63946\",\"secondary\":\"#1A1A2E\",\"accent\":\"#FFD60A\",\"neutralLight\":\"#F5F5F5\",\"neutralDark\":\"#0D0D0D\"},\"moodAnalysis\":{\"type\":\"dynamic\",\"confidence\":0.88,\"keywords\":[\"bold\",\"energetic\",\"powerful\",\"action\",\"modern\"]},\"layoutHints\":{\"gridType\":\"diagonal\",\"density\":\"high\",\"focusArea\":\"top-right\",\"suggestedColumns\":3}}"
          }
        ],
        "role": "model"
      },
      "finishReason": "STOP",
      "index": 0
    }
  ],
  "usageMetadata": {
    "promptTokenCount": 2500,
    "candidatesTokenCount": 175,
    "totalTokenCount": 2675
  },
  "modelVersion": "gemini-2.0-flash"
}
</file>

<file path="src/test/resources/fixtures/gemini/image-analysis-premium.json">
{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "{\"colorPalette\":{\"primary\":\"#1A2744\",\"secondary\":\"#4A5568\",\"accent\":\"#C9A962\",\"neutralLight\":\"#F8F6F3\",\"neutralDark\":\"#2D2D2D\"},\"moodAnalysis\":{\"type\":\"premium\",\"confidence\":0.92,\"keywords\":[\"elegant\",\"sophisticated\",\"luxurious\",\"refined\",\"exclusive\"]},\"layoutHints\":{\"gridType\":\"asymmetric\",\"density\":\"low\",\"focusArea\":\"center-left\",\"suggestedColumns\":2}}"
          }
        ],
        "role": "model"
      },
      "finishReason": "STOP",
      "index": 0
    }
  ],
  "usageMetadata": {
    "promptTokenCount": 2500,
    "candidatesTokenCount": 180,
    "totalTokenCount": 2680
  },
  "modelVersion": "gemini-2.0-flash"
}
</file>

<file path="src/test/resources/fixtures/gemini/layout-simple.json">
{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "{\"html\":\"<div class=\\\"product-page\\\"><header class=\\\"page-header\\\"><h1>eActros 600</h1><p class=\\\"subtitle\\\">Der vollelektrische Schwer-Lkw</p></header><main class=\\\"content\\\"><section class=\\\"hero\\\"><img src=\\\"product-image.jpg\\\" alt=\\\"eActros 600\\\" class=\\\"hero-image\\\"/></section><section class=\\\"highlights\\\"><h2>Highlights</h2><ul class=\\\"feature-list\\\"><li>Bis zu 500 km Reichweite</li><li>Megawatt-Charging fähig</li><li>Null lokale Emissionen</li></ul></section><section class=\\\"specs\\\"><h2>Technische Daten</h2><table class=\\\"spec-table\\\"><tr><th>Batteriekapazität</th><td>621 kWh</td></tr><tr><th>Reichweite</th><td>bis 500 km</td></tr><tr><th>Leistung</th><td>400 kW</td></tr></table></section></main><footer class=\\\"page-footer\\\"><p>Mercedes-Benz Trucks</p></footer></div>\",\"css\":\".product-page{font-family:'Inter',sans-serif;max-width:210mm;margin:0 auto;padding:15mm;background:#fff}.page-header{text-align:center;margin-bottom:2rem;border-bottom:2px solid #0066cc;padding-bottom:1rem}.page-header h1{font-size:2.5rem;color:#0066cc;margin-bottom:0.5rem}.subtitle{color:#666;font-size:1.25rem}.hero{margin-bottom:2rem}.hero-image{width:100%;height:auto;border-radius:8px}.highlights{margin-bottom:2rem}.highlights h2{font-size:1.5rem;color:#333;margin-bottom:1rem}.feature-list{list-style:none;padding:0}.feature-list li{padding:0.5rem 0;padding-left:1.5rem;position:relative}.feature-list li::before{content:'✓';position:absolute;left:0;color:#0066cc}.specs{margin-bottom:2rem}.spec-table{width:100%;border-collapse:collapse}.spec-table th,.spec-table td{padding:0.75rem;text-align:left;border-bottom:1px solid #eee}.spec-table th{color:#666;font-weight:500}.page-footer{text-align:center;color:#999;font-size:0.875rem;margin-top:2rem;padding-top:1rem;border-top:1px solid #eee}\",\"title\":\"eActros 600 Produktseite\"}"
          }
        ],
        "role": "model"
      },
      "finishReason": "STOP",
      "index": 0
    }
  ],
  "usageMetadata": {
    "promptTokenCount": 1250,
    "candidatesTokenCount": 850,
    "totalTokenCount": 2100
  },
  "modelVersion": "gemini-2.0-flash"
}
</file>

<file path="src/test/resources/fixtures/gemini/layout-with-specs.json">
{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "{\"html\":\"<div class=\\\"product-page technical\\\"><header class=\\\"page-header\\\"><div class=\\\"brand\\\">Mercedes-Benz Trucks</div><h1>Actros L 1853 LS ProCabin</h1><p class=\\\"tagline\\\">Fernverkehr auf höchstem Niveau</p></header><main class=\\\"content\\\"><div class=\\\"layout-grid\\\"><section class=\\\"product-image\\\"><img src=\\\"actros-l.jpg\\\" alt=\\\"Actros L ProCabin\\\" class=\\\"main-image\\\"/></section><section class=\\\"product-info\\\"><h2>Überblick</h2><p class=\\\"description\\\">Der Actros L mit ProCabin setzt neue Maßstäbe im Fernverkehr. Maximaler Komfort für lange Strecken kombiniert mit modernster Technologie.</p><div class=\\\"highlights-grid\\\"><div class=\\\"highlight\\\"><span class=\\\"value\\\">530</span><span class=\\\"unit\\\">PS</span><span class=\\\"label\\\">Leistung</span></div><div class=\\\"highlight\\\"><span class=\\\"value\\\">2.600</span><span class=\\\"unit\\\">Nm</span><span class=\\\"label\\\">Drehmoment</span></div><div class=\\\"highlight\\\"><span class=\\\"value\\\">12.8</span><span class=\\\"unit\\\">L</span><span class=\\\"label\\\">Hubraum</span></div></div></section></div><section class=\\\"specifications\\\"><h2>Technische Daten</h2><div class=\\\"spec-categories\\\"><div class=\\\"spec-category\\\"><h3>Motor</h3><table class=\\\"spec-table\\\"><tr><th>Typ</th><td>OM 471</td></tr><tr><th>Hubraum</th><td>12.809 cm³</td></tr><tr><th>Leistung</th><td>390 kW (530 PS)</td></tr><tr><th>Drehmoment</th><td>2.600 Nm</td></tr><tr><th>Abgasnorm</th><td>Euro VI-E</td></tr></table></div><div class=\\\"spec-category\\\"><h3>Getriebe</h3><table class=\\\"spec-table\\\"><tr><th>Typ</th><td>Mercedes PowerShift 3</td></tr><tr><th>Gänge</th><td>12</td></tr><tr><th>Schaltung</th><td>Automatisiert</td></tr></table></div><div class=\\\"spec-category\\\"><h3>Abmessungen</h3><table class=\\\"spec-table\\\"><tr><th>Radstand</th><td>3.700 mm</td></tr><tr><th>Gesamtlänge</th><td>6.500 mm</td></tr><tr><th>Gesamthöhe</th><td>3.950 mm</td></tr></table></div></div></section></main><footer class=\\\"page-footer\\\"><p>Technische Änderungen vorbehalten. Stand: 2024</p></footer></div>\",\"css\":\".product-page.technical{font-family:'Inter',sans-serif;max-width:210mm;margin:0 auto;padding:12mm;background:#fff;color:#333}.page-header{margin-bottom:1.5rem}.brand{font-size:0.75rem;text-transform:uppercase;letter-spacing:0.1em;color:#666;margin-bottom:0.5rem}.page-header h1{font-size:2rem;font-weight:700;color:#1a1a1a;margin-bottom:0.25rem}.tagline{color:#0066cc;font-size:1rem}.layout-grid{display:grid;grid-template-columns:1fr 1fr;gap:2rem;margin-bottom:2rem}.main-image{width:100%;height:auto;border-radius:4px}.product-info h2{font-size:1.25rem;margin-bottom:0.75rem;color:#333}.description{color:#666;line-height:1.6;margin-bottom:1.5rem}.highlights-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:1rem}.highlight{text-align:center;padding:1rem;background:#f8f9fa;border-radius:4px}.highlight .value{display:block;font-size:1.75rem;font-weight:700;color:#0066cc}.highlight .unit{font-size:0.875rem;color:#666}.highlight .label{display:block;font-size:0.75rem;color:#999;margin-top:0.25rem}.specifications h2{font-size:1.25rem;margin-bottom:1rem;padding-bottom:0.5rem;border-bottom:2px solid #0066cc}.spec-categories{display:grid;grid-template-columns:repeat(3,1fr);gap:1.5rem}.spec-category h3{font-size:0.875rem;text-transform:uppercase;letter-spacing:0.05em;color:#666;margin-bottom:0.75rem}.spec-table{width:100%;font-size:0.875rem}.spec-table th,.spec-table td{padding:0.5rem 0;border-bottom:1px solid #eee}.spec-table th{text-align:left;color:#666;font-weight:500;width:40%}.spec-table td{color:#1a1a1a}.page-footer{margin-top:2rem;padding-top:1rem;border-top:1px solid #eee;text-align:center;font-size:0.75rem;color:#999}\",\"title\":\"Actros L 1853 LS ProCabin - Technisches Datenblatt\"}"
          }
        ],
        "role": "model"
      },
      "finishReason": "STOP",
      "index": 0
    }
  ],
  "usageMetadata": {
    "promptTokenCount": 1850,
    "candidatesTokenCount": 1450,
    "totalTokenCount": 3300
  },
  "modelVersion": "gemini-2.0-flash"
}
</file>

<file path="src/test/resources/fixtures/gemini-responses/.gitkeep">
# Gemini API response fixtures for testing
</file>

<file path="src/test/resources/application-test.yml">
spring:
  application:
    name: catalog-forge-backend-test

catalogforge:
  data:
    products-path: classpath:data/products.json
  
  skills:
    base-path: classpath:skills/
    cache-enabled: false
  
  gemini:
    api-key: test-api-key
    base-url: https://generativelanguage.googleapis.com/v1beta
    model-default: gemini-2.5-flash
    model-vision: gemini-2.5-pro-vision
    model-complex: gemini-2.5-pro
    timeout-seconds: 10
    max-retries: 1
  
  puppeteer:
    node-path: /usr/bin/node
    script-path: ./puppeteer/pdf-generator.js
    temp-dir: /tmp/catalogforge-test/pdf
    default-dpi: 150
    image-timeout-seconds: 5
  
  layout:
    variant-count-default: 1
    max-variant-count: 3
    fallback-enabled: true
  
  images:
    temp-dir: /tmp/catalogforge-test/images
    url-validation-timeout-ms: 1000
    expiration-hours: 1
    placeholder-enabled: true
  
  logging:
    llm:
      enabled: false
      directory: ./logs/llm-test
      file-pattern: "{date}_llm.jsonl"

logging:
  level:
    com.catalogforge: DEBUG
</file>

<file path=".env.example">
# CatalogForge Backend Environment Variables
# Copy this file to .env and fill in your values

# Google Gemini API Key (required)
# Get your key at: https://aistudio.google.com/app/apikey
GEMINI_API_KEY=your-gemini-api-key-here
</file>

<file path=".gitignore">
# Gradle
.gradle/
build/
!gradle/wrapper/gradle-wrapper.jar

# IDE
.idea/
*.iml
*.ipr
*.iws
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log

# Temp files
/tmp/

# Environment
.env
.env.local

# Dev Container
.gradle-cache/

# Node
scripts/node_modules/

.DS_Store
</file>

<file path="build.gradle.kts">
plugins {
    java
    id("org.springframework.boot") version "3.4.1"
    id("io.spring.dependency-management") version "1.1.7"
    jacoco
}

group = "com.catalogforge"
version = "1.0.0-SNAPSHOT"

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // Spring Boot
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-webflux")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    
    // JSON Processing
    implementation("com.fasterxml.jackson.core:jackson-databind")
    implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310")
    
    // Configuration
    annotationProcessor("org.springframework.boot:spring-boot-configuration-processor")
    
    // Testing
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.junit.jupiter:junit-jupiter:5.11.3")
    testImplementation("org.mockito:mockito-core:5.14.2")
    testImplementation("org.assertj:assertj-core:3.26.3")
    testImplementation("net.jqwik:jqwik:1.9.2")
    testImplementation("org.skyscreamer:jsonassert:1.5.3")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

tasks.withType<Test> {
    useJUnitPlatform {
        includeEngines("junit-jupiter", "jqwik")
    }
    testLogging {
        events("passed", "skipped", "failed")
    }
}

tasks.register<Test>("unitTest") {
    useJUnitPlatform {
        includeTags("unit")
    }
}

tasks.register<Test>("integrationTest") {
    useJUnitPlatform {
        includeTags("integration")
    }
}

tasks.register<Test>("propertyTest") {
    useJUnitPlatform {
        includeTags("property")
    }
}

tasks.jacocoTestReport {
    dependsOn(tasks.test)
    reports {
        xml.required = true
        html.required = true
    }
}
</file>

<file path="daimler_truck_katalog_schema_dokumentation.md">
# Daimler Truck Katalog - JSON Schema Dokumentation

## Übersicht

Dieses Dokument beschreibt alle Key-Elemente im Daimler Truck Produktkatalog JSON.

---

## Hauptstruktur

```
{
  "katalog": { ... },      // Hauptcontainer mit Fahrzeugdaten
  "metadaten": { ... }     // Metadaten und Zusatzinformationen
}
```

---

## 1. Katalog-Objekt (`katalog`)

| Key | Typ | Pflicht | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `titel` | string | ✓ | Titel des Katalogs | "Daimler Truck Produktkatalog 2025" |
| `unternehmen` | string | ✓ | Unternehmensname | "Daimler Truck AG" |
| `version` | string | ✓ | Versionsnummer | "1.0" |
| `erstellungsdatum` | string | ○ | Datum (YYYY-MM-DD) | "2025-01-15" |
| `sprache` | string | ○ | BCP 47 Sprachcode | "de-DE" |
| `trucks` | array | ✓ | Array aller Fahrzeuge | [...] |

---

## 2. Metadaten-Objekt (`metadaten`)

| Key | Typ | Beschreibung | Beispiel |
|-----|-----|--------------|----------|
| `anzahl_fahrzeuge` | integer | Gesamtanzahl Fahrzeuge | 30 |
| `kategorien` | array[string] | Liste aller Kategorien | ["Fernverkehr", "Baustelle"] |
| `baureihen` | array[string] | Liste aller Baureihen | ["Actros L", "Arocs"] |
| `hinweis` | string | Allgemeiner Hinweis | "Alle Angaben sind..." |
| `bildhinweis` | string | Hinweis zu Bildern | "Die Bild-URLs sind..." |
| `copyright` | string | Copyright-Vermerk | "Daimler Truck AG" |

---

## 3. Truck-Objekt (`katalog.trucks[]`)

### 3.1 Grunddaten

| Key | Typ | Pflicht | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `id` | integer | ✓ | Eindeutige ID | 1 |
| `modell` | string | ✓ | Vollständige Modellbezeichnung | "Mercedes-Benz Actros L 1853 LS ProCabin" |
| `baureihe` | string | ✓ | Baureihe | "Actros L" |
| `kategorie` | string | ✓ | Einsatzkategorie | "Fernverkehr" |
| `bild_url` | string (URI) | ✓ | URL zum Produktbild | "https://..." |
| `kurzbeschreibung` | string | ✓ | Kurze Beschreibung (1-2 Sätze) | "Das Flaggschiff..." |
| `preis_ab_eur` | integer | ✓ | Einstiegspreis in EUR | 189500 |

### 3.2 Textinhalte

| Key | Typ | Pflicht | Beschreibung | Länge |
|-----|-----|---------|--------------|-------|
| `marketing_text_lang` | string | ✓ | Langer Marketingtext | 300+ Wörter |
| `marketing_text_mittel` | string | ✓ | Mittlerer Marketingtext | ~150 Wörter |
| `ausstattung_highlights` | array[string] | ✓ | Ausstattungsmerkmale | ~8 Einträge |

### 3.3 Erlaubte Werte für `baureihe`

```
"Actros L" | "Actros F" | "eActros" | "Arocs" | "eArocs" | 
"Atego" | "Econic" | "eEconic" | "Unimog" | "Zetros" | 
"Actros SLT" | "Arocs SLT"
```

---

## 4. Technische Daten (`katalog.trucks[].technische_daten`)

> **Hinweis:** Nicht alle Felder sind für jeden Fahrzeugtyp relevant. 
> Diesel-Fahrzeuge haben andere Felder als Elektro-Fahrzeuge.

### 4.1 Motor & Antrieb (Diesel/Gas)

| Key | Typ | Einheit | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `motor` | string | - | Motorbezeichnung mit Norm | "OM 471 Euro VI-E" |
| `hubraum_l` | float | Liter | Hubraum | 12.8 |
| `leistung_ps` | integer | PS | Motorleistung | 530 |
| `leistung_kw` | integer | kW | Motorleistung | 390 |
| `drehmoment_nm` | integer | Nm | Max. Drehmoment | 2600 |
| `abgasnorm` | string | - | Abgasnorm | "Euro VI-E" |

### 4.2 Elektro-Antrieb

| Key | Typ | Einheit | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `antrieb` | string | - | Art des E-Antriebs | "Elektrisch (2 Elektromotoren)" |
| `dauerleistung_kw` | integer | kW | Dauerleistung | 400 |
| `spitzenleistung_kw` | integer | kW | Spitzenleistung | 600 |
| `spitzenleistung_ps` | integer | PS | Spitzenleistung | 816 |
| `batteriekapazitaet_kwh` | integer | kWh | Batteriekapazität | 621 |
| `batterietyp` | string | - | Batterietechnologie | "LFP" |
| `reichweite_km` | integer | km | Elektrische Reichweite | 500 |
| `ladeleistung_max_kw` | integer | kW | Max. Ladeleistung | 400 |
| `bordspannung_v` | integer | V | Bordspannung | 800 |

### 4.3 Alternative Kraftstoffe (CNG/LNG)

| Key | Typ | Einheit | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `kraftstoff` | string | - | Kraftstoffart | "LNG (Liquefied Natural Gas)" |
| `tankvolumen_kg` | integer | kg | Tankinhalt (Gas) | 80 |

### 4.4 Getriebe & Fahrwerk

| Key | Typ | Einheit | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `getriebe` | string | - | Getriebetyp | "Mercedes PowerShift 3 (12-Gang)" |
| `antriebsformel` | string | - | Achskonfiguration | "4x2", "6x4", "8x8 permanent" |

### 4.5 Masse & Gewichte

| Key | Typ | Einheit | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `gesamtgewicht_t` | integer | t | Zul. Gesamtgewicht | 40 |
| `zuggesamtgewicht_t` | integer | t | Zul. Zuggesamtgewicht | 250 |
| `nutzlast_t` | integer | t | Nutzlast | 22 |
| `hinterachse_t` | integer | t | Hinterachslast | 10 |
| `leergewicht_reduzierung_kg` | integer | kg | Gewichtsersparnis (Leichtbau) | 350 |

### 4.6 Abmessungen

| Key | Typ | Einheit | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `radstand_mm` | integer | mm | Radstand | 3700 |
| `bodenfreiheit_mm` | integer | mm | Bodenfreiheit | 400 |
| `wattiefe_mm` | integer | mm | Wattiefe | 800 |
| `einstiegshoehe_mm` | integer | mm | Einstiegshöhe | 380 |
| `sattelhoehe_mm` | integer | mm | Sattelhöhe | 950 |
| `lichte_hoehe_m` | float | m | Lichte Ladehöhe | 3.0 |
| `ladeflaeche_m` | float | m | Ladeflächenlänge | 7.2 |
| `kipper_volumen_m3` | integer | m³ | Kippervolumen | 5 |

### 4.7 Fahrerhaus

| Key | Typ | Beschreibung | Erlaubte Werte |
|-----|-----|--------------|----------------|
| `fahrerhaustyp` | string | Typ des Fahrerhauses | siehe unten |

**Erlaubte Werte für `fahrerhaustyp`:**
```
"GigaSpace ProCabin" | "GigaSpace" | "GigaSpace Edition" | 
"BigSpace" | "BigSpace Loader" | "StreamSpace" | "StreamSpace Volumer" |
"ClassicSpace" | "CompactSpace" | "M-Fahrerhaus" | 
"S-Fahrerhaus" | "S-Fahrerhaus kurz"
```

### 4.8 Verbrauch & Tank

| Key | Typ | Einheit | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `tankvolumen_l` | integer | l | Tankvolumen | 900 |
| `verbrauch_l_100km` | float | l/100km | Durchschnittsverbrauch | 24.5 |
| `hoechstgeschwindigkeit_kmh` | integer | km/h | Höchstgeschwindigkeit | 89 |

### 4.9 Gelände-Eigenschaften

| Key | Typ | Einheit | Beschreibung | Beispiel |
|-----|-----|---------|--------------|----------|
| `steigfaehigkeit_prozent` | integer | % | Max. Steigfähigkeit | 100 |
| `kriechgang` | string | - | Min. Kriechgeschwindigkeit | "0.04 km/h" |

### 4.10 Sonstiges

| Key | Typ | Beschreibung | Beispiel |
|-----|-----|--------------|----------|
| `nebenantrieb` | boolean | Nebenantrieb vorhanden | true |
| `bereifung` | string | Bereifungsart | "Singlebereifung hinten" |

---

## 5. Fahrzeugtyp-spezifische Felder

### Diesel-Fahrzeuge
Nutzen primär: `motor`, `hubraum_l`, `leistung_ps`, `leistung_kw`, `drehmoment_nm`, `abgasnorm`, `tankvolumen_l`, `verbrauch_l_100km`

### Elektro-Fahrzeuge  
Nutzen primär: `antrieb`, `dauerleistung_kw`, `spitzenleistung_kw`, `batteriekapazitaet_kwh`, `batterietyp`, `reichweite_km`, `ladeleistung_max_kw`, `bordspannung_v`

### Gas-Fahrzeuge (CNG/LNG)
Nutzen zusätzlich: `kraftstoff`, `tankvolumen_kg`, `reichweite_km`

### Geländefahrzeuge
Nutzen zusätzlich: `bodenfreiheit_mm`, `wattiefe_mm`, `steigfaehigkeit_prozent`, `kriechgang`

### Low-Entry (Econic)
Nutzen zusätzlich: `einstiegshoehe_mm`

### Sattelzugmaschinen
Nutzen zusätzlich: `sattelhoehe_mm`, `zuggesamtgewicht_t`

---

## 6. Beispiel-Struktur

```json
{
  "katalog": {
    "titel": "Daimler Truck Produktkatalog 2025",
    "unternehmen": "Daimler Truck AG",
    "version": "1.0",
    "erstellungsdatum": "2025-01-15",
    "sprache": "de-DE",
    "trucks": [
      {
        "id": 1,
        "modell": "Mercedes-Benz Actros L 1853 LS ProCabin",
        "baureihe": "Actros L",
        "kategorie": "Fernverkehr",
        "bild_url": "https://images.unsplash.com/photo-xxx",
        "kurzbeschreibung": "Das Flaggschiff im Fernverkehr...",
        "technische_daten": {
          "motor": "OM 471 Euro VI-E",
          "hubraum_l": 12.8,
          "leistung_ps": 530,
          "leistung_kw": 390,
          "drehmoment_nm": 2600,
          "antriebsformel": "4x2",
          "getriebe": "Mercedes PowerShift 3 (12-Gang)",
          "gesamtgewicht_t": 40,
          "fahrerhaustyp": "GigaSpace ProCabin",
          "tankvolumen_l": 900,
          "verbrauch_l_100km": 24.5
        },
        "ausstattung_highlights": [
          "Multimedia Cockpit Interactive 2",
          "Active Brake Assist 6",
          "Predictive Powertrain Control"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros L 1853...",
        "marketing_text_mittel": "Der Actros L 1853 ist...",
        "preis_ab_eur": 189500
      }
    ]
  },
  "metadaten": {
    "anzahl_fahrzeuge": 30,
    "kategorien": ["Fernverkehr", "Baustellenverkehr"],
    "baureihen": ["Actros L", "Arocs"],
    "copyright": "Daimler Truck AG"
  }
}
```

---

## 7. Validierung

Das JSON-Schema kann zur Validierung verwendet werden:

```bash
# Mit Python jsonschema
pip install jsonschema
python -c "
import json
from jsonschema import validate

with open('daimler_truck_katalog_schema.json') as f:
    schema = json.load(f)
with open('daimler_truck_katalog_final.json') as f:
    data = json.load(f)

validate(instance=data, schema=schema)
print('✓ JSON ist valide!')
"
```

---

## Legende

| Symbol | Bedeutung |
|--------|-----------|
| ✓ | Pflichtfeld |
| ○ | Optionales Feld |
| string | Textfeld |
| integer | Ganzzahl |
| float | Dezimalzahl |
| boolean | Wahrheitswert (true/false) |
| array | Liste/Array |

---

*Dokumentation erstellt am: 2025-01-15*  
*Schema Version: 1.0*
</file>

<file path="daimler_truck_katalog_schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://daimler-truck.com/schemas/katalog/v1.0",
  "title": "Daimler Truck Produktkatalog Schema",
  "description": "JSON-Schema für den Daimler Truck Produktkatalog mit vollständiger Definition aller Fahrzeugdaten",
  "type": "object",
  "required": ["katalog", "metadaten"],
  
  "properties": {
    "katalog": {
      "type": "object",
      "description": "Hauptcontainer für den Produktkatalog",
      "required": ["titel", "unternehmen", "version", "trucks"],
      "properties": {
        "titel": {
          "type": "string",
          "description": "Titel des Katalogs",
          "example": "Daimler Truck Produktkatalog 2025"
        },
        "unternehmen": {
          "type": "string",
          "description": "Name des Unternehmens",
          "example": "Daimler Truck AG"
        },
        "version": {
          "type": "string",
          "description": "Versionsnummer des Katalogs",
          "pattern": "^\\d+\\.\\d+$",
          "example": "1.0"
        },
        "erstellungsdatum": {
          "type": "string",
          "format": "date",
          "description": "Erstellungsdatum des Katalogs (YYYY-MM-DD)",
          "example": "2025-01-15"
        },
        "sprache": {
          "type": "string",
          "description": "Sprache des Katalogs (BCP 47 Format)",
          "pattern": "^[a-z]{2}-[A-Z]{2}$",
          "example": "de-DE"
        },
        "trucks": {
          "type": "array",
          "description": "Array aller Fahrzeuge im Katalog",
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/truck"
          }
        }
      }
    },
    
    "metadaten": {
      "type": "object",
      "description": "Metadaten und Zusatzinformationen zum Katalog",
      "properties": {
        "anzahl_fahrzeuge": {
          "type": "integer",
          "description": "Gesamtanzahl der Fahrzeuge im Katalog",
          "minimum": 0
        },
        "kategorien": {
          "type": "array",
          "description": "Liste aller verwendeten Fahrzeugkategorien",
          "items": { "type": "string" }
        },
        "baureihen": {
          "type": "array",
          "description": "Liste aller enthaltenen Baureihen",
          "items": { "type": "string" }
        },
        "hinweis": {
          "type": "string",
          "description": "Allgemeiner Hinweis zum Katalog"
        },
        "bildhinweis": {
          "type": "string",
          "description": "Hinweis zu den verwendeten Bildern"
        },
        "copyright": {
          "type": "string",
          "description": "Copyright-Vermerk"
        }
      }
    }
  },
  
  "definitions": {
    "truck": {
      "type": "object",
      "description": "Vollständige Definition eines Fahrzeugs",
      "required": [
        "id",
        "modell",
        "baureihe",
        "kategorie",
        "bild_url",
        "kurzbeschreibung",
        "technische_daten",
        "ausstattung_highlights",
        "marketing_text_lang",
        "marketing_text_mittel",
        "preis_ab_eur"
      ],
      "properties": {
        "id": {
          "type": "integer",
          "description": "Eindeutige ID des Fahrzeugs",
          "minimum": 1,
          "example": 1
        },
        "modell": {
          "type": "string",
          "description": "Vollständige Modellbezeichnung",
          "example": "Mercedes-Benz Actros L 1853 LS ProCabin"
        },
        "baureihe": {
          "type": "string",
          "description": "Baureihe des Fahrzeugs",
          "enum": [
            "Actros L",
            "Actros F",
            "eActros",
            "Arocs",
            "eArocs",
            "Atego",
            "Econic",
            "eEconic",
            "Unimog",
            "Zetros",
            "Actros SLT",
            "Arocs SLT"
          ],
          "example": "Actros L"
        },
        "kategorie": {
          "type": "string",
          "description": "Einsatzkategorie des Fahrzeugs",
          "example": "Fernverkehr"
        },
        "bild_url": {
          "type": "string",
          "format": "uri",
          "description": "URL zum Produktbild",
          "example": "https://images.unsplash.com/photo-1601584115197-04ecc0da31d7?w=800&h=600&fit=crop"
        },
        "kurzbeschreibung": {
          "type": "string",
          "description": "Kurze Beschreibung des Fahrzeugs (1-2 Sätze)",
          "maxLength": 200,
          "example": "Das Flaggschiff im Fernverkehr – maximale Effizienz trifft auf Premium-Komfort."
        },
        "technische_daten": {
          "$ref": "#/definitions/technische_daten"
        },
        "ausstattung_highlights": {
          "type": "array",
          "description": "Liste der wichtigsten Ausstattungsmerkmale",
          "minItems": 1,
          "items": { "type": "string" },
          "example": ["Multimedia Cockpit Interactive 2", "Active Brake Assist 6"]
        },
        "marketing_text_lang": {
          "type": "string",
          "description": "Langer Marketingtext (300+ Wörter)",
          "minLength": 500
        },
        "marketing_text_mittel": {
          "type": "string",
          "description": "Mittlerer Marketingtext (ca. 150 Wörter)",
          "minLength": 200,
          "maxLength": 1500
        },
        "preis_ab_eur": {
          "type": "integer",
          "description": "Einstiegspreis in Euro",
          "minimum": 0,
          "example": 189500
        }
      }
    },
    
    "technische_daten": {
      "type": "object",
      "description": "Technische Spezifikationen des Fahrzeugs. Nicht alle Felder sind für jeden Fahrzeugtyp relevant.",
      "properties": {
        
        "_comment_motor": "=== MOTOR & ANTRIEB (Diesel/Gas) ===",
        "motor": {
          "type": "string",
          "description": "Motorbezeichnung mit Abgasnorm",
          "example": "OM 471 Euro VI-E"
        },
        "hubraum_l": {
          "type": "number",
          "description": "Hubraum in Litern",
          "minimum": 0,
          "example": 12.8
        },
        "leistung_ps": {
          "type": "integer",
          "description": "Motorleistung in PS",
          "minimum": 0,
          "example": 530
        },
        "leistung_kw": {
          "type": "integer",
          "description": "Motorleistung in kW",
          "minimum": 0,
          "example": 390
        },
        "drehmoment_nm": {
          "type": "integer",
          "description": "Maximales Drehmoment in Nm",
          "minimum": 0,
          "example": 2600
        },
        "abgasnorm": {
          "type": "string",
          "description": "Erfüllte Abgasnorm",
          "enum": ["Euro VI-E", "Euro VI-D", "Euro VI", "Euro III"],
          "example": "Euro VI-E"
        },
        
        "_comment_elektro": "=== ELEKTRO-ANTRIEB ===",
        "antrieb": {
          "type": "string",
          "description": "Art des Antriebs bei E-Fahrzeugen",
          "example": "Elektrisch (2 Elektromotoren)"
        },
        "dauerleistung_kw": {
          "type": "integer",
          "description": "Dauerleistung bei E-Antrieb in kW",
          "minimum": 0,
          "example": 400
        },
        "spitzenleistung_kw": {
          "type": "integer",
          "description": "Spitzenleistung bei E-Antrieb in kW",
          "minimum": 0,
          "example": 600
        },
        "spitzenleistung_ps": {
          "type": "integer",
          "description": "Spitzenleistung bei E-Antrieb in PS",
          "minimum": 0,
          "example": 816
        },
        "batteriekapazitaet_kwh": {
          "type": "integer",
          "description": "Batteriekapazität in kWh",
          "minimum": 0,
          "example": 621
        },
        "batterietyp": {
          "type": "string",
          "description": "Technologie der Batterie",
          "enum": ["LFP (Lithium-Eisenphosphat)", "LFP", "NMC"],
          "example": "LFP (Lithium-Eisenphosphat)"
        },
        "reichweite_km": {
          "type": "integer",
          "description": "Elektrische Reichweite in km",
          "minimum": 0,
          "example": 500
        },
        "ladeleistung_max_kw": {
          "type": "integer",
          "description": "Maximale Ladeleistung in kW",
          "minimum": 0,
          "example": 400
        },
        "bordspannung_v": {
          "type": "integer",
          "description": "Bordspannung bei E-Fahrzeugen in Volt",
          "enum": [400, 800],
          "example": 800
        },
        
        "_comment_alternative": "=== ALTERNATIVE KRAFTSTOFFE ===",
        "kraftstoff": {
          "type": "string",
          "description": "Kraftstoffart bei alternativen Antrieben",
          "enum": ["CNG (Compressed Natural Gas)", "LNG (Liquefied Natural Gas)"],
          "example": "LNG (Liquefied Natural Gas)"
        },
        "tankvolumen_kg": {
          "type": "integer",
          "description": "Tankvolumen in kg (bei Gasantrieb)",
          "minimum": 0,
          "example": 80
        },
        
        "_comment_getriebe": "=== GETRIEBE & FAHRWERK ===",
        "getriebe": {
          "type": "string",
          "description": "Getriebetyp und Ganganzahl",
          "example": "Mercedes PowerShift 3 (12-Gang)"
        },
        "antriebsformel": {
          "type": "string",
          "description": "Achskonfiguration (Antriebsformel)",
          "pattern": "^\\d+x\\d+( permanent)?$",
          "example": "4x2"
        },
        
        "_comment_masse": "=== MASSE & GEWICHTE ===",
        "gesamtgewicht_t": {
          "type": "integer",
          "description": "Zulässiges Gesamtgewicht in Tonnen",
          "minimum": 0,
          "example": 40
        },
        "zuggesamtgewicht_t": {
          "type": "integer",
          "description": "Zulässiges Zuggesamtgewicht in Tonnen",
          "minimum": 0,
          "example": 250
        },
        "nutzlast_t": {
          "type": "integer",
          "description": "Nutzlast in Tonnen",
          "minimum": 0,
          "example": 22
        },
        "hinterachse_t": {
          "type": "integer",
          "description": "Hinterachslast in Tonnen",
          "minimum": 0,
          "example": 10
        },
        "leergewicht_reduzierung_kg": {
          "type": "integer",
          "description": "Leergewichtsreduzierung bei Leichtbau-Varianten in kg",
          "minimum": 0,
          "example": 350
        },
        
        "_comment_abmessungen": "=== ABMESSUNGEN ===",
        "radstand_mm": {
          "type": "integer",
          "description": "Radstand in mm",
          "minimum": 0,
          "example": 3700
        },
        "bodenfreiheit_mm": {
          "type": "integer",
          "description": "Bodenfreiheit in mm",
          "minimum": 0,
          "example": 400
        },
        "wattiefe_mm": {
          "type": "integer",
          "description": "Wattiefe in mm",
          "minimum": 0,
          "example": 800
        },
        "einstiegshoehe_mm": {
          "type": "integer",
          "description": "Einstiegshöhe ins Fahrerhaus in mm",
          "minimum": 0,
          "example": 380
        },
        "sattelhoehe_mm": {
          "type": "integer",
          "description": "Sattelhöhe bei Sattelzugmaschinen in mm",
          "minimum": 0,
          "example": 950
        },
        "lichte_hoehe_m": {
          "type": "number",
          "description": "Lichte Ladehöhe in m",
          "minimum": 0,
          "example": 3.0
        },
        "ladeflaeche_m": {
          "type": "number",
          "description": "Länge der Ladefläche in m",
          "minimum": 0,
          "example": 7.2
        },
        "kipper_volumen_m3": {
          "type": "integer",
          "description": "Kippervolumen in m³",
          "minimum": 0,
          "example": 5
        },
        
        "_comment_fahrerhaus": "=== FAHRERHAUS ===",
        "fahrerhaustyp": {
          "type": "string",
          "description": "Typ des Fahrerhauses",
          "enum": [
            "GigaSpace ProCabin",
            "GigaSpace",
            "GigaSpace Edition",
            "BigSpace",
            "BigSpace Loader",
            "StreamSpace",
            "StreamSpace Volumer",
            "ClassicSpace",
            "CompactSpace",
            "M-Fahrerhaus",
            "S-Fahrerhaus",
            "S-Fahrerhaus kurz"
          ],
          "example": "GigaSpace ProCabin"
        },
        
        "_comment_verbrauch": "=== VERBRAUCH & TANK ===",
        "tankvolumen_l": {
          "type": "integer",
          "description": "Tankvolumen in Litern",
          "minimum": 0,
          "example": 900
        },
        "verbrauch_l_100km": {
          "type": "number",
          "description": "Durchschnittsverbrauch in l/100km",
          "minimum": 0,
          "example": 24.5
        },
        "hoechstgeschwindigkeit_kmh": {
          "type": "integer",
          "description": "Höchstgeschwindigkeit in km/h",
          "minimum": 0,
          "example": 89
        },
        
        "_comment_gelaende": "=== GELÄNDE-EIGENSCHAFTEN ===",
        "steigfaehigkeit_prozent": {
          "type": "integer",
          "description": "Maximale Steigfähigkeit in Prozent",
          "minimum": 0,
          "maximum": 100,
          "example": 100
        },
        "kriechgang": {
          "type": "string",
          "description": "Minimale Kriechgeschwindigkeit",
          "example": "0.04 km/h"
        },
        
        "_comment_sonstiges": "=== SONSTIGES ===",
        "nebenantrieb": {
          "type": "boolean",
          "description": "Nebenantrieb vorhanden (für Aufbauten)",
          "example": true
        },
        "bereifung": {
          "type": "string",
          "description": "Bereifungsart",
          "example": "Singlebereifung hinten"
        }
      }
    }
  }
}
</file>

<file path="dummy-katalog-data.json">
{
  "katalog": {
    "titel": "Daimler Truck Produktkatalog 2025",
    "unternehmen": "Daimler Truck AG",
    "version": "1.0",
    "erstellungsdatum": "2025-01-15",
    "sprache": "de-DE",
    "trucks": [
      {
        "id": 1,
        "modell": "Mercedes-Benz Actros L 1853 LS ProCabin",
        "baureihe": "Actros L",
        "kategorie": "Fernverkehr",
        "bild_url": "https://images.unsplash.com/photo-1601584115197-04ecc0da31d7?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Das Flaggschiff im Fernverkehr – maximale Effizienz trifft auf Premium-Komfort mit der revolutionären ProCabin-Kabine.",
        "technische_daten": {
          "motor": "OM 471 Euro VI-E",
          "hubraum_l": 12.8,
          "leistung_ps": 530,
          "leistung_kw": 390,
          "drehmoment_nm": 2600,
          "antriebsformel": "4x2",
          "getriebe": "Mercedes PowerShift 3 (12-Gang)",
          "gesamtgewicht_t": 40,
          "radstand_mm": 3700,
          "fahrerhaustyp": "GigaSpace ProCabin",
          "tankvolumen_l": 900,
          "verbrauch_l_100km": 24.5,
          "abgasnorm": "Euro VI-E",
          "hoechstgeschwindigkeit_kmh": 89
        },
        "ausstattung_highlights": [
          "Multimedia Cockpit Interactive 2",
          "Active Brake Assist 6",
          "Active Sideguard Assist 2",
          "Predictive Powertrain Control",
          "Active Drive Assist 3 (Level 2)",
          "LED Matrix-Scheinwerfer",
          "Klimaautomatik mit Standheizung",
          "Kühlschrank 40L"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros L 1853 LS ProCabin repräsentiert die absolute Spitze dessen, was moderner Fernverkehr zu bieten hat. Mit der vollständig neu gestalteten ProCabin setzt dieses Fahrzeug neue Maßstäbe in Sachen Aerodynamik, Effizienz und Fahrerkomfort. Die um 80 Millimeter verlängerte Fahrzeugfront ist das Ergebnis intensiver Windkanalforschung und führt zu einer Kraftstoffeinsparung von bis zu drei Prozent gegenüber dem Vorgängermodell.\n\nDas Herzstück des Actros L 1853 ist der bewährte OM 471 Motor der dritten Generation mit 12,8 Litern Hubraum. Mit seinen 530 PS und einem maximalen Drehmoment von 2.600 Nm meistert er selbst anspruchsvollste Streckenprofile mühelos. In Kombination mit dem Mercedes PowerShift 3 Getriebe und der intelligenten Predictive Powertrain Control erreicht der Actros L Verbrauchswerte, die in dieser Leistungsklasse ihresgleichen suchen.\n\nBesonders beeindruckend ist das neue Sicherheitskonzept: Der Active Brake Assist 6 erkennt nicht nur vorausfahrende Fahrzeuge, sondern auch Fußgänger und Radfahrer – und kann im Notfall eine Vollbremsung einleiten. Der Active Sideguard Assist 2 warnt beim Abbiegen vor Objekten im toten Winkel und greift bei Gefahr aktiv in die Bremsung ein. Diese Systeme übertreffen die strengen Anforderungen der EU General Safety Regulation deutlich.\n\nDas Interieur der GigaSpace ProCabin ist ein rollendes Zuhause. Die Stehöhe von über zwei Metern, das durchdachte Stauraumkonzept und die ergonomisch optimierten Bedienelemente machen lange Touren zum Komforterlebnis. Das 12-Zoll-Instrumentendisplay und der verbesserte Touchscreen des Multimedia Cockpit Interactive 2 lassen sich intuitiv bedienen – viele Funktionen sind per Sprachsteuerung erreichbar. Der Active Drive Assist 3 ermöglicht teilautomatisiertes Fahren auf Level 2 und entlastet den Fahrer auf langen Autobahnabschnitten spürbar.\n\nMit dem Actros L 1853 LS ProCabin entscheiden Sie sich für ein Fahrzeug, das Wirtschaftlichkeit und Nachhaltigkeit mit höchstem Fahrerkomfort vereint – ein echtes Premiumprodukt für anspruchsvolle Transportunternehmen.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros L 1853 LS ProCabin definiert den modernen Fernverkehr neu. Mit der aerodynamisch optimierten ProCabin-Kabine erreicht er Kraftstoffeinsparungen von bis zu drei Prozent. Der 530 PS starke OM 471 Motor liefert beeindruckende 2.600 Nm Drehmoment und überzeugt durch vorbildliche Effizienz.\n\nDas Sicherheitspaket mit Active Brake Assist 6 und Active Sideguard Assist 2 übertrifft alle gesetzlichen Anforderungen. Das Multimedia Cockpit Interactive 2 mit Sprachsteuerung und der Active Drive Assist 3 für teilautomatisiertes Fahren entlasten den Fahrer erheblich. Die GigaSpace ProCabin bietet mit über zwei Metern Stehöhe und durchdachtem Raumkonzept höchsten Wohnkomfort für lange Touren. Ein echtes Premium-Flaggschiff für anspruchsvolle Flottenmanager.",
        "preis_ab_eur": 189500
      },
      {
        "id": 2,
        "modell": "Mercedes-Benz Actros L 1848 LS",
        "baureihe": "Actros L",
        "kategorie": "Fernverkehr",
        "bild_url": "https://images.unsplash.com/photo-1586191582066-71c6bb4e6ec6?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Der vielseitige Allrounder im Fernverkehr – optimale Balance zwischen Leistung und Wirtschaftlichkeit.",
        "technische_daten": {
          "motor": "OM 471 Euro VI-E",
          "hubraum_l": 12.8,
          "leistung_ps": 480,
          "leistung_kw": 353,
          "drehmoment_nm": 2400,
          "antriebsformel": "4x2",
          "getriebe": "Mercedes PowerShift 3 (12-Gang)",
          "gesamtgewicht_t": 40,
          "radstand_mm": 3700,
          "fahrerhaustyp": "BigSpace",
          "tankvolumen_l": 800,
          "verbrauch_l_100km": 25.2,
          "abgasnorm": "Euro VI-E",
          "hoechstgeschwindigkeit_kmh": 89
        },
        "ausstattung_highlights": [
          "Multimedia Cockpit Interactive 2",
          "Active Brake Assist 5",
          "Spurhalteassistent",
          "Predictive Powertrain Control",
          "LED-Hauptscheinwerfer",
          "Tempomat mit Limiter",
          "Klimaanlage",
          "Standheizung"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros L 1848 LS ist die perfekte Wahl für Transportunternehmen, die einen zuverlässigen und wirtschaftlichen Partner für den Fernverkehr suchen. Mit 480 PS bietet er ausreichend Kraftreserven für alle gängigen Transportaufgaben in Europa, während sein optimierter Verbrauch die Betriebskosten im Rahmen hält.\n\nDer OM 471 Motor der dritten Generation ist speziell auf kraftstoffsparendes Fahren ausgelegt. In Verbindung mit dem Mercedes PowerShift 3 Getriebe und der Predictive Powertrain Control passt sich der Antriebsstrang automatisch an das Streckenprofil an. Das System nutzt GPS-Daten und Topographieinformationen, um Schaltvorgänge und Geschwindigkeit vorausschauend zu optimieren – für maximale Effizienz auf jeder Route.\n\nDie BigSpace-Kabine bietet dem Fahrer einen komfortablen Arbeits- und Lebensraum. Mit einer Innenhöhe von 1,98 Metern und einem durchdachten Stauraumkonzept ist sie ideal für mehrtägige Touren geeignet. Das Multimedia Cockpit Interactive 2 fungiert als zentrale Kommandozentrale und ermöglicht die Steuerung aller wichtigen Funktionen per Touchscreen oder Sprachbefehl.\n\nBei der Sicherheit setzt der Actros L 1848 auf bewährte Mercedes-Benz Technologie: Der Active Brake Assist 5 erkennt vorausfahrende Fahrzeuge und kann bei Gefahr automatisch bremsen. Der Spurhalteassistent warnt bei unbeabsichtigtem Verlassen der Fahrspur und korrigiert sanft die Lenkung. Müdigkeitswarnsysteme überwachen das Fahrerverhalten und empfehlen rechtzeitig Pausen.\n\nDer Actros L 1848 LS ist das ideale Fahrzeug für Flottenbetreiber, die Zuverlässigkeit, moderate Anschaffungskosten und niedrige Betriebskosten in einem bewährten Premiumfahrzeug vereint wissen wollen. Mit seinem ausgewogenen Gesamtpaket ist er ein echter Kilometerfresser, der Tag für Tag zuverlässig seine Arbeit verrichtet.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros L 1848 LS vereint Wirtschaftlichkeit und Zuverlässigkeit auf höchstem Niveau. Mit 480 PS und dem kraftstoffoptimierten OM 471 Motor bietet er die ideale Balance für den täglichen Fernverkehr. Die Predictive Powertrain Control sorgt automatisch für effizientes Fahren.\n\nDie komfortable BigSpace-Kabine mit knapp zwei Metern Innenhöhe macht mehrtägige Touren zum Vergnügen. Das Multimedia Cockpit Interactive 2 bietet intuitive Bedienung per Touch oder Sprache. Sicherheitssysteme wie der Active Brake Assist 5 und der Spurhalteassistent schützen Fahrer und andere Verkehrsteilnehmer. Ein ausgewogenes Gesamtpaket für anspruchsvolle Flottenbetreiber.",
        "preis_ab_eur": 159800
      },
      {
        "id": 3,
        "modell": "Mercedes-Benz Actros L 1863 LS",
        "baureihe": "Actros L",
        "kategorie": "Fernverkehr/Schwerlast",
        "bild_url": "https://images.unsplash.com/photo-1519003722824-194d4455a60c?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Die Kraft der Superlative – unser leistungsstärkstes Fernverkehrsfahrzeug für maximale Performance.",
        "technische_daten": {
          "motor": "OM 473 Euro VI-E",
          "hubraum_l": 15.6,
          "leistung_ps": 625,
          "leistung_kw": 460,
          "drehmoment_nm": 3000,
          "antriebsformel": "4x2",
          "getriebe": "Mercedes PowerShift 3 (12-Gang)",
          "gesamtgewicht_t": 44,
          "radstand_mm": 3700,
          "fahrerhaustyp": "GigaSpace",
          "tankvolumen_l": 1000,
          "verbrauch_l_100km": 28.5,
          "abgasnorm": "Euro VI-E",
          "hoechstgeschwindigkeit_kmh": 89
        },
        "ausstattung_highlights": [
          "Turbo-Retarder-Kupplung",
          "High Performance Engine Brake",
          "Multimedia Cockpit Interactive 2",
          "Active Brake Assist 6",
          "Active Drive Assist 3",
          "Luftfederung vorne und hinten",
          "Premium-Fahrersitz mit Massage",
          "Freisprechanlage mit Bluetooth"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros L 1863 LS ist das Kraftpaket für besondere Herausforderungen. Mit seinem monumentalen OM 473 Motor und 625 PS Leistung bewältigt er selbst die anspruchsvollsten Streckenprofile souverän. Das gewaltige Drehmoment von 3.000 Nm steht bereits bei niedrigen Drehzahlen zur Verfügung und garantiert mühelose Bergfahrten mit voller Beladung.\n\nBesonders bei Fahrten über die Alpen oder durch skandinavische Gebirgslandschaften zeigt der 1863 seine wahren Stärken. Die Turbo-Retarder-Kupplung kombiniert eine verschleißfreie Anfahrkupplung mit einem integrierten Retarder. Zusammen mit der High Performance Engine Brake erreicht das System eine Bremsleistung von bis zu 750 kW – genug, um selbst bei voller Beladung lange Gefällestrecken ohne Betriebsbremse zu bewältigen.\n\nDie GigaSpace-Kabine bietet dem Fahrer eines Hochleistungsfahrzeugs den Komfort, den er verdient. Der Premium-Fahrersitz mit Massagefunktion und individuell einstellbarer Klimatisierung macht auch anstrengende Etappen erträglich. Das durchdachte Belüftungssystem mit Klimaautomatik sorgt für optimales Raumklima bei jeder Außentemperatur.\n\nDer Active Drive Assist 3 ermöglicht teilautomatisiertes Fahren und hält das Fahrzeug in der Spur, während er automatisch Abstand zum Vordermann hält. In Kombination mit dem Active Brake Assist 6 und dem Active Sideguard Assist 2 entsteht ein umfassendes Sicherheitsnetz, das den Fahrer bei seiner anspruchsvollen Aufgabe optimal unterstützt.\n\nDie Luftfederung an Vorder- und Hinterachse sorgt für überlegenen Fahrkomfort und schont gleichzeitig die Ladung. Das adaptive Dämpfungssystem passt die Fahrwerkcharakteristik automatisch an die aktuelle Straßensituation an. Für Transportunternehmen mit besonders anspruchsvollen Routen ist der Actros L 1863 LS die erste Wahl.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros L 1863 LS ist unser leistungsstärkstes Fernverkehrsfahrzeug. Mit 625 PS und 3.000 Nm Drehmoment aus dem OM 473 Motor meistert er selbst extreme Steigungen mühelos. Die Turbo-Retarder-Kupplung und High Performance Engine Brake liefern bis zu 750 kW Bremsleistung.\n\nDie GigaSpace-Kabine mit Premium-Fahrersitz und Massagefunktion bietet höchsten Komfort. Der Active Drive Assist 3 ermöglicht teilautomatisiertes Fahren. Die Vollluftfederung sorgt für überlegenen Fahrkomfort bei jeder Beladung. Das ideale Fahrzeug für Alpentransit und anspruchsvolle internationale Routen.",
        "preis_ab_eur": 218900
      },
      {
        "id": 4,
        "modell": "Mercedes-Benz Actros L Edition 3",
        "baureihe": "Actros L",
        "kategorie": "Fernverkehr/Sondermodell",
        "bild_url": "https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Streng limitiert auf 400 Exemplare – das exklusivste Fahrerlebnis im Fernverkehr mit einzigartigen Design-Features.",
        "technische_daten": {
          "motor": "OM 471 Euro VI-E",
          "hubraum_l": 12.8,
          "leistung_ps": 530,
          "leistung_kw": 390,
          "drehmoment_nm": 2600,
          "antriebsformel": "4x2",
          "getriebe": "Mercedes PowerShift 3 (12-Gang)",
          "gesamtgewicht_t": 40,
          "fahrerhaustyp": "GigaSpace Edition",
          "tankvolumen_l": 900
        },
        "ausstattung_highlights": [
          "Exklusive Außenlackierung Weißaluminium Metallic",
          "Mercedes-Stern in Dark-Chrome",
          "LED-Bars in Sonnenblende",
          "Edelstahl-Zierteile",
          "Leder-Interieur mit Edition-Stickerei",
          "Exklusives Nummerierungsschild"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros L Edition 3 ist weit mehr als ein Lkw – er ist ein Statement. Streng limitiert auf nur 400 Exemplare weltweit, vereint dieses Sondermodell das Beste aus drei erfolgreichen Vorgänger-Editionen mit völlig neuen, exklusiven Designelementen. Jedes Fahrzeug trägt ein individuelles Nummerierungsschild, das seinen einzigartigen Status dokumentiert.\n\nSchon aus der Ferne fällt die markante Erscheinung auf: Die Außenlackierung in edlem Weißaluminium Metallic erstreckt sich über eine perfekt verarbeitete Karosserie. Die Fahrzeugfront mit den Edelstahl-Zierelementen und dem Mercedes-Stern in exklusivem Dark-Chrome zieht alle Blicke auf sich. Die in die Sonnenblende integrierten LED-Bars setzen auch bei Nacht ein unverwechselbares Zeichen.\n\nDas Interieur der Edition 3 ist ein Fest für die Sinne. Hochwertiges Leder mit präziser Edition-Stickerei kleidet Sitze und Verkleidungen aus. Die Materialauswahl und Verarbeitungsqualität orientieren sich an den strengsten Standards der Automobilindustrie. Jedes Detail wurde mit höchster Sorgfalt ausgewählt – von den Aluminium-Pedalen bis zu den beleuchteten Einstiegsleisten mit Edition-3-Schriftzug.\n\nTechnisch steht die Edition 3 auf dem Fundament des bewährten Actros L 1853. Der effiziente OM 471 Motor mit 530 PS und die Predictive Powertrain Control sorgen für vorbildliche Wirtschaftlichkeit. Alle Premium-Sicherheitssysteme wie Active Brake Assist 6, Active Sideguard Assist 2 und Active Drive Assist 3 sind serienmäßig an Bord.\n\nDie Edition 3 richtet sich an Fahrer und Unternehmer, für die ein Lkw mehr ist als nur ein Arbeitsmittel. Sie verkörpert die Leidenschaft für das Fahren und den Stolz auf einen der schönsten Arbeitsplätze der Welt. Ein echtes Sammlerstück für Kenner.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros L Edition 3 ist ein echtes Sammlerstück – streng limitiert auf 400 Exemplare weltweit. Die exklusive Außenlackierung in Weißaluminium Metallic, der Mercedes-Stern in Dark-Chrome und die LED-Bars in der Sonnenblende setzen unverwechselbare Akzente.\n\nDas Leder-Interieur mit Edition-Stickerei und Aluminium-Pedalen bietet höchsten Luxus. Technisch basiert die Edition 3 auf dem bewährten Actros L 1853 mit 530 PS und allen Premium-Sicherheitssystemen. Jedes Fahrzeug trägt ein individuelles Nummerierungsschild. Für Fahrer, die mehr als nur ein Arbeitsmittel suchen.",
        "preis_ab_eur": 245000
      },
      {
        "id": 5,
        "modell": "Mercedes-Benz Actros F 1845",
        "baureihe": "Actros F",
        "kategorie": "Fernverkehr/Einstieg",
        "bild_url": "https://images.unsplash.com/photo-1580674684081-7617fbf3d745?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Der funktionale Einstieg in die Actros-Welt – bewährte Technik zum attraktiven Preis.",
        "technische_daten": {
          "motor": "OM 471 Euro VI-E",
          "hubraum_l": 12.8,
          "leistung_ps": 449,
          "leistung_kw": 330,
          "drehmoment_nm": 2200,
          "antriebsformel": "4x2",
          "getriebe": "Mercedes PowerShift 3 (12-Gang)",
          "gesamtgewicht_t": 40,
          "fahrerhaustyp": "StreamSpace",
          "tankvolumen_l": 700
        },
        "ausstattung_highlights": [
          "Classic Cockpit",
          "Active Brake Assist 5",
          "Klassische Außenspiegel",
          "Klimaanlage",
          "Standheizung",
          "Radio mit Bluetooth"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros F 1845 macht den Einstieg in die Welt des Actros so zugänglich wie nie zuvor. Als funktionsorientiertes Modell konzentriert er sich auf das Wesentliche: bewährte Mercedes-Benz Technik, solide Verarbeitung und ein überzeugendes Preis-Leistungs-Verhältnis. Für Unternehmer, die auf das typische Actros-Erlebnis nicht verzichten möchten, aber nicht jede Innovation der neuesten Generation benötigen.\n\nDer OM 471 Motor mit 449 PS bietet ausreichend Leistungsreserven für den Standard-Fernverkehr in Europa. Die Kombination mit dem Mercedes PowerShift 3 Getriebe sorgt für komfortables und effizientes Fahren. Das Fahrzeug ist auf zuverlässigen Dauereinsatz ausgelegt und profitiert von der jahrzehntelangen Erfahrung von Mercedes-Benz im Nutzfahrzeugbau.\n\nDas StreamSpace-Fahrerhaus bietet einen funktionalen Arbeitsplatz mit ausreichend Platz für längere Touren. Das Classic Cockpit mit analogen Rundinstrumenten ist übersichtlich gestaltet und leicht zu bedienen. Die klassischen Außenspiegel bieten exzellente Sicht und sind im Service einfach zu ersetzen – ein Kostenvorteil im täglichen Betrieb.\n\nBei der Sicherheit macht der Actros F keine Kompromisse: Der Active Brake Assist 5 ist serienmäßig an Bord und erkennt vorausfahrende Fahrzeuge zuverlässig. Spurhaltewarner und Müdigkeitserkennung unterstützen den Fahrer zusätzlich.\n\nMit dem Actros F 1845 bietet Mercedes-Benz eine ehrliche Alternative für preisbewusste Unternehmer, die auf Mercedes-Qualität vertrauen.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros F 1845 ist der funktionale Einstieg in die Actros-Familie. Mit 449 PS und dem bewährten OM 471 Motor bietet er solide Leistung für den europäischen Fernverkehr. Das StreamSpace-Fahrerhaus mit Classic Cockpit konzentriert sich auf das Wesentliche.\n\nDie klassischen Außenspiegel sind robust und servicefreundlich. Der Active Brake Assist 5 sorgt für hohe Sicherheit. Die elektronische Luftfederung hinten passt sich automatisch der Beladung an. Ideal für preisbewusste Unternehmer, die auf bewährte Mercedes-Qualität nicht verzichten möchten.",
        "preis_ab_eur": 134500
      },
      {
        "id": 6,
        "modell": "Mercedes-Benz eActros 600",
        "baureihe": "eActros",
        "kategorie": "Fernverkehr/Elektro",
        "bild_url": "https://images.unsplash.com/photo-1593941707882-a5bba14938c7?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Die Zukunft des Fernverkehrs ist elektrisch – 500 km Reichweite und 600 kW Spitzenleistung für emissionsfreien Gütertransport.",
        "technische_daten": {
          "antrieb": "Elektrisch (2 Elektromotoren)",
          "dauerleistung_kw": 400,
          "spitzenleistung_kw": 600,
          "spitzenleistung_ps": 816,
          "drehmoment_nm": 2100,
          "batteriekapazitaet_kwh": 621,
          "batterietyp": "LFP (Lithium-Eisenphosphat)",
          "reichweite_km": 500,
          "ladeleistung_max_kw": 400,
          "antriebsformel": "4x2",
          "getriebe": "4-Gang Elektrogetriebe",
          "gesamtgewicht_t": 44,
          "nutzlast_t": 22,
          "bordspannung_v": 800
        },
        "ausstattung_highlights": [
          "800V E-Antriebsachse",
          "Drei LFP-Batteriepakete à 207 kWh",
          "CCS2-Schnellladen bis 400 kW",
          "MCS-Vorbereitung für 1 MW Laden",
          "ProCabin Fahrerhaus",
          "Active Brake Assist 6",
          "Fünf Rekuperationsstufen"
        ],
        "marketing_text_lang": "Der Mercedes-Benz eActros 600 markiert den Beginn einer neuen Ära im schweren Güterverkehr. Als erster batterieelektrischer Fernverkehrs-Lkw mit Stern ist er für Zuggewichte bis 44 Tonnen und Tagesfahrleistungen von über 1.000 Kilometern konzipiert. Mit einer Reichweite von 500 Kilometern ohne Zwischenladung und blitzschnellem CCS2-Laden mit bis zu 400 kW macht er den Umstieg auf emissionsfreien Transport wirtschaftlich attraktiv.\n\nDas technische Herzstück ist die selbst entwickelte 800-Volt-E-Antriebsachse mit zwei integrierten Elektromotoren. Die Dauerleistung von 400 kW und eine Spitzenleistung von beeindruckenden 600 kW (816 PS) garantieren souveränes Fortkommen auch bei voller Beladung und in anspruchsvollem Gelände. Das speziell entwickelte 4-Gang-Elektrogetriebe optimiert die Effizienz über den gesamten Geschwindigkeitsbereich.\n\nDrei Batteriepakete mit LFP-Technologie (Lithium-Eisenphosphat) und einer Gesamtkapazität von 621 kWh speichern die Energie für lange Etappen. Die LFP-Chemie zeichnet sich durch hohe Langlebigkeit aus – nach zehn Jahren und 1,2 Millionen Kilometern soll der Batteriezustand noch über 80 Prozent betragen.\n\nDie fünf Rekuperationsstufen ermöglichen die Anpassung der Energierückgewinnung an Fahrweise und Streckenprofil. Die puristische ProCabin wurde aerodynamisch optimiert und verleiht dem eActros 600 sein unverwechselbares Erscheinungsbild. Mit dem eActros 600 beginnt die elektrische Transformation des Fernverkehrs.",
        "marketing_text_mittel": "Der Mercedes-Benz eActros 600 ist der erste batterieelektrische Fernverkehrs-Lkw von Mercedes-Benz. Mit 500 km Reichweite, 621 kWh LFP-Batteriekapazität und 600 kW Spitzenleistung ist er für den harten Logistikalltag konzipiert. CCS2-Laden mit bis zu 400 kW ermöglicht schnelles Nachladen während der Lenkpausen.\n\nDie selbst entwickelte 800V-E-Antriebsachse garantiert souveräne Leistung bis 44 Tonnen Gesamtgewicht. Fünf Rekuperationsstufen maximieren die Energierückgewinnung. Die aerodynamische ProCabin reduziert den Luftwiderstand um neun Prozent. Der eActros 600 macht emissionsfreien Fernverkehr wirtschaftlich.",
        "preis_ab_eur": 286300
      },
      {
        "id": 7,
        "modell": "Mercedes-Benz eActros 400",
        "baureihe": "eActros",
        "kategorie": "Verteilerverkehr/Elektro",
        "bild_url": "https://images.unsplash.com/photo-1558618047-3c8c76ca7d13?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Elektrischer Verteilerverkehr auf höchstem Niveau – leise, sauber und effizient in urbanen Gebieten.",
        "technische_daten": {
          "antrieb": "Elektrisch",
          "dauerleistung_kw": 330,
          "spitzenleistung_kw": 400,
          "batteriekapazitaet_kwh": 420,
          "reichweite_km": 400,
          "ladeleistung_max_kw": 160,
          "gesamtgewicht_t": 27,
          "fahrerhaustyp": "M-Fahrerhaus"
        },
        "ausstattung_highlights": [
          "Vier NMC-Batteriepakete",
          "AC- und DC-Laden",
          "Kabinenheizung elektrisch",
          "Active Brake Assist 5",
          "Rekuperationsbremse",
          "Wärmepumpe"
        ],
        "marketing_text_lang": "Der Mercedes-Benz eActros 400 ist die Speerspitze des elektrischen Verteilerverkehrs. Mit einer Reichweite von 400 Kilometern und einem zulässigen Gesamtgewicht von 27 Tonnen deckt er ein breites Spektrum von Anwendungen ab – von der Belieferung innerstädtischer Geschäfte bis zum regionalen Warenumschlag. Dabei fährt er lokal emissionsfrei und nahezu geräuschlos durch urbane Gebiete.\n\nVier Batteriepakete mit NMC-Technologie und einer Gesamtkapazität von 420 kWh versorgen den Elektromotor mit Energie. Die Dauerleistung von 330 kW reicht für alle typischen Verteileraufgaben mehr als aus, während die Spitzenleistung von 400 kW auch bei voller Beladung zügiges Vorankommen garantiert.\n\nDas Laden ist flexibel gestaltet: Über Nacht kann der eActros 400 an der Depot-Wechselstromstation geladen werden, unterwegs ermöglichen DC-Schnellladesäulen das schnelle Nachladen. Mit maximal 160 kW Ladeleistung ist die Batterie in überschaubarer Zeit wieder einsatzbereit.\n\nDas kompakte M-Fahrerhaus ist ideal für den Stop-and-Go-Betrieb im Verteilerverkehr. Der Active Brake Assist 5 und der Abbiege-Assistent sorgen für maximale Sicherheit im komplexen Stadtverkehr.",
        "marketing_text_mittel": "Der Mercedes-Benz eActros 400 definiert elektrischen Verteilerverkehr neu. Mit 400 km Reichweite und 420 kWh Batteriekapazität meistert er den urbanen Lieferalltag souverän. Die 400 kW Spitzenleistung garantiert auch bei voller Beladung zügiges Vorankommen.\n\nDC-Schnellladen mit bis zu 160 kW ermöglicht kurze Ladezeiten. Das kompakte M-Fahrerhaus ist ideal für Stop-and-Go. Die Wärmepumpen-Klimatisierung schont die Reichweite bei kalten Temperaturen. Ideal für nachhaltige City-Logistik.",
        "preis_ab_eur": 242000
      },
      {
        "id": 8,
        "modell": "Mercedes-Benz Arocs 3251 K 8x4",
        "baureihe": "Arocs",
        "kategorie": "Baustellenverkehr",
        "bild_url": "https://images.unsplash.com/photo-1567789884554-0b844b597180?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Der robuste Kraftprotz für schwere Baustelleneinsätze – maximale Tragfähigkeit und unerschütterliche Zuverlässigkeit.",
        "technische_daten": {
          "motor": "OM 471 Euro VI-E",
          "hubraum_l": 12.8,
          "leistung_ps": 510,
          "leistung_kw": 375,
          "drehmoment_nm": 2500,
          "antriebsformel": "8x4",
          "getriebe": "Mercedes PowerShift 3 (12-Gang)",
          "gesamtgewicht_t": 41,
          "fahrerhaustyp": "ClassicSpace",
          "nebenantrieb": true
        },
        "ausstattung_highlights": [
          "Turbo-Retarder-Kupplung",
          "Stahlfederung Grounder",
          "Hydraulische Abstützung",
          "Active Brake Assist 5",
          "Differentialsperre vorne/hinten",
          "Robuste Stoßfänger in Stahl"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Arocs 3251 K 8x4 ist der unerschütterliche Partner für schwere Baustelleneinsätze. Mit seiner 8x4-Konfiguration und dem Grounder-Fahrwerk meistert er auch extremste Bedingungen – sei es auf aufgeweichten Böden, in steilem Gelände oder unter maximaler Beladung. Wo andere Fahrzeuge an ihre Grenzen stoßen, fängt der Arocs erst richtig an.\n\nDer OM 471 Motor mit 510 PS und 2.500 Nm Drehmoment liefert die Kraft, die auf der Baustelle gebraucht wird. Die Turbo-Retarder-Kupplung ermöglicht präzises Manövrieren auch bei extremen Steigungen und schwerem Kipperaufbau. Das Grounder-Fahrwerk mit Stahlfederung ist für die härtesten Einsatzbedingungen konzipiert.\n\nDas ClassicSpace-Fahrerhaus bietet dem Fahrer einen funktionalen Arbeitsplatz mit hervorragender Rundumsicht. Der Nebenantrieb ermöglicht den Betrieb von Kippern, Betonmischern und anderen Aufbauten. Der Active Brake Assist 5 und die Berganfahrhilfe sorgen für Sicherheit auf der Baustelle.",
        "marketing_text_mittel": "Der Mercedes-Benz Arocs 3251 K 8x4 ist für extremste Baustellenbedingungen konzipiert. Mit 510 PS, 8x4-Antrieb und dem verstärkten Grounder-Fahrwerk meistert er auch anspruchsvollstes Gelände. Die Turbo-Retarder-Kupplung ermöglicht präzises Manövrieren bei extremen Steigungen.\n\nDifferentialsperren an beiden Achsen garantieren Traktion auf jedem Untergrund. Das Multimedia Cockpit und der Nebenantrieb für Kipperaufbauten machen ihn zum vielseitigen Baustellen-Partner.",
        "preis_ab_eur": 197500
      },
      {
        "id": 9,
        "modell": "Mercedes-Benz Arocs 2653 L 6x4",
        "baureihe": "Arocs",
        "kategorie": "Baustellenverkehr",
        "bild_url": "https://images.unsplash.com/photo-1504270232528-89ca5a53e0bd?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Kraftvolle Performance für anspruchsvolle Baustellenlogistik – ideal für Betonmischer und Kipperanwendungen.",
        "technische_daten": {
          "motor": "OM 473 Euro VI-E",
          "hubraum_l": 15.6,
          "leistung_ps": 530,
          "leistung_kw": 390,
          "drehmoment_nm": 2600,
          "antriebsformel": "6x4",
          "gesamtgewicht_t": 33,
          "fahrerhaustyp": "CompactSpace"
        },
        "ausstattung_highlights": [
          "OM 473 Großmotor",
          "Flüssigkeitskupplung",
          "Stahlfederung",
          "Hydraulik für Aufbauten",
          "Active Brake Assist 5",
          "Abbiege-Assistent"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Arocs 2653 L 6x4 ist das Arbeitstier für anspruchsvolle Baustofflogistik. Mit seinem mächtigen OM 473 Motor und 530 PS bewegt er schwere Betonmischer und Kipperaufbauten mühelos durch den Baustellenalltag. Der große Hubraum von 15,6 Litern garantiert souveräne Kraftentfaltung bei jeder Drehzahl.\n\nDie Flüssigkeitskupplung ermöglicht butterweiche Anfahrvorgänge auch bei voller Beladung und auf extremen Steigungen – ideal für Betonmischer. Das 6x4-Fahrwerk mit Stahlfederung ist auf maximale Belastbarkeit ausgelegt. Der Hydraulikanschluss für Aufbauten liefert Energie für Kipper, Betonmischer und Ladekrane.\n\nMit dem Abbiege-Assistenten und dem Active Brake Assist 5 setzt der Arocs 2653 auf modernste Sicherheitstechnik. Der Arocs 2653 L 6x4 ist die richtige Wahl für Unternehmen, die maximale Produktivität auf der Baustelle fordern.",
        "marketing_text_mittel": "Der Mercedes-Benz Arocs 2653 L 6x4 ist für schwere Baustellenarbeit konzipiert. Der 530 PS starke OM 473 mit 15,6 Litern Hubraum liefert souveräne Kraft für Betonmischer und Kipper. Die Flüssigkeitskupplung ermöglicht verschleißfreies Anfahren auch auf extremen Steigungen.\n\nDas 6x4-Fahrwerk verkraftet höchste Lasten. Hydraulikanschlüsse versorgen alle gängigen Aufbauten. Der Abbiege-Assistent und Active Brake Assist 5 sorgen für Sicherheit auf der Baustelle.",
        "preis_ab_eur": 178900
      },
      {
        "id": 10,
        "modell": "Mercedes-Benz Arocs Extent 3253 K",
        "baureihe": "Arocs",
        "kategorie": "Baustellenverkehr/Sondermodell",
        "bild_url": "https://images.unsplash.com/photo-1609143739217-01b60dad1c67?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Streng limitiert auf 100 Exemplare – der exklusivste Arocs aller Zeiten mit einzigartigen Design-Elementen.",
        "technische_daten": {
          "motor": "OM 473 Euro VI-E",
          "hubraum_l": 15.6,
          "leistung_ps": 530,
          "leistung_kw": 390,
          "antriebsformel": "8x4",
          "gesamtgewicht_t": 41,
          "fahrerhaustyp": "BigSpace"
        },
        "ausstattung_highlights": [
          "Exklusives Arocs-Schriftzug in Dark-Chrome",
          "Schwarze Blende hinter Mercedes-Stern",
          "LED-Scheinwerfer mit LED-Zusatzleuchten",
          "Carbon-Optik Zierelemente",
          "Edelstahl-Achskappen",
          "Leder-Lenkrad",
          "Nummerierungsplakette"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Arocs Extent ist das exklusivste Baustellenfahrzeug, das jemals einen Mercedes-Stern getragen hat. Streng limitiert auf nur 100 Exemplare weltweit, vereint dieses Sondermodell die unverwüstliche Robustheit des Arocs mit einzigartigen Design-Elementen.\n\nSchon aus der Ferne fällt das markante Design auf: Die schwarze Blende hinter dem Mercedes-Stern und der exklusive Arocs-Schriftzug in Dark-Chrome setzen kraftvolle Akzente. Die LED-Scheinwerfer werden von zusätzlichen LED-Leuchten in der Sonnenblende ergänzt. Die Carbon-Optik Zierelemente und die premium Edelstahl-Achskappen unterstreichen den exklusiven Charakter.\n\nTechnisch basiert der Extent auf dem bewährten Arocs 3253 K. Der OM 473 Motor mit 530 PS liefert die Kraft für schwerste Einsätze. Das Leder-Lenkrad liegt perfekt in der Hand. Jedes Fahrzeug trägt eine individuelle Nummerierungsplakette am Exterieur.",
        "marketing_text_mittel": "Der Mercedes-Benz Arocs Extent ist streng auf 100 Exemplare limitiert – das exklusivste Baustellenfahrzeug von Mercedes-Benz. Der Dark-Chrome Arocs-Schriftzug, die schwarze Blende hinter dem Stern und die LED-Zusatzleuchten machen ihn unverwechselbar.\n\nTechnisch basiert er auf dem Arocs 3253 K mit 530 PS und 8x4-Antrieb. Leder-Lenkrad und Carbon-Optik Elemente werten das Interieur auf. Jedes Fahrzeug trägt eine Nummerierungsplakette. Für Profis mit Stil.",
        "preis_ab_eur": 235000
      },
      {
        "id": 11,
        "modell": "Mercedes-Benz Arocs 4145 K 8x8",
        "baureihe": "Arocs",
        "kategorie": "Baustellenverkehr/Allrad",
        "bild_url": "https://images.unsplash.com/photo-1611273426858-450d8e3c9fce?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Kompromisslose Geländefähigkeit mit Vierradantrieb – für extremste Bedingungen abseits befestigter Straßen.",
        "technische_daten": {
          "motor": "OM 470 Euro VI-E",
          "hubraum_l": 10.7,
          "leistung_ps": 449,
          "antriebsformel": "8x8",
          "gesamtgewicht_t": 41,
          "bodenfreiheit_mm": 400,
          "wattiefe_mm": 800
        },
        "ausstattung_highlights": [
          "Permanenter Allradantrieb 8x8",
          "Drei schaltbare Differentialsperren",
          "Off-Road Getriebeabstimmung",
          "Erhöhte Bodenfreiheit 400mm",
          "Wattiefe 800mm",
          "Unterfahrschutz Stahl"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Arocs 4145 K 8x8 ist für Einsätze konzipiert, bei denen herkömmliche Baustellenfahrzeuge kapitulieren. Mit seinem permanenten Allradantrieb an allen vier Achsen und drei schaltbaren Differentialsperren meistert er auch extremstes Gelände – tiefe Schlammlöcher, steile Abraumhalden oder aufgeweichte Waldwege.\n\nDer OM 470 Motor mit 449 PS ist auf den Geländeeinsatz abgestimmt. Das Mercedes PowerShift 3 Off-Road Getriebe verfügt über spezielle Abstufungen für Langsamfahrt. Das Grounder Plus Fahrwerk kombiniert maximale Robustheit mit beeindruckender Geländegängigkeit. Die erhöhte Bodenfreiheit von 400 Millimetern und eine Wattiefe von 800 Millimetern ermöglichen Durchfahrten durch tiefe Pfützen.\n\nDie drei schaltbaren Differentialsperren lassen sich einzeln oder gemeinsam aktivieren. Die Bergabfahrhilfe hält das Fahrzeug bei Gefällestrecken automatisch auf konstantem Tempo.",
        "marketing_text_mittel": "Der Mercedes-Benz Arocs 4145 K 8x8 ist für extremstes Gelände konzipiert. Der permanente 8x8-Allradantrieb mit drei schaltbaren Differentialsperren garantiert Traktion unter allen Bedingungen. 400 mm Bodenfreiheit und 800 mm Wattiefe ermöglichen Durchfahrten durch jedes Hindernis.\n\nDer 449 PS Motor mit Off-Road-Getriebeabstimmung bietet perfekte Kontrolle. Ideal für Steinbrüche, Kieswerke und Waldwirtschaft.",
        "preis_ab_eur": 215000
      },
      {
        "id": 12,
        "modell": "Mercedes-Benz Atego 1224 L",
        "baureihe": "Atego",
        "kategorie": "Verteilerverkehr",
        "bild_url": "https://images.unsplash.com/photo-1586528116311-ad8dd3c8310d?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Der wendige Allrounder für den leichten Verteilerverkehr – perfekt für Innenstädte und enge Zufahrten.",
        "technische_daten": {
          "motor": "OM 936 Euro VI-E",
          "hubraum_l": 7.7,
          "leistung_ps": 238,
          "antriebsformel": "4x2",
          "gesamtgewicht_t": 12,
          "fahrerhaustyp": "S-Fahrerhaus"
        },
        "ausstattung_highlights": [
          "10,25-Zoll LCD-Instrumentendisplay",
          "Active Brake Assist 6",
          "Active Sideguard Assist 2",
          "Niedrige Einstiegshöhe",
          "Kompakter Wendekreis",
          "Rückfahrkamera"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Atego 1224 L ist seit 25 Jahren das Maß aller Dinge im leichten Verteilerverkehr. Mit der neuesten Modellgeneration setzt er diese Erfolgsgeschichte fort und kombiniert bewährte Tugenden mit modernster Technik. Das kompakte Format und der enge Wendekreis machen ihn zum idealen Partner für Lieferungen in Innenstädten.\n\nDer OM 936 Motor mit 238 PS bietet reichlich Leistung für den urbanen Einsatz. Das vollständig überarbeitete Cockpit präsentiert sich mit einem hochauflösenden 10,25-Zoll LCD-Display. Der Active Brake Assist 6 und der Active Sideguard Assist 2 entsprechen dem neuesten Stand der Technik.\n\nDas S-Fahrerhaus mit niedriger Einstiegshöhe erleichtert das häufige Ein- und Aussteigen erheblich. Die Rückfahrkamera unterstützt bei Rangiermanövern. Der Atego 1224 L ist das zuverlässige Arbeitstier für den städtischen Verteilerverkehr.",
        "marketing_text_mittel": "Der Mercedes-Benz Atego 1224 L ist der Spezialist für den leichten Verteilerverkehr. Mit 238 PS und kompaktem Wendekreis meistert er enge Innenstädte mühelos. Das neue 10,25-Zoll LCD-Display ersetzt die analogen Instrumente.\n\nDer Active Brake Assist 6 und Active Sideguard Assist 2 setzen auf modernste Sensorfusion für maximale Sicherheit. Die niedrige Einstiegshöhe und die Rückfahrkamera erleichtern den Stop-and-Go-Alltag. Der zuverlässige Partner für urbane Logistik.",
        "preis_ab_eur": 78500
      },
      {
        "id": 13,
        "modell": "Mercedes-Benz Atego 1530 L",
        "baureihe": "Atego",
        "kategorie": "Verteilerverkehr",
        "bild_url": "https://images.unsplash.com/photo-1570793005386-838e52f1f284?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Die leistungsstarke Variante für mittelschweren Verteilerverkehr – ideal für größere Ladevolumen.",
        "technische_daten": {
          "motor": "OM 936 Euro VI-E",
          "hubraum_l": 7.7,
          "leistung_ps": 299,
          "antriebsformel": "4x2",
          "getriebe": "PowerShift 3 (8-Gang)",
          "gesamtgewicht_t": 15,
          "ladeflaeche_m": 7.2
        },
        "ausstattung_highlights": [
          "8-Gang PowerShift Getriebe",
          "Verlängertes S-Fahrerhaus",
          "Active Brake Assist 6",
          "Luftfederung Hinterachse",
          "Ladebordwand-Vorbereitung",
          "Navigationssystem"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Atego 1530 L schließt die Lücke zwischen leichtem Verteilerverkehr und schwerem Nutzfahrzeug. Mit 299 PS und 15 Tonnen zulässigem Gesamtgewicht bietet er die richtige Kombination aus Leistung und Wirtschaftlichkeit. Der längere Radstand ermöglicht Aufbaulängen bis 7,2 Meter.\n\nDas 8-Gang PowerShift Getriebe sorgt für enge Gangabstufungen. Die Luftfederung an der Hinterachse passt die Fahrzeughöhe automatisch an die Beladung an. Das verlängerte S-Fahrerhaus bietet mehr Stauraum. Die Ladebordwand-Vorbereitung ist serienmäßig verbaut.\n\nMit dem Active Brake Assist 6 und dem Spurhalteassistent verfügt der Atego 1530 über ein umfassendes Sicherheitspaket. Der ideale Partner für mittelschweren Verteilerverkehr.",
        "marketing_text_mittel": "Der Mercedes-Benz Atego 1530 L bietet 299 PS für mittelschwere Transportaufgaben. Das 8-Gang PowerShift Getriebe und die Luftfederung an der Hinterachse sorgen für effizientes Fahren. Der längere Radstand ermöglicht bis zu 7,2 Meter Aufbaulänge.\n\nDas verlängerte S-Fahrerhaus eignet sich für längere Touren. Die Ladebordwand-Vorbereitung ist serienmäßig. Der Active Brake Assist 6 bietet umfassende Sicherheit. Die perfekte Wahl für anspruchsvollen Verteilerverkehr.",
        "preis_ab_eur": 98500
      },
      {
        "id": 14,
        "modell": "Mercedes-Benz Atego 1630 AF",
        "baureihe": "Atego",
        "kategorie": "Bauverkehr/Feuerwehr",
        "bild_url": "https://images.unsplash.com/photo-1566576912321-d58ddd7a6088?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Der robuste Allrounder für Bau und Rettungsdienst – mit verstärkter Hinterachse für erhöhte Tragfähigkeit.",
        "technische_daten": {
          "motor": "OM 936 Euro VI-E",
          "leistung_ps": 299,
          "antriebsformel": "4x2",
          "gesamtgewicht_t": 16,
          "hinterachse_t": 10,
          "bereifung": "Singlebereifung hinten"
        },
        "ausstattung_highlights": [
          "10-Tonnen Hinterachse",
          "Singlebereifung für Flexibilität",
          "Nebenantrieb für Aufbauten",
          "Active Brake Assist 6",
          "Robuste Stoßfänger",
          "Feuerwehr-Vorbereitung"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Atego 1630 AF ist für Spezialanwendungen in Bau und Rettungswesen konzipiert. Mit seiner verstärkten 10-Tonnen Hinterachse und der Singlebereifung bietet er maximale Flexibilität bei der Gewichtsverteilung von Aufbauten. Die erhöhte Achslast ermöglicht schwerere Aggregate.\n\nDer OM 936 Motor mit 299 PS liefert die Kraft für anspruchsvolle Einsätze. Der Nebenantrieb stellt Hydraulikleistung für Feuerwehrpumpen, Ladekrane oder andere Aufbauten zur Verfügung. Die optionale Feuerwehr-Vorbereitung umfasst spezielle Elektrik und verstärkte Lichtmaschine.\n\nMit dem Active Brake Assist 6 verfügt auch dieses Spezialfahrzeug über modernste Sicherheitstechnik. Die robuste Basis für anspruchsvolle Spezialaufbauten.",
        "marketing_text_mittel": "Der Mercedes-Benz Atego 1630 AF bietet eine verstärkte 10-Tonnen Hinterachse mit Singlebereifung für maximale Aufbau-Flexibilität. Mit 299 PS und robustem Nebenantrieb ist er ideal für Feuerwehr- und Baustellenaufbauten.\n\nDie erhöhte Bodenfreiheit und der optionale Allradantrieb ermöglichen Einsätze in schwierigem Gelände. Die Feuerwehr-Vorbereitung ist verfügbar. Die perfekte Basis für Spezialfahrzeuge.",
        "preis_ab_eur": 112000
      },
      {
        "id": 15,
        "modell": "Mercedes-Benz Econic 2630 L 6x2",
        "baureihe": "Econic",
        "kategorie": "Kommunalverkehr",
        "bild_url": "https://images.unsplash.com/photo-1558905586-526e4a45a526?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Das Low-Entry-Konzept für den urbanen Kommunaleinsatz – nur zwei Schritte bis ins Fahrerhaus.",
        "technische_daten": {
          "motor": "OM 936 Euro VI-E",
          "leistung_ps": 299,
          "antriebsformel": "6x2",
          "getriebe": "Allison Automatik (6-Gang)",
          "gesamtgewicht_t": 26,
          "einstiegshoehe_mm": 380
        },
        "ausstattung_highlights": [
          "Einstiegshöhe nur 380mm",
          "Panorama-Windschutzscheibe",
          "Niedrige Fahrerhausposition",
          "Allison Automatikgetriebe",
          "Active Sideguard Assist 2",
          "360-Grad Kamerasystem",
          "Beidseitige Einstiegstüren"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Econic 2630 L ist das Ergebnis konsequenten Designs für den urbanen Kommunaleinsatz. Das revolutionäre Low-Entry-Konzept ermöglicht einen Einstieg in nur zwei Schritten – die Einstiegshöhe von nur 380 Millimetern schont die Gelenke der Müllwerker bei hunderten Ein- und Ausstiegen pro Schicht.\n\nDie niedrige Fahrerposition und die Panorama-Windschutzscheibe bieten eine einzigartige Rundumsicht. Der Fahrer sitzt auf Augenhöhe mit Radfahrern und Fußgängern. Das Allison Automatikgetriebe ist speziell auf den Stop-and-Go-Betrieb abgestimmt.\n\nDer Active Sideguard Assist 2 mit 360-Grad Kamerasystem schafft ein umfassendes Sicherheitsnetz. Das Fahrerhaus bietet volle Stehöhe und beidseitige Einstiegstüren. Der Econic 2630 L ist die Referenz für ergonomisches Arbeiten im Kommunalbereich.",
        "marketing_text_mittel": "Der Mercedes-Benz Econic 2630 L setzt Maßstäbe im Kommunalbereich. Mit nur 380 mm Einstiegshöhe und dem Low-Entry-Konzept sind nur zwei Schritte bis ins Fahrerhaus nötig. Die Panorama-Windschutzscheibe und niedrige Sitzposition ermöglichen beste Rundumsicht.\n\nDas Allison Automatikgetriebe ist perfekt auf Stop-and-Go abgestimmt. Der Active Sideguard Assist 2 mit 360-Grad Kameras schützt Fußgänger und Radfahrer. Das ergonomischste Kommunalfahrzeug seiner Klasse.",
        "preis_ab_eur": 165000
      },
      {
        "id": 16,
        "modell": "Mercedes-Benz eEconic",
        "baureihe": "eEconic",
        "kategorie": "Kommunalverkehr/Elektro",
        "bild_url": "https://images.unsplash.com/photo-1617886903355-9354bb57751f?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Elektrischer Kommunaldienst – lokal emissionsfrei und nahezu geräuschlos durch die Stadt.",
        "technische_daten": {
          "antrieb": "Elektrisch",
          "dauerleistung_kw": 330,
          "spitzenleistung_kw": 400,
          "batteriekapazitaet_kwh": 420,
          "reichweite_km": 300,
          "antriebsformel": "6x2",
          "gesamtgewicht_t": 27,
          "einstiegshoehe_mm": 380
        },
        "ausstattung_highlights": [
          "Low-Entry Konzept",
          "Vier NMC-Batteriepakete",
          "Nahezu geräuschlos im Betrieb",
          "Rekuperationsbremse",
          "Panorama-Windschutzscheibe",
          "360-Grad Kamerasystem",
          "Wärmepumpen-Klimatisierung"
        ],
        "marketing_text_lang": "Der Mercedes-Benz eEconic ist die elektrische Evolution des bewährten Econic-Konzepts. Er kombiniert das einzigartige Low-Entry-Design mit lokal emissionsfreiem Antrieb und macht die Müllabfuhr der Zukunft zur Realität von heute. In Wohngebieten fällt vor allem seine Lautlosigkeit auf – die frühmorgendliche Müllabfuhr stört nicht mehr den Schlaf.\n\nVier Batteriepakete mit einer Gesamtkapazität von 420 kWh liefern eine Reichweite von rund 300 Kilometern. Die Rekuperationsbremse gewinnt bei den zahlreichen Bremsvorgängen Energie zurück. Das Low-Entry-Fahrerhaus mit 380 Millimetern Einstiegshöhe bleibt erhalten.\n\nDie Wärmepumpen-Klimatisierung arbeitet hocheffizient. Das 360-Grad Kamerasystem und der Active Sideguard Assist bieten ein umfassendes Sicherheitspaket. Mit dem eEconic können Kommunen ihre Klimaziele konkret umsetzen.",
        "marketing_text_mittel": "Der Mercedes-Benz eEconic bringt elektrische Mobilität in den Kommunalbereich. Mit 420 kWh Batteriekapazität und 300 km Reichweite meistert er auch lange Sammeltouren. Der nahezu geräuschlose Betrieb ermöglicht frühmorgendliche Einsätze ohne Lärmbelästigung.\n\nDas Low-Entry-Konzept mit 380 mm Einstiegshöhe bleibt erhalten. Die Wärmepumpen-Klimatisierung schont die Reichweite. Die umweltfreundliche Müllabfuhr der Zukunft – heute schon verfügbar.",
        "preis_ab_eur": 325000
      },
      {
        "id": 17,
        "modell": "Mercedes-Benz Econic 1830 L NGT",
        "baureihe": "Econic",
        "kategorie": "Kommunalverkehr/Erdgas",
        "bild_url": "https://images.unsplash.com/photo-1558906096-f6ec15e85c3f?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Sauberer Antrieb mit Erdgas – reduzierte Emissionen bei bewährter Zuverlässigkeit.",
        "technische_daten": {
          "motor": "M 936 G NGT Euro VI",
          "leistung_ps": 302,
          "kraftstoff": "CNG (Compressed Natural Gas)",
          "tankvolumen_kg": 80,
          "antriebsformel": "4x2",
          "gesamtgewicht_t": 18,
          "einstiegshoehe_mm": 380
        },
        "ausstattung_highlights": [
          "CNG-Gastanks auf dem Rahmen",
          "Low-Entry Konzept",
          "Allison Automatikgetriebe",
          "Panorama-Windschutzscheibe",
          "Active Sideguard Assist",
          "Niedrige Geräuschemissionen",
          "Bio-CNG kompatibel"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Econic 1830 L NGT bietet eine umweltfreundliche Alternative zum Dieselantrieb. Der Erdgas-Motor M 936 G liefert 302 PS und vereint kraftvolle Leistung mit deutlich reduzierten Emissionen. Bei Nutzung von Bio-CNG kann die CO2-Bilanz nahezu klimaneutral ausfallen.\n\nDer Erdgas-Antrieb zeichnet sich durch besonders ruhigen Lauf aus. Die Gastanks sind platzsparend auf dem Rahmen montiert. Das bewährte Low-Entry-Konzept bleibt vollständig erhalten. Die Panorama-Windschutzscheibe macht den Arbeitsalltag sicherer.\n\nDie Reichweite mit 80 Kilogramm CNG ist für kommunale Anwendungen mehr als ausreichend. Die Betankung dauert nur wenige Minuten. Die saubere Alternative im Kommunalbereich.",
        "marketing_text_mittel": "Der Mercedes-Benz Econic 1830 L NGT verbindet Erdgas-Antrieb mit dem Low-Entry-Konzept. Der M 936 G Motor mit 302 PS läuft besonders ruhig und emissionsarm. Mit Bio-CNG wird ein nahezu klimaneutraler Betrieb möglich.\n\nDie Gastanks sind platzsparend auf dem Rahmen montiert. Die niedrige Einstiegshöhe und Panorama-Windschutzscheibe bleiben erhalten. Die saubere Alternative im Kommunalbereich.",
        "preis_ab_eur": 185000
      },
      {
        "id": 18,
        "modell": "Mercedes-Benz Unimog U 430",
        "baureihe": "Unimog",
        "kategorie": "Geräteträger/Kommunal",
        "bild_url": "https://images.unsplash.com/photo-1533473359331-0135ef1b58bf?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Der legendäre Geräteträger – universelles Multitalent für Kommunal, Agrar und Spezialanwendungen.",
        "technische_daten": {
          "motor": "OM 936 Euro VI-E",
          "leistung_ps": 299,
          "antriebsformel": "4x4 permanent",
          "getriebe": "UG 100/8 (8-Gang)",
          "gesamtgewicht_t": 14.5,
          "radstand_mm": 3600,
          "kriechgang": "0.04 km/h"
        },
        "ausstattung_highlights": [
          "Permanenter Allradantrieb",
          "VarioPilot wechselseitiges Fahren",
          "Drei Anbauräume vorne/hinten/seitlich",
          "Zapfwellen vorne und hinten",
          "EasyDrive Automatikfunktion",
          "Portalachsen für Bodenfreiheit",
          "Arbeitshydraulik bis 200 l/min"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Unimog U 430 ist weit mehr als ein Fahrzeug – er ist ein Konzept. Seit über 70 Jahren verkörpert der Unimog die Idee des universellen Geräteträgers. Der U 430 setzt diese Tradition fort und kombiniert legendäre Unimog-Tugenden mit modernster Technik.\n\nDer OM 936 Motor mit 299 PS liefert die Kraft für anspruchsvollste Arbeitseinsätze. Das einzigartige UG 100/8 Getriebe ermöglicht Kriechgeschwindigkeiten bis 0,04 km/h. Die drei Anbauräume ermöglichen die gleichzeitige Montage mehrerer Geräte. Die Zapfwellen an Front und Heck treiben Mähwerke, Streuer und Kehrmaschinen an.\n\nDas VarioPilot-System ermöglicht wechselseitiges Fahren: Der Bedienerplatz kann vom Fahrer zur Beifahrerseite gewechselt werden – ohne Umbau, während der Fahrt. Die legendären Portalachsen sorgen für die typische Bodenfreiheit des Unimog.",
        "marketing_text_mittel": "Der Mercedes-Benz Unimog U 430 ist das universelle Multitalent. Mit 299 PS, permanentem 4x4-Antrieb und drei Anbauräumen kann er hunderte Geräte tragen. Der Kriechgang bis 0,04 km/h ermöglicht präziseste Arbeiten.\n\nDas VarioPilot-System erlaubt wechselseitiges Fahren für mehr Sicherheit. Zapfwellen vorne und hinten versorgen alle gängigen Anbaugeräte. Der Unimog – seit 70 Jahren die Referenz für Vielseitigkeit.",
        "preis_ab_eur": 198000
      },
      {
        "id": 19,
        "modell": "Mercedes-Benz Unimog U 5023",
        "baureihe": "Unimog",
        "kategorie": "Hochgeländegängig",
        "bild_url": "https://images.unsplash.com/photo-1503376780353-7e6692767b70?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Extrem geländegängig – für Einsätze dort, wo andere nicht mehr weiterkommen.",
        "technische_daten": {
          "motor": "OM 934 Euro VI-E",
          "leistung_ps": 231,
          "antriebsformel": "4x4 permanent",
          "gesamtgewicht_t": 14.5,
          "bodenfreiheit_mm": 570,
          "wattiefe_mm": 1200,
          "steigfaehigkeit_prozent": 100
        },
        "ausstattung_highlights": [
          "570mm Bodenfreiheit",
          "1200mm Wattiefe",
          "100% Steigfähigkeit",
          "Reifendruckanlage",
          "Differentialsperren vorne/hinten",
          "Portalachsen",
          "Seilwinde optional",
          "Expeditionsvorbereitung"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Unimog U 5023 ist die ultimative Antwort auf extremste Geländeherausforderungen. Mit einer Bodenfreiheit von 570 Millimetern, einer Wattiefe von 1.200 Millimetern und einer Steigfähigkeit von 100 Prozent überwindet er Hindernisse, an denen jedes andere Fahrzeug scheitert.\n\nDer OM 934 Motor mit 231 PS ist auf Geländetauglichkeit optimiert. Die legendären Portalachsen sind das Geheimnis der extremen Bodenfreiheit. Die Differentialsperren an Vorder- und Hinterachse garantieren Traktion. Die optionale Reifendruckanlage ermöglicht die Anpassung während der Fahrt.\n\nDer U 5023 ist die bevorzugte Basis für Expeditionsfahrzeuge und Spezialanwendungen in Bergrettung, Forstwirtschaft und Energiewirtschaft. Ein Fahrzeug für Menschen, die das Abenteuer suchen.",
        "marketing_text_mittel": "Der Mercedes-Benz Unimog U 5023 ist für extremstes Gelände konzipiert. Mit 570 mm Bodenfreiheit, 1.200 mm Wattiefe und 100% Steigfähigkeit überwindet er jedes Hindernis. Die Portalachsen und Differentialsperren garantieren legendäre Geländegängigkeit.\n\nDer 231 PS Motor mit Kriechgängen ermöglicht präzise Kontrolle. Die Reifendruckanlage passt den Druck während der Fahrt an. Für Expeditionen, Bergrettung und Forstwirtschaft.",
        "preis_ab_eur": 235000
      },
      {
        "id": 20,
        "modell": "Mercedes-Benz Zetros 3343 A 6x6",
        "baureihe": "Zetros",
        "kategorie": "Schwerlast/Offroad",
        "bild_url": "https://images.unsplash.com/photo-1552519507-da3b142c6e3d?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Das Extrem-Schwerlastfahrzeug für härteste Bedingungen – unaufhaltsam im Gelände.",
        "technische_daten": {
          "motor": "OM 460 Euro III",
          "leistung_ps": 428,
          "antriebsformel": "6x6 permanent",
          "getriebe": "Mercedes G 330-12 (12-Gang)",
          "gesamtgewicht_t": 33,
          "zuggesamtgewicht_t": 120,
          "bodenfreiheit_mm": 400,
          "wattiefe_mm": 1000
        },
        "ausstattung_highlights": [
          "Permanenter 6x6-Allradantrieb",
          "Drei Differentialsperren",
          "Untersetzungsgetriebe",
          "Stahlfederung mit hoher Tragfähigkeit",
          "Klimaanlage -30 bis +50°C",
          "Berganfahrhilfe",
          "Seilwindenaufnahme"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Zetros 3343 A 6x6 ist für die extremsten Einsatzszenarien konzipiert. Ob Wüsteneinsatz, Bergbau oder Katastrophenhilfe – der Zetros meistert Bedingungen, unter denen herkömmliche Fahrzeuge längst kapituliert hätten. Mit seinem permanenten 6x6-Allradantrieb und drei schaltbaren Differentialsperren ist er praktisch unaufhaltsam.\n\nDer OM 460 Motor mit 428 PS liefert brachiale Kraft bei jeder Drehzahl. Das massive Drehmoment von 2.100 Nm steht bei niedrigen Drehzahlen zur Verfügung. Das robuste G 330-12 Getriebe mit Untersetzungsgruppe verdoppelt die Ganganzahl für extreme Situationen.\n\nDas Fahrwerk ist auf maximale Belastbarkeit ausgelegt. Die Klimaanlage arbeitet zuverlässig bei -30 bis +50 Grad Celsius. Mit 120 Tonnen Zuggesamtgewicht eignet sich der Zetros auch als Zugmaschine für schwerste Lasten.",
        "marketing_text_mittel": "Der Mercedes-Benz Zetros 3343 A 6x6 ist für extremste Einsätze konzipiert. Mit permanentem 6x6-Antrieb, drei Differentialsperren und 428 PS bewältigt er Wüste, Bergbau und Katastrophengebiete. 400 mm Bodenfreiheit und 1.000 mm Wattiefe machen ihn unaufhaltsam.\n\nDas robuste Fahrwerk verkraftet schwerste Belastungen. Mit 120 t Zuggesamtgewicht ist er auch als Schwerlastzugmaschine einsetzbar. Das kompromisslose Werkzeug für härteste Bedingungen.",
        "preis_ab_eur": 285000
      },
      {
        "id": 21,
        "modell": "Mercedes-Benz Actros SLT 4163 8x6",
        "baureihe": "Actros SLT",
        "kategorie": "Schwerlasttransport",
        "bild_url": "https://images.unsplash.com/photo-1562674916-9d6f4a58e01f?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Die Schwerlastzugmaschine für außergewöhnliche Transportaufgaben – bis 250 Tonnen Gesamtzuggewicht.",
        "technische_daten": {
          "motor": "OM 473 Euro VI-E",
          "leistung_ps": 625,
          "drehmoment_nm": 3000,
          "antriebsformel": "8x6",
          "getriebe": "PowerShift 3 SLT (16-Gang)",
          "zuggesamtgewicht_t": 250,
          "fahrerhaustyp": "GigaSpace",
          "tankvolumen_l": 1100
        },
        "ausstattung_highlights": [
          "Turbo-Retarder-Kupplung",
          "SLT-Getriebe mit 16 Gängen",
          "Hinterachslift und -lenkung",
          "Telligent Niveauregelung",
          "Schwerlast-Sattelkupplung",
          "Zusatztanks 1.100 Liter",
          "Actros Experience Room"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros SLT 4163 8x6 ist für die Königsdisziplin des Straßentransports konzipiert: den Schwerlasttransport. Mit einem zulässigen Gesamtzuggewicht von bis zu 250 Tonnen bewegt er Lasten, die für andere Fahrzeuge unmöglich sind – von Transformatoren über Windkraftanlagen bis hin zu kompletten Industrieanlagen.\n\nDer mächtige OM 473 Motor mit 625 PS und 3.000 Nm Drehmoment bildet das Kraftzentrum. Die Turbo-Retarder-Kupplung ermöglicht präzises Manövrieren mit schwerem Tiefbettanhänger. Das SLT-Getriebe mit 16 Gängen und Kriechgangstufe bietet für jede Situation die passende Übersetzung.\n\nDas GigaSpace-Fahrerhaus mit Actros Experience Room und zwei Schlafplätzen macht den SLT zum rollenden Zuhause für tagelange Transporte. Der Actros SLT 4163 wird von Custom Tailored Trucks (CTT) in Molsheim individuell gefertigt.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros SLT 4163 8x6 ist die ultimative Schwerlastzugmaschine. Mit 625 PS, 3.000 Nm und bis zu 250 t Zuggesamtgewicht bewegt er außergewöhnliche Lasten. Die Turbo-Retarder-Kupplung ermöglicht präzises Manövrieren.\n\nDas 16-Gang SLT-Getriebe mit Kriechgang und die lenkbare Hinterachse sorgen für Wendigkeit. Das GigaSpace-Fahrerhaus mit Experience Room bietet Wohnkomfort. Individuell gefertigt von Custom Tailored Trucks.",
        "preis_ab_eur": 395000
      },
      {
        "id": 22,
        "modell": "Mercedes-Benz Arocs SLT 4158 8x8",
        "baureihe": "Arocs SLT",
        "kategorie": "Schwerlasttransport/Offroad",
        "bild_url": "https://images.unsplash.com/photo-1592838064575-70ed626d3a0e?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Die geländegängige Schwerlastzugmaschine – wenn extreme Lasten auch extreme Wege erfordern.",
        "technische_daten": {
          "motor": "OM 473 Euro VI-E",
          "leistung_ps": 580,
          "antriebsformel": "8x8",
          "zuggesamtgewicht_t": 250,
          "fahrerhaustyp": "BigSpace",
          "bodenfreiheit_mm": 320
        },
        "ausstattung_highlights": [
          "Permanenter 8x8-Allradantrieb",
          "Vier Differentialsperren",
          "Stahlfederung Grounder",
          "Turbo-Retarder-Kupplung",
          "Hydraulischer Antrieb (HAD)",
          "Seilwindenaufnahme",
          "Schwerlast-Anhängerkupplung"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Arocs SLT 4158 8x8 vereint die Schwerlastfähigkeit der SLT-Baureihe mit der kompromisslosen Geländetauglichkeit des Arocs. Wenn schwere Lasten nicht nur transportiert, sondern auch abseits befestigter Straßen bewegt werden müssen, ist der Arocs SLT die erste Wahl.\n\nDer OM 473 Motor mit 580 PS liefert die Kraft für Schwerlast und Gelände gleichermaßen. Der permanente 8x8-Allradantrieb mit vier schaltbaren Differentialsperren garantiert Traktion unter allen Bedingungen. Der optionale Hydraulic Auxiliary Drive (HAD) verstärkt die Antriebskraft bei extremen Steigungen.\n\nDas Grounder-Fahrwerk mit Stahlfederung ist auf maximale Belastbarkeit im Gelände ausgelegt. Die Seilwindenaufnahme ermöglicht die Montage einer Bergewinde. Mit 250 Tonnen Zuggesamtgewicht und der Geländefähigkeit eines echten Offroaders schließt der Arocs SLT eine wichtige Lücke.",
        "marketing_text_mittel": "Der Mercedes-Benz Arocs SLT 4158 8x8 kombiniert Schwerlasttauglichkeit mit extremer Geländefähigkeit. Mit 580 PS, permanentem 8x8-Antrieb und vier Differentialsperren bewältigt er bis zu 250 t Zuggewicht auch abseits befestigter Straßen.\n\nDas Grounder-Fahrwerk mit erhöhter Bodenfreiheit und der optionale HAD-Antrieb meistern extremstes Gelände. Für Schwertransporte dorthin, wo andere nicht hinkommen.",
        "preis_ab_eur": 425000
      },
      {
        "id": 23,
        "modell": "Mercedes-Benz Actros L 2653 LS 6x2 Volumer",
        "baureihe": "Actros L",
        "kategorie": "Fernverkehr/Volumen",
        "bild_url": "https://images.unsplash.com/photo-1605705658744-45d3a9c1f9e7?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Die Volumer-Variante für maximales Ladevolumen – 3 Meter lichte Höhe für optimale Raumausnutzung.",
        "technische_daten": {
          "motor": "OM 473 Euro VI-E",
          "leistung_ps": 530,
          "antriebsformel": "6x2",
          "gesamtgewicht_t": 44,
          "fahrerhaustyp": "StreamSpace Volumer",
          "sattelhoehe_mm": 950,
          "lichte_hoehe_m": 3.0
        },
        "ausstattung_highlights": [
          "Abgesenkte Sattelhöhe 950mm",
          "3 Meter lichte Höhe möglich",
          "StreamSpace Fahrerhaus",
          "Luftfederung mit Absenkfunktion",
          "Active Brake Assist 5",
          "Predictive Powertrain Control",
          "Elektronische Niveauregulierung"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros L 2653 LS 6x2 Volumer ist speziell für Transportunternehmen entwickelt, bei denen das Ladevolumen wichtiger ist als das Gewicht. Mit einer abgesenkten Sattelhöhe von nur 950 Millimetern ermöglicht er eine lichte Ladehöhe von drei Metern – entscheidend für den Transport von voluminösen, aber leichten Gütern.\n\nDer OM 473 Motor mit 530 PS bietet auch in der Volumer-Konfiguration reichlich Leistungsreserven. Die 6x2-Achskonfiguration mit gelenkter Nachlaufachse reduziert das Leergewicht und verbessert die Wendigkeit. Die Luftfederung mit Absenkfunktion ermöglicht das Absenken an Laderampen.\n\nDie elektronische Niveauregulierung passt die Fahrzeughöhe automatisch an die Beladung an. Der Actros L Volumer ist die Wahl für Speditionen, die jedes verfügbare Kubikzentimeter Ladevolumen nutzen möchten.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros L Volumer maximiert das Ladevolumen. Mit nur 950 mm Sattelhöhe ermöglicht er drei Meter lichte Ladehöhe – ideal für voluminöse, leichte Güter. Der 530 PS starke OM 473 Motor liefert ausreichend Leistungsreserven.\n\nDie 6x2-Konfiguration mit gelenkter Nachlaufachse spart Gewicht und verbessert die Wendigkeit. Die elektronische Niveauregulierung hält die Sattelhöhe konstant. Optimale Raumausnutzung für moderne Logistik.",
        "preis_ab_eur": 185000
      },
      {
        "id": 24,
        "modell": "Mercedes-Benz Actros L 1843 LS Loader",
        "baureihe": "Actros L",
        "kategorie": "Fernverkehr/Leichtbau",
        "bild_url": "https://images.unsplash.com/photo-1616432043562-3671ea2e5242?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Die Leichtbau-Variante für maximale Nutzlast – bis zu 350 kg weniger Leergewicht.",
        "technische_daten": {
          "motor": "OM 471 Euro VI-E",
          "leistung_ps": 428,
          "antriebsformel": "4x2",
          "gesamtgewicht_t": 40,
          "fahrerhaustyp": "BigSpace Loader",
          "tankvolumen_l": 600,
          "leergewicht_reduzierung_kg": 350
        },
        "ausstattung_highlights": [
          "Leichtbau-Optimierungen",
          "Aluminium-Räder",
          "Entfall Kühlerjalousie",
          "Kompakter Tank 600L",
          "Active Brake Assist 5",
          "Optimierte Ausstattung",
          "Gewichtszertifikat"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros L 1843 LS Loader ist für Transportunternehmen konzipiert, bei denen jedes Kilogramm Nutzlast zählt. Durch konsequenten Leichtbau und den Verzicht auf nicht essenzielle Komponenten spart der Loader bis zu 350 Kilogramm Leergewicht – Gewicht, das direkt der Nutzlast zugutekommen.\n\nDer OM 471 Motor mit 428 PS bietet eine optimale Balance aus Leistung und Gewicht. Die Leichtbau-Maßnahmen umfassen Aluminium-Räder, einen kompakteren 600-Liter-Tank und den Entfall der Kühlerjalousie. Jedes Loader-Fahrzeug wird mit einem Gewichtszertifikat ausgeliefert.\n\nTrotz des Fokus auf Leichtbau erfüllt der Loader alle Sicherheitsstandards. Der Active Brake Assist 5 ist serienmäßig. Der clevere Weg zur maximalen Nutzlast.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros L Loader maximiert die Nutzlast durch konsequenten Leichtbau. Bis zu 350 kg weniger Leergewicht durch Aluminium-Räder, kompakteren Tank und optimierte Komponenten. Der 428 PS Motor bietet effiziente Leistung.\n\nJedes Fahrzeug erhält ein Gewichtszertifikat mit exaktem Leergewicht. Alle wichtigen Sicherheitssysteme sind an Bord. Ideal für Anwendungen, bei denen jedes Kilogramm Nutzlast zählt.",
        "preis_ab_eur": 152000
      },
      {
        "id": 25,
        "modell": "Mercedes-Benz eArocs 400",
        "baureihe": "eArocs",
        "kategorie": "Baustellenverkehr/Elektro",
        "bild_url": "https://images.unsplash.com/photo-1630650231841-9dc7e3568bde?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Elektrischer Baustellen-Einsatz – emissionsfrei und leise auf urbanen Baustellen.",
        "technische_daten": {
          "antrieb": "Elektrisch (2 Elektromotoren)",
          "dauerleistung_kw": 300,
          "spitzenleistung_kw": 400,
          "batteriekapazitaet_kwh": 414,
          "batterietyp": "LFP",
          "reichweite_km": 200,
          "antriebsformel": "6x2",
          "gesamtgewicht_t": 27
        },
        "ausstattung_highlights": [
          "Zwei LFP-Batteriepakete",
          "800V Bordspannung",
          "CCS2-Schnellladen",
          "Nebenantrieb für Aufbauten",
          "Active Brake Assist 6",
          "Active Sideguard Assist 2",
          "Niedrige Geräuschemission"
        ],
        "marketing_text_lang": "Der Mercedes-Benz eArocs 400 bringt den elektrischen Antrieb auf die Baustelle. Als elektrische Variante des bewährten Arocs ist er speziell für urbane Baustelleneinsätze konzipiert, bei denen Emissionsfreiheit und geringe Lärmbelästigung gefordert sind.\n\nZwei LFP-Batteriepakete mit einer Gesamtkapazität von 414 kWh versorgen die E-Motoren mit Energie. Die Spitzenleistung von 400 kW garantiert auch bei voller Beladung zügiges Vorankommen. Die Reichweite von rund 200 Kilometern ist für urbane Baustellenlogistik mehr als ausreichend.\n\nDer elektrische Nebenantrieb versorgt Kipperaufbauten und andere Aggregate mit Energie. Der eArocs 400 macht den emissionsfreien Baustellenbetrieb zur Realität.",
        "marketing_text_mittel": "Der Mercedes-Benz eArocs 400 elektrifiziert die Baustelle. Mit 414 kWh LFP-Batteriekapazität und 400 kW Spitzenleistung meistert er urbane Baustellenlogistik emissionsfrei. Die Reichweite von 200 km deckt typische Tagestouren ab.\n\nDer elektrische Nebenantrieb versorgt Kipperaufbauten. CCS2-Schnellladen mit bis zu 400 kW ermöglicht kurze Ladezeiten. Für emissionssensible Bauprojekte ab 2026.",
        "preis_ab_eur": 295000
      },
      {
        "id": 26,
        "modell": "Mercedes-Benz Actros L 1858 LS Hydraulic Trailer",
        "baureihe": "Actros L",
        "kategorie": "Fernverkehr/Sattelzug",
        "bild_url": "https://images.unsplash.com/photo-1591768793355-74d04bb6608f?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Die optimierte Sattelzugmaschine mit hydraulischem Anhängersystem für effizientes Rangieren.",
        "technische_daten": {
          "motor": "OM 471 Euro VI-E",
          "leistung_ps": 578,
          "drehmoment_nm": 2800,
          "antriebsformel": "4x2",
          "gesamtgewicht_t": 40,
          "fahrerhaustyp": "GigaSpace",
          "tankvolumen_l": 800
        },
        "ausstattung_highlights": [
          "Hydraulisches Anhängersystem",
          "Fernbedienung für Auflieger",
          "Automatische Sattelkupplungserkennung",
          "Active Brake Assist 6",
          "Active Drive Assist 3",
          "Trailer Stability Control",
          "Predictive Powertrain Control"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros L 1858 LS mit hydraulischem Anhängersystem ist für den professionellen Sattelzugbetrieb optimiert. Die integrierte Hydraulikversorgung ermöglicht die Steuerung von Auflieger-Funktionen wie Stützen, Achsen und Ladungssicherung direkt vom Fahrerhaus aus.\n\nDer OM 471 Motor mit 578 PS liegt im oberen Leistungsbereich und bietet reichlich Kraftreserven für schwere Transporte. Die hydraulische Fernbedienung ermöglicht das Absenken der Stützfüße und die Steuerung liftbarer Achsen ohne Aussteigen.\n\nDie automatische Sattelkupplungserkennung überprüft die korrekte Verriegelung des Aufliegers. Der Trailer Stability Control erkennt instabile Fahrzustände. Mit der Predictive Powertrain Control nutzt der Actros L GPS-Daten für vorausschauendes Fahren.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros L 1858 LS mit hydraulischem Anhängersystem optimiert den Sattelzugbetrieb. Mit 578 PS und hydraulischer Fernbedienung für Auflieger-Funktionen spart er Zeit bei jedem Kupplungsvorgang.\n\nTrailer Stability Control und Active Brake Assist 6 schützen das Gespann. Der Active Drive Assist 3 ermöglicht teilautomatisiertes Fahren. Die professionelle Wahl für Sattelzugprofis.",
        "preis_ab_eur": 198500
      },
      {
        "id": 27,
        "modell": "Mercedes-Benz Atego 823 K",
        "baureihe": "Atego",
        "kategorie": "Verteilerverkehr/Kipper",
        "bild_url": "https://images.unsplash.com/photo-1581092160607-ee22621dd758?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Der kompakte Kipper für den Bauhof – wendig, robust und vielseitig einsetzbar.",
        "technische_daten": {
          "motor": "OM 934 Euro VI-E",
          "leistung_ps": 231,
          "antriebsformel": "4x2",
          "gesamtgewicht_t": 8.5,
          "fahrerhaustyp": "S-Fahrerhaus kurz",
          "kipper_volumen_m3": 5
        },
        "ausstattung_highlights": [
          "Dreiseitenkipper-Aufbau",
          "Hydraulische Bordwand",
          "Niedriger Einstieg",
          "Kompakter Wendekreis",
          "Active Brake Assist 5",
          "Rückfahrkamera",
          "Anhängerkupplung",
          "Plane und Spriegel"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Atego 823 K ist der ideale Partner für kommunale Bauhöfe, Garten- und Landschaftsbauer sowie kleine Bauunternehmen. Mit seinem kompakten Format und dem engen Wendekreis manövriert er auch durch enge Hofeinfahrten. Der Dreiseitenkipper-Aufbau ermöglicht das Entladen zu drei Seiten.\n\nDer OM 934 Motor mit 231 PS bietet für die typischen Einsätze reichlich Leistung. Der 5-Kubikmeter Kipperaufbau mit hydraulischer Bordwand ist auf häufiges Be- und Entladen ausgelegt. Die optionale Plane mit Spriegel schützt die Ladung.\n\nMit dem Active Brake Assist 5 verfügt auch dieses kompakte Nutzfahrzeug über modernste Sicherheitstechnik. Die Rückfahrkamera erleichtert das präzise Rangieren. Die wirtschaftliche Lösung für den täglichen Einsatz.",
        "marketing_text_mittel": "Der Mercedes-Benz Atego 823 K ist der kompakte Kipper für Bauhöfe und kleine Baufirmen. Mit 231 PS, Dreiseitenkipper und 5 m³ Volumen ist er vielseitig einsetzbar. Der enge Wendekreis meistert verwinkelte Zufahrten.\n\nDie hydraulische Bordwand und die optionale Plane erweitern die Einsatzmöglichkeiten. Active Brake Assist 5 und Rückfahrkamera sorgen für Sicherheit. Wirtschaftlich und robust.",
        "preis_ab_eur": 72000
      },
      {
        "id": 28,
        "modell": "Mercedes-Benz Unimog U 218",
        "baureihe": "Unimog",
        "kategorie": "Geräteträger/Kompakt",
        "bild_url": "https://images.unsplash.com/photo-1494976388531-d1058494cdd8?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Der kompakte Geräteträger – volle Unimog-Vielseitigkeit in stadtfreundlichen Abmessungen.",
        "technische_daten": {
          "motor": "OM 934 Euro VI-E",
          "leistung_ps": 177,
          "antriebsformel": "4x4 permanent",
          "getriebe": "UG 80/8 (8-Gang)",
          "gesamtgewicht_t": 10,
          "radstand_mm": 2900,
          "kriechgang": "0.05 km/h"
        },
        "ausstattung_highlights": [
          "Kompakte Abmessungen",
          "Permanenter Allradantrieb",
          "Drei Anbauräume",
          "Zapfwellen vorne/hinten",
          "Arbeitshydraulik",
          "Portalachsen",
          "Wendiger Radstand"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Unimog U 218 bringt die legendäre Vielseitigkeit des Unimog in ein kompaktes Format. Mit einem Radstand von nur 2.900 Millimetern passt er auch durch enge Straßen und Parkanlagen, in denen größere Geräteträger nicht mehr weiterkommen.\n\nDer OM 934 Motor mit 177 PS bietet ausreichend Leistung für alle typischen Geräteträger-Anwendungen. Das UG 80/8 Getriebe mit Kriechgängen bis 0,05 km/h ermöglicht präzises Arbeiten. Trotz seiner kompakten Abmessungen bietet der U 218 drei Anbauräume, Zapfwellen vorne und hinten und eine leistungsfähige Arbeitshydraulik.\n\nDer permanente Allradantrieb mit Differentialsperren garantiert Traktion auch auf rutschigem Untergrund. Der U 218 ist die clevere Wahl für volle Unimog-Vielseitigkeit in kompaktem Format.",
        "marketing_text_mittel": "Der Mercedes-Benz Unimog U 218 bringt Unimog-Vielseitigkeit in kompakte Abmessungen. Mit 2.900 mm Radstand meistert er auch engste Altstadtgassen. Der 177 PS Motor und Kriechgänge bis 0,05 km/h ermöglichen präzises Arbeiten.\n\nDrei Anbauräume, Zapfwellen vorne/hinten und Arbeitshydraulik bieten volle Geräteträger-Funktionalität. Der wendige Unimog für kommunale Aufgaben in beengten Bereichen.",
        "preis_ab_eur": 155000
      },
      {
        "id": 29,
        "modell": "Mercedes-Benz Econic 1824 L Feuerwehr",
        "baureihe": "Econic",
        "kategorie": "Feuerwehr",
        "bild_url": "https://images.unsplash.com/photo-1578662996442-48f60103fc96?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Das Low-Entry-Fahrzeug für die Feuerwehr – schneller Einstieg und beste Übersicht im Einsatz.",
        "technische_daten": {
          "motor": "OM 936 Euro VI-E",
          "leistung_ps": 238,
          "antriebsformel": "4x2",
          "getriebe": "Allison Automatik (6-Gang)",
          "gesamtgewicht_t": 18,
          "einstiegshoehe_mm": 380
        },
        "ausstattung_highlights": [
          "Feuerwehr-Vorbereitung",
          "Sondersignal-Anlage",
          "Doppelkabine 6 Sitzplätze",
          "Low-Entry Konzept",
          "Allison Automatik",
          "Panorama-Windschutzscheibe",
          "Verstärkte Elektrik",
          "Active Sideguard Assist"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Econic 1824 L in Feuerwehr-Ausführung verbindet das bewährte Low-Entry-Konzept mit den spezifischen Anforderungen von Rettungseinsätzen. Das ultraschnelle Ein- und Aussteigen in nur zwei Schritten kann im Ernstfall kostbare Sekunden sparen.\n\nDer OM 936 Motor mit 238 PS ist zuverlässig und wartungsarm. Das Allison Automatikgetriebe ermöglicht die volle Konzentration auf die Einsatzfahrt. Die Doppelkabine bietet Platz für bis zu sechs Einsatzkräfte in voller Schutzausrüstung. Die beidseitigen Einstiegstüren ermöglichen schnelles Verlassen des Fahrzeugs.\n\nDer Econic Feuerwehr wird in enger Abstimmung mit führenden Feuerwehr-Aufbauherstellern wie Rosenbauer, Ziegler und Magirus entwickelt. Die moderne Basis für Feuerwehrfahrzeuge der neuen Generation.",
        "marketing_text_mittel": "Der Mercedes-Benz Econic 1824 L Feuerwehr verbindet das Low-Entry-Konzept mit Feuerwehr-Anforderungen. Der Ein- und Ausstieg in nur zwei Schritten spart kostbare Sekunden. Die Doppelkabine bietet Platz für sechs Einsatzkräfte.\n\nDas Allison Automatikgetriebe ermöglicht volle Konzentration auf die Einsatzfahrt. Die verstärkte Elektrik versorgt alle Sondersignalanlagen. Die moderne Basis für HLF, TLF und DLK.",
        "preis_ab_eur": 178000
      },
      {
        "id": 30,
        "modell": "Mercedes-Benz Actros L 1851 LS LNG",
        "baureihe": "Actros L",
        "kategorie": "Fernverkehr/Alternative Antriebe",
        "bild_url": "https://images.unsplash.com/photo-1532408840957-031d8034aeef?w=800&h=600&fit=crop",
        "kurzbeschreibung": "Der Fernverkehrs-Actros mit Flüssiggas-Antrieb – reduzierte Emissionen bei hoher Reichweite.",
        "technische_daten": {
          "motor": "M 936 G LNG Euro VI",
          "leistung_ps": 302,
          "kraftstoff": "LNG (Liquefied Natural Gas)",
          "tankvolumen_l": 600,
          "reichweite_km": 1100,
          "antriebsformel": "4x2",
          "gesamtgewicht_t": 40,
          "fahrerhaustyp": "GigaSpace"
        },
        "ausstattung_highlights": [
          "LNG-Kryotanks",
          "Hohe Reichweite 1.100 km",
          "CO2-Reduktion bis 20%",
          "Bio-LNG kompatibel",
          "GigaSpace Fahrerhaus",
          "Active Brake Assist 5",
          "Predictive Powertrain Control",
          "Niedertemperatur-Betankung"
        ],
        "marketing_text_lang": "Der Mercedes-Benz Actros L 1851 LS LNG bietet eine überzeugende Alternative zum Diesel-Fernverkehr. Mit Flüssigerdgas (LNG) als Kraftstoff reduziert er die CO2-Emissionen um bis zu 20 Prozent gegenüber dem Diesel-Pendant. Bei Nutzung von Bio-LNG kann die CO2-Bilanz nahezu klimaneutral ausfallen.\n\nDer M 936 G Motor mit 302 PS ist speziell für den Gas-Betrieb entwickelt. Er arbeitet nach dem Otto-Prinzip und zeichnet sich durch besonders ruhigen Lauf aus. Die beiden LNG-Kryotanks mit insgesamt 600 Litern Volumen ermöglichen eine beeindruckende Reichweite von über 1.100 Kilometern.\n\nDie Betankung erfolgt über einen speziellen Niedertemperatur-Anschluss und dauert etwa 10-15 Minuten. Das GigaSpace-Fahrerhaus bietet den gewohnten Actros-Komfort. Der Actros L LNG ist die Brückentechnologie auf dem Weg zur Elektrifizierung.",
        "marketing_text_mittel": "Der Mercedes-Benz Actros L LNG reduziert CO2-Emissionen um bis zu 20 Prozent gegenüber Diesel. Der 302 PS Gasmotor läuft besonders ruhig und leise. Mit 600 Litern LNG-Tankvolumen erreicht er über 1.100 km Reichweite.\n\nBio-LNG ermöglicht nahezu klimaneutralen Betrieb. Das GigaSpace-Fahrerhaus bietet vollen Fernverkehrskomfort. Die Brückentechnologie für umweltbewusste Transportunternehmen.",
        "preis_ab_eur": 195000
      }
    ]
  },
  "metadaten": {
    "anzahl_fahrzeuge": 30,
    "kategorien": [
      "Fernverkehr",
      "Verteilerverkehr",
      "Baustellenverkehr",
      "Kommunalverkehr",
      "Schwerlasttransport",
      "Elektro",
      "Alternative Antriebe",
      "Spezialfahrzeuge"
    ],
    "baureihen": [
      "Actros L",
      "Actros F",
      "eActros",
      "Arocs",
      "eArocs",
      "Atego",
      "Econic",
      "eEconic",
      "Unimog",
      "Zetros",
      "Actros SLT",
      "Arocs SLT"
    ],
    "hinweis": "Alle Angaben sind fiktive Beispieldaten für Demonstrationszwecke. Preise, technische Daten und Ausstattungsdetails entsprechen nicht zwingend den aktuellen Herstellerangaben.",
    "bildhinweis": "Die Bild-URLs sind Platzhalter. Für den produktiven Einsatz müssen echte Produktbilder von Daimler Truck verwendet werden.",
    "copyright": "Daimler Truck AG – Alle Markenrechte vorbehalten"
  }
}
</file>

<file path="gradle.properties">
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
org.gradle.parallel=true
org.gradle.caching=true
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac



# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line



@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="README.md">
# CatalogForge Backend

Spring Boot 3.4 REST API für die KI-gestützte Generierung professioneller Produktkataloge und Flyer mit Google Gemini.

## Features

- **Text-to-Layout**: Generiert HTML/CSS-Layouts aus Textbeschreibungen
- **Image-to-Layout**: Analysiert Referenzbilder für Farbpaletten und Stimmung
- **Skills-System**: Modulares Prompt-Engineering mit wiederverwendbaren Skills
- **Agent Framework**: Flexible Pipelines (Linear, Iterativ, Parallel)
- **PDF-Export**: Druckfertige PDFs via Puppeteer mit verschiedenen Presets
- **Multi-Varianten**: Generiert mehrere Layout-Varianten parallel

## Architektur

```
┌─────────────────────────────────────────────────────────────┐
│                     REST Controllers                         │
│  (Products, Skills, Layouts, Images, PDF)                   │
├─────────────────────────────────────────────────────────────┤
│                      Services Layer                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ ProductSvc  │  │  SkillsSvc  │  │ LayoutGenerationSvc │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│                    Agent Framework                           │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              AgentOrchestrator                        │   │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────────┐    │   │
│  │  │  Linear    │ │ Iterative  │ │   Parallel     │    │   │
│  │  │  Pipeline  │ │  Pipeline  │ │   Pipeline     │    │   │
│  │  └────────────┘ └────────────┘ └────────────────┘    │   │
│  └──────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                    External Services                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │GeminiClient │  │ LLM Logger  │  │  PuppeteerBridge    │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## Voraussetzungen

### Lokal
- Java 21
- Node.js 20+ (für PDF-Generierung)
- Google Gemini API Key

### Dev Container (empfohlen)
- Docker
- VS Code mit Dev Containers Extension

## Schnellstart

### Option 1: Dev Container (empfohlen)

1. Repository öffnen in VS Code
2. `Cmd/Ctrl + Shift + P` → "Dev Containers: Reopen in Container"
3. Warten bis der Container gebaut ist
4. Gemini API Key setzen:
   ```bash
   export GEMINI_API_KEY=your-api-key
   ```
5. Anwendung starten:
   ```bash
   ./gradlew bootRun
   ```

### Option 2: Lokale Installation

1. **Java 21 installieren** (z.B. via SDKMAN):
   ```bash
   sdk install java 21-tem
   ```

2. **Node.js Dependencies installieren**:
   ```bash
   cd scripts
   npm install
   cd ..
   ```

3. **Umgebungsvariablen setzen**:
   ```bash
   cp .env.example .env
   # .env editieren und GEMINI_API_KEY setzen
   source .env
   ```

4. **Anwendung starten**:
   ```bash
   ./gradlew bootRun
   ```

Die API ist dann unter `http://localhost:8080` erreichbar.

## Konfiguration

### Umgebungsvariablen

| Variable | Beschreibung | Pflicht |
|----------|--------------|---------|
| `GEMINI_API_KEY` | Google Gemini API Key | Ja |

### application.yml

Wichtige Konfigurationsoptionen:

```yaml
catalogforge:
  gemini:
    api-key: ${GEMINI_API_KEY:}
    timeout-seconds: 60
    max-retries: 3
  
  layout:
    variant-count-default: 2
    max-variant-count: 5
    fallback-enabled: true
  
  images:
    expiration-hours: 24
```

## API-Endpoints

### Products
| Method | Endpoint | Beschreibung |
|--------|----------|--------------|
| GET | `/api/v1/products` | Alle Produkte (paginiert, filterbar) |
| GET | `/api/v1/products/{id}` | Einzelnes Produkt |
| GET | `/api/v1/products/categories` | Alle Kategorien |
| GET | `/api/v1/products/series` | Alle Serien |
| GET | `/api/v1/products/search?q={query}` | Volltextsuche |

### Skills
| Method | Endpoint | Beschreibung |
|--------|----------|--------------|
| GET | `/api/v1/skills` | Alle Skills |
| GET | `/api/v1/skills/{category}` | Skills nach Kategorie |
| GET | `/api/v1/skills/prompts/examples` | Beispiel-Prompts |

### Layouts
| Method | Endpoint | Beschreibung |
|--------|----------|--------------|
| POST | `/api/v1/layouts/generate/text` | Text-to-Layout |
| POST | `/api/v1/layouts/generate/image` | Image-to-Layout |
| GET | `/api/v1/layouts/{id}` | Layout abrufen |
| PUT | `/api/v1/layouts/{id}` | Layout aktualisieren |
| DELETE | `/api/v1/layouts/{id}` | Layout löschen |
| GET | `/api/v1/layouts/{id}/variants` | Layout-Varianten |

### Images
| Method | Endpoint | Beschreibung |
|--------|----------|--------------|
| POST | `/api/v1/images/upload` | Bild hochladen |
| GET | `/api/v1/images/{imageId}` | Bild abrufen |

### PDF
| Method | Endpoint | Beschreibung |
|--------|----------|--------------|
| POST | `/api/v1/pdf/generate` | PDF generieren |
| GET | `/api/v1/pdf/{id}/download` | PDF herunterladen |

## Entwicklung

### Tests ausführen
```bash
./gradlew test
```

### Build
```bash
./gradlew build
```

### Code-Stil
- Java 21 Features (Records, Pattern Matching)
- Spring Boot 3.4 Best Practices
- Property-Based Testing mit jqwik

## Projektstruktur

```
catForge-backend/
├── src/main/java/com/catalogforge/
│   ├── agent/           # Agent Framework (Pipelines, Steps)
│   ├── config/          # Spring Konfiguration
│   ├── controller/      # REST Controller
│   ├── exception/       # Exception Handling
│   ├── gemini/          # Gemini Client
│   ├── logging/         # LLM Logging
│   ├── model/           # Domain Models & DTOs
│   ├── pdf/             # PDF Generation
│   ├── service/         # Business Logic
│   ├── skills/          # Skills System
│   └── util/            # Utilities
├── src/main/resources/
│   ├── css/             # CSS Templates
│   ├── data/            # Produktdaten (JSON)
│   ├── prompts/         # Beispiel-Prompts
│   ├── skills/          # Skill Markdown Files
│   └── application.yml
├── scripts/             # Puppeteer PDF Generator
└── .devcontainer/       # Dev Container Config
```

## Skills-System

Skills sind modulare Markdown-Dateien für Prompt-Engineering:

- **Core**: Layout-Prinzipien, Typografie, Farben, Grid, Spacing
- **Styles**: Modern, Technical, Premium, Eco, Dynamic
- **Formats**: A4, A5, DL, A6, Square
- **Image-Analysis**: Farbextraktion, Stimmungsanalyse

## Lizenz

Proprietär - Alle Rechte vorbehalten.
</file>

<file path="settings.gradle.kts">
rootProject.name = "catalog-forge-backend"
</file>

</files>
