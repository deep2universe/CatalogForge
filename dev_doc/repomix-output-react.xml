This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  favicon.svg
src/
  api/
    client.ts
    errors.test.ts
    errors.ts
    images.ts
    index.ts
    layouts.ts
    pdf.ts
    products.ts
    skills.ts
    types.ts
  components/
    charts/
      BarChart.tsx
      index.ts
      PieChart.tsx
      StatCard.tsx
    features/
      preview/
        CodeEditor.tsx
        index.ts
        LayoutPreview.tsx
        PdfExport.tsx
        VariantSelector.tsx
      products/
        index.ts
        ProductCard.tsx
        ProductFilter.tsx
        ProductGrid.tsx
        ProductSearch.tsx
      prompts/
        index.ts
        PromptCard.tsx
        PromptDetail.tsx
        prompts.test.ts
      skills/
        CategoryFilter.tsx
        index.ts
        SkillCard.tsx
        SkillDetail.tsx
        skills.test.ts
      wizard/
        ChatInterface.tsx
        ImageUpload.tsx
        index.ts
        LayoutOptions.tsx
        ProductSelector.tsx
        PromptInput.tsx
        StepIndicator.tsx
        wizard.test.ts
    layout/
      AppLayout.tsx
      Header.tsx
      index.ts
      PageContainer.tsx
      Sidebar.test.tsx
      Sidebar.tsx
    ui/
      Badge.test.tsx
      Badge.tsx
      Button.test.tsx
      Button.tsx
      Card.tsx
      index.ts
      Input.tsx
      Modal.tsx
      Select.tsx
      Slider.tsx
      Spinner.tsx
      Tabs.tsx
      Toast.tsx
      Toggle.tsx
    ErrorBoundary.tsx
  context/
    index.ts
  hooks/
    index.ts
    useDebounce.ts
    useImageUpload.ts
    useLayouts.ts
    usePdf.ts
    useProducts.ts
    useSkills.ts
  pages/
    CatalogPreview/
      CatalogPreviewPage.tsx
    CatalogWizard/
      CatalogWizardPage.tsx
    Dashboard/
      DashboardPage.tsx
    PromptExplorer/
      PromptExplorerPage.tsx
    SkillExplorer/
      SkillExplorerPage.tsx
  store/
    wizardStore.test.ts
    wizardStore.ts
  styles/
    globals.css
  test/
    setup.ts
  utils/
    aggregations.test.ts
    aggregations.ts
    cn.ts
    errorMessages.test.ts
    errorMessages.ts
    filters.test.ts
    filters.ts
    formatters.ts
    index.ts
    pageFormats.test.ts
    pageFormats.ts
    validators.ts
  App.tsx
  main.tsx
  vite-env.d.ts
.env.example
.gitignore
index.html
package.json
postcss.config.js
tailwind.config.js
tsconfig.json
tsconfig.node.json
vite.config.ts
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#A8D5E5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/>
  <path d="M8 7h6"/>
  <path d="M8 11h8"/>
</svg>
</file>

<file path="src/api/client.ts">
import { ApiError } from './errors';
import type { ErrorResponse } from './types';

const API_BASE_URL = import.meta.env.VITE_API_URL || '/api/v1';

export async function apiClient<T>(
  endpoint: string,
  options?: RequestInit
): Promise<T> {
  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
    ...options,
  });

  if (!response.ok) {
    let errorResponse: ErrorResponse;
    try {
      errorResponse = await response.json();
    } catch {
      errorResponse = {
        timestamp: new Date().toISOString(),
        status: response.status,
        error: response.statusText,
        message: 'Ein unerwarteter Fehler ist aufgetreten.',
        path: endpoint,
      };
    }
    throw new ApiError(errorResponse);
  }

  if (response.status === 204) {
    return undefined as T;
  }

  return response.json();
}
</file>

<file path="src/api/errors.test.ts">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { ApiError, getErrorMessage, errorMessages } from './errors';
import type { ErrorResponse } from './types';

/**
 * Property 3: API Client Error Handling
 * Validates: Requirements 4.3
 */
describe('API Error Handling', () => {
  // Property: For any valid ErrorResponse, ApiError correctly extracts status
  it('should correctly extract status from any ErrorResponse', () => {
    fc.assert(
      fc.property(
        fc.record({
          timestamp: fc.string(),
          status: fc.integer({ min: 100, max: 599 }),
          error: fc.string(),
          message: fc.string(),
          path: fc.string(),
        }),
        (errorResponse: ErrorResponse) => {
          const apiError = new ApiError(errorResponse);
          expect(apiError.status).toBe(errorResponse.status);
          expect(apiError.message).toBe(errorResponse.message);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: isNotFound is true iff status === 404
  it('should correctly identify 404 errors', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 100, max: 599 }),
        (status) => {
          const errorResponse: ErrorResponse = {
            timestamp: new Date().toISOString(),
            status,
            error: 'Test',
            message: 'Test message',
            path: '/test',
          };
          const apiError = new ApiError(errorResponse);
          expect(apiError.isNotFound).toBe(status === 404);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: isValidationError is true iff status === 400
  it('should correctly identify validation errors', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 100, max: 599 }),
        (status) => {
          const errorResponse: ErrorResponse = {
            timestamp: new Date().toISOString(),
            status,
            error: 'Test',
            message: 'Test message',
            path: '/test',
          };
          const apiError = new ApiError(errorResponse);
          expect(apiError.isValidationError).toBe(status === 400);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: isServerError is true iff status >= 500
  it('should correctly identify server errors', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 100, max: 599 }),
        (status) => {
          const errorResponse: ErrorResponse = {
            timestamp: new Date().toISOString(),
            status,
            error: 'Test',
            message: 'Test message',
            path: '/test',
          };
          const apiError = new ApiError(errorResponse);
          expect(apiError.isServerError).toBe(status >= 500);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: getErrorMessage returns a known message for known codes, fallback otherwise
  it('should return appropriate error messages for any status code', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 100, max: 599 }),
        (status) => {
          const message = getErrorMessage(status);
          if (status in errorMessages) {
            expect(message).toBe(errorMessages[status]);
          } else {
            expect(message).toBe(errorMessages[500]);
          }
        }
      ),
      { numRuns: 100 }
    );
  });
});
</file>

<file path="src/api/errors.ts">
import type { ErrorResponse } from './types';

export class ApiError extends Error {
  constructor(public response: ErrorResponse) {
    super(response.message);
    this.name = 'ApiError';
  }

  get status() {
    return this.response.status;
  }

  get isNotFound() {
    return this.status === 404;
  }

  get isValidationError() {
    return this.status === 400;
  }

  get isServerError() {
    return this.status >= 500;
  }
}

export const errorMessages: Record<number, string> = {
  400: 'Ungültige Eingabe. Bitte überprüfen Sie Ihre Daten.',
  404: 'Die angeforderte Ressource wurde nicht gefunden.',
  413: 'Die Datei ist zu groß. Maximale Größe: 10MB.',
  502: 'Der KI-Service ist momentan nicht erreichbar. Bitte versuchen Sie es später erneut.',
  500: 'Ein unerwarteter Fehler ist aufgetreten.',
};

export function getErrorMessage(status: number): string {
  return errorMessages[status] || errorMessages[500];
}
</file>

<file path="src/api/images.ts">
import { apiClient } from './client';
import type { ImageUploadResponse } from './types';

const API_BASE_URL = import.meta.env.VITE_API_URL || '/api/v1';

export const imagesApi = {
  upload: async (file: File): Promise<ImageUploadResponse> => {
    const formData = new FormData();
    formData.append('file', file);

    const response = await fetch(`${API_BASE_URL}/images/upload`, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      throw new Error('Image upload failed');
    }

    return response.json();
  },

  uploadBase64: (base64Data: string, mimeType: string, filename?: string) =>
    apiClient<ImageUploadResponse>('/images/upload/base64', {
      method: 'POST',
      body: JSON.stringify({ base64Data, mimeType, filename }),
    }),
};
</file>

<file path="src/api/index.ts">
export * from './types';
export * from './errors';
export { apiClient } from './client';
export { productsApi } from './products';
export { layoutsApi } from './layouts';
export { skillsApi } from './skills';
export { pdfApi } from './pdf';
export { imagesApi } from './images';
</file>

<file path="src/api/layouts.ts">
import { apiClient } from './client';
import type {
  TextToLayoutRequest,
  ImageToLayoutRequest,
  LayoutResponse,
  VariantResponse,
} from './types';

export const layoutsApi = {
  generateFromText: (request: TextToLayoutRequest) =>
    apiClient<LayoutResponse>('/layouts/generate/text', {
      method: 'POST',
      body: JSON.stringify(request),
    }),

  generateFromImage: (request: ImageToLayoutRequest) =>
    apiClient<LayoutResponse>('/layouts/generate/image', {
      method: 'POST',
      body: JSON.stringify(request),
    }),

  getById: (id: string) => apiClient<LayoutResponse>(`/layouts/${id}`),

  update: (id: string, layout: Partial<LayoutResponse>) =>
    apiClient<LayoutResponse>(`/layouts/${id}`, {
      method: 'PUT',
      body: JSON.stringify(layout),
    }),

  delete: (id: string) =>
    apiClient<void>(`/layouts/${id}`, { method: 'DELETE' }),

  getVariants: (id: string) =>
    apiClient<VariantResponse[]>(`/layouts/${id}/variants`),
};
</file>

<file path="src/api/pdf.ts">
import { apiClient } from './client';
import type { PdfGenerateRequest, PdfGenerateResponse, PrintPreset } from './types';

const API_BASE_URL = import.meta.env.VITE_API_URL || '/api/v1';

export const pdfApi = {
  generate: (request: PdfGenerateRequest) =>
    apiClient<PdfGenerateResponse>('/pdf/generate', {
      method: 'POST',
      body: JSON.stringify(request),
    }),

  download: async (id: string): Promise<Blob> => {
    const response = await fetch(`${API_BASE_URL}/pdf/${id}/download`);
    if (!response.ok) {
      throw new Error('PDF download failed');
    }
    return response.blob();
  },

  getPresets: () => apiClient<PrintPreset[]>('/pdf/presets'),
};
</file>

<file path="src/api/products.ts">
import { apiClient } from './client';
import type { Product } from './types';

export const productsApi = {
  getAll: (category?: string, series?: string) => {
    const params = new URLSearchParams();
    if (category) params.set('category', category);
    if (series) params.set('series', series);
    const query = params.toString();
    return apiClient<Product[]>(`/products${query ? `?${query}` : ''}`);
  },

  getById: (id: number) => apiClient<Product>(`/products/${id}`),

  getCategories: () => apiClient<string[]>('/products/categories'),

  getSeries: () => apiClient<string[]>('/products/series'),

  search: (query: string) =>
    apiClient<Product[]>(`/products/search?q=${encodeURIComponent(query)}`),
};
</file>

<file path="src/api/skills.ts">
import { apiClient } from './client';
import type { Skill, ExamplePrompt } from './types';

export const skillsApi = {
  getAll: () => apiClient<Skill[]>('/skills'),

  getCategories: () => apiClient<string[]>('/skills/categories'),

  getByCategory: (category: string) =>
    apiClient<Skill[]>(`/skills/${category}`),

  getExamplePrompts: () =>
    apiClient<ExamplePrompt[]>('/skills/prompts/examples'),

  reload: () => apiClient<void>('/skills/reload', { method: 'POST' }),
};
</file>

<file path="src/api/types.ts">
// Products
export interface Product {
  id: number;
  name: string;
  shortDescription: string;
  description: string;
  longDescription: string;
  category: string;
  series: string;
  specs: Record<string, string>;
  highlights: string[];
  imageUrl: string;
  priceEur: number | null;
}

// Layouts
export type PageFormat = 'A4' | 'A5' | 'A6' | 'DL' | 'SQUARE';
export type LayoutStyle = 'modern' | 'technical' | 'premium' | 'eco' | 'dynamic';

export interface LayoutOptions {
  pageFormat?: PageFormat;
  style?: LayoutStyle;
  variantCount?: number;
  includeSpecs?: boolean;
  complexStrategy?: boolean;
}

export interface TextToLayoutRequest {
  productIds: number[];
  options?: LayoutOptions;
  prompt: string;
}

export interface ImageToLayoutRequest {
  productIds: number[];
  options?: LayoutOptions;
  prompt?: string;
  imageBase64: string;
  imageMimeType: string;
}

export interface VariantResponse {
  id: string;
  html: string;
  css: string;
}

export interface LayoutResponse {
  id: string;
  status: string;
  generatedAt: string;
  pageFormat: string;
  variants: VariantResponse[];
  variantCount: number;
}

// Skills
export interface Skill {
  name: string;
  category: string;
  content: string;
  dependencies: string[];
  priority: number;
}

export interface ExamplePrompt {
  id: string;
  title: string;
  description?: string;
  prompt: string;
  skills: string[];
  style: string;
  format: string;
}

// PDF
export interface PdfGenerateRequest {
  layoutId: string;
  variantId?: string;
  preset?: string;
}

export interface PdfGenerateResponse {
  pdfId: string;
  downloadUrl: string;
}

export interface PrintPreset {
  name: string;
  description: string;
  dpi: number;
  bleedMm: number;
  cropMarks: boolean;
}

// Images
export interface ImageUploadResponse {
  imageId: string;
  url: string;
  mimeType: string;
  expiresAt: string;
}

// Errors
export interface ErrorResponse {
  timestamp: string;
  status: number;
  error: string;
  message: string;
  path: string;
}
</file>

<file path="src/components/charts/BarChart.tsx">
import { BarChart as RechartsBarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { Card, CardHeader, CardContent } from '@/components/ui';

interface BarChartData {
  name: string;
  value: number;
}

interface BarChartProps {
  title: string;
  data: BarChartData[];
  color?: string;
  onBarClick?: (name: string) => void;
}

export function BarChart({ title, data, color = '#A8D5E5', onBarClick }: BarChartProps) {
  return (
    <Card>
      <CardHeader>
        <h3 className="text-lg font-semibold text-neutral-800">{title}</h3>
      </CardHeader>
      <CardContent>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <RechartsBarChart data={data} layout="vertical">
              <CartesianGrid strokeDasharray="3 3" stroke="#E5E5E5" />
              <XAxis type="number" tick={{ fill: '#525252', fontSize: 12 }} />
              <YAxis
                type="category"
                dataKey="name"
                tick={{ fill: '#525252', fontSize: 12 }}
                width={100}
              />
              <Tooltip
                contentStyle={{
                  backgroundColor: 'white',
                  border: '1px solid #E5E5E5',
                  borderRadius: '8px',
                }}
              />
              <Bar
                dataKey="value"
                fill={color}
                radius={[0, 4, 4, 0]}
                onClick={(entry) => onBarClick?.(entry.name)}
                style={{ cursor: onBarClick ? 'pointer' : 'default' }}
              />
            </RechartsBarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/charts/index.ts">
export { StatCard } from './StatCard';
export { PieChart } from './PieChart';
export { BarChart } from './BarChart';
</file>

<file path="src/components/charts/PieChart.tsx">
import { PieChart as RechartsPieChart, Pie, Cell, ResponsiveContainer, Tooltip, Legend } from 'recharts';
import { Card, CardHeader, CardContent } from '@/components/ui';

interface PieChartData {
  name: string;
  value: number;
}

interface PieChartProps {
  title: string;
  data: PieChartData[];
  onSegmentClick?: (name: string) => void;
}

const COLORS = [
  '#A8D5E5', // pastel-blue
  '#B5E5CF', // pastel-green
  '#D4B5E5', // pastel-purple
  '#F5E6A3', // pastel-yellow
  '#E5CDB5', // pastel-orange
  '#E5B5B5', // pastel-red
];

export function PieChart({ title, data, onSegmentClick }: PieChartProps) {
  return (
    <Card>
      <CardHeader>
        <h3 className="text-lg font-semibold text-neutral-800">{title}</h3>
      </CardHeader>
      <CardContent>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <RechartsPieChart>
              <Pie
                data={data}
                cx="50%"
                cy="50%"
                innerRadius={60}
                outerRadius={80}
                paddingAngle={2}
                dataKey="value"
                onClick={(entry) => onSegmentClick?.(entry.name)}
                style={{ cursor: onSegmentClick ? 'pointer' : 'default' }}
              >
                {data.map((_, index) => (
                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                ))}
              </Pie>
              <Tooltip
                contentStyle={{
                  backgroundColor: 'white',
                  border: '1px solid #E5E5E5',
                  borderRadius: '8px',
                }}
              />
              <Legend />
            </RechartsPieChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/charts/StatCard.tsx">
import type { LucideIcon } from 'lucide-react';
import { Card } from '@/components/ui';
import { cn } from '@/utils/cn';

interface StatCardProps {
  title: string;
  value: number | string;
  icon: LucideIcon;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  onClick?: () => void;
  className?: string;
}

export function StatCard({ title, value, icon: Icon, trend, onClick, className }: StatCardProps) {
  return (
    <Card
      hoverable={!!onClick}
      onClick={onClick}
      className={cn('p-6', className)}
    >
      <div className="flex items-start justify-between">
        <div>
          <p className="text-sm text-neutral-600">{title}</p>
          <p className="mt-2 text-3xl font-semibold text-neutral-800">{value}</p>
          {trend && (
            <p
              className={cn(
                'mt-1 text-sm',
                trend.isPositive ? 'text-pastel-green-dark' : 'text-pastel-red-dark'
              )}
            >
              {trend.isPositive ? '↑' : '↓'} {Math.abs(trend.value)}%
            </p>
          )}
        </div>
        <div className="p-3 bg-pastel-blue-light rounded-lg">
          <Icon className="h-6 w-6 text-pastel-blue-dark" />
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/components/features/preview/CodeEditor.tsx">
import { useState } from 'react';
import { cn } from '@/utils/cn';
import { Button } from '@/components/ui';

interface CodeEditorProps {
  html: string;
  css: string;
  onHtmlChange?: (html: string) => void;
  onCssChange?: (css: string) => void;
  readOnly?: boolean;
}

type Tab = 'html' | 'css';

export function CodeEditor({
  html,
  css,
  onHtmlChange,
  onCssChange,
  readOnly = false,
}: CodeEditorProps) {
  const [activeTab, setActiveTab] = useState<Tab>('html');
  const [copied, setCopied] = useState(false);

  const currentCode = activeTab === 'html' ? html : css;
  const handleChange = activeTab === 'html' ? onHtmlChange : onCssChange;

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(currentCode);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  return (
    <div className="flex flex-col h-full border border-neutral-200 rounded-lg overflow-hidden">
      {/* Tabs */}
      <div className="flex items-center justify-between border-b border-neutral-200 bg-neutral-50 px-2">
        <div className="flex">
          <button
            onClick={() => setActiveTab('html')}
            className={cn(
              'px-4 py-2 text-sm font-medium transition-colors',
              activeTab === 'html'
                ? 'text-neutral-800 border-b-2 border-pastel-blue'
                : 'text-neutral-500 hover:text-neutral-700'
            )}
          >
            HTML
          </button>
          <button
            onClick={() => setActiveTab('css')}
            className={cn(
              'px-4 py-2 text-sm font-medium transition-colors',
              activeTab === 'css'
                ? 'text-neutral-800 border-b-2 border-pastel-blue'
                : 'text-neutral-500 hover:text-neutral-700'
            )}
          >
            CSS
          </button>
        </div>
        <Button variant="ghost" size="sm" onClick={handleCopy}>
          {copied ? 'Kopiert!' : 'Kopieren'}
        </Button>
      </div>

      {/* Editor */}
      <div className="flex-1 overflow-auto">
        <textarea
          value={currentCode}
          onChange={(e) => handleChange?.(e.target.value)}
          readOnly={readOnly}
          spellCheck={false}
          className={cn(
            'w-full h-full p-4 font-mono text-sm bg-neutral-900 text-neutral-100 resize-none',
            'focus:outline-none',
            readOnly && 'cursor-default'
          )}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/components/features/preview/index.ts">
export { LayoutPreview } from './LayoutPreview';
export { VariantSelector } from './VariantSelector';
export { CodeEditor } from './CodeEditor';
export { PdfExport } from './PdfExport';
</file>

<file path="src/components/features/preview/LayoutPreview.tsx">
import { useState, useRef, useEffect } from 'react';
import { cn } from '@/utils/cn';
import { Button } from '@/components/ui';
import type { VariantResponse } from '@/api';

interface LayoutPreviewProps {
  variant: VariantResponse | null;
  pageFormat?: string;
  className?: string;
}

const ZOOM_LEVELS = [50, 75, 100, 125, 150];

export function LayoutPreview({ variant, pageFormat = 'A4', className }: LayoutPreviewProps) {
  const [zoom, setZoom] = useState(100);
  const iframeRef = useRef<HTMLIFrameElement>(null);

  // Update iframe content when variant changes
  useEffect(() => {
    if (iframeRef.current && variant) {
      const doc = iframeRef.current.contentDocument;
      if (doc) {
        doc.open();
        doc.write(`
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              * { margin: 0; padding: 0; box-sizing: border-box; }
              body { 
                font-family: 'Inter', system-ui, sans-serif;
                background: white;
              }
              ${variant.css}
            </style>
          </head>
          <body>
            ${variant.html}
          </body>
          </html>
        `);
        doc.close();
      }
    }
  }, [variant]);

  const handleZoomIn = () => {
    const currentIndex = ZOOM_LEVELS.indexOf(zoom);
    if (currentIndex < ZOOM_LEVELS.length - 1) {
      setZoom(ZOOM_LEVELS[currentIndex + 1]);
    }
  };

  const handleZoomOut = () => {
    const currentIndex = ZOOM_LEVELS.indexOf(zoom);
    if (currentIndex > 0) {
      setZoom(ZOOM_LEVELS[currentIndex - 1]);
    }
  };

  const handleResetZoom = () => setZoom(100);

  // Get aspect ratio based on page format
  const getAspectRatio = () => {
    switch (pageFormat) {
      case 'A4': return 'aspect-[210/297]';
      case 'A5': return 'aspect-[148/210]';
      case 'A6': return 'aspect-[105/148]';
      case 'DL': return 'aspect-[99/210]';
      case 'SQUARE': return 'aspect-square';
      default: return 'aspect-[210/297]';
    }
  };

  if (!variant) {
    return (
      <div className={cn('flex items-center justify-center bg-neutral-100 rounded-lg p-8', className)}>
        <p className="text-neutral-500">Kein Layout ausgewählt</p>
      </div>
    );
  }

  return (
    <div className={cn('flex flex-col', className)}>
      {/* Zoom Controls */}
      <div className="flex items-center justify-between mb-4 px-2">
        <div className="flex items-center gap-2">
          <Button
            variant="secondary"
            size="sm"
            onClick={handleZoomOut}
            disabled={zoom === ZOOM_LEVELS[0]}
          >
            −
          </Button>
          <span className="text-sm text-neutral-600 min-w-[4rem] text-center">
            {zoom}%
          </span>
          <Button
            variant="secondary"
            size="sm"
            onClick={handleZoomIn}
            disabled={zoom === ZOOM_LEVELS[ZOOM_LEVELS.length - 1]}
          >
            +
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={handleResetZoom}
          >
            Zurücksetzen
          </Button>
        </div>
        <span className="text-sm text-neutral-500">
          Format: {pageFormat}
        </span>
      </div>

      {/* Preview Container */}
      <div className="flex-1 overflow-auto bg-neutral-100 rounded-lg p-4">
        <div
          className="mx-auto transition-transform origin-top"
          style={{ transform: `scale(${zoom / 100})` }}
        >
          <div className={cn('bg-white shadow-lg mx-auto', getAspectRatio(), 'w-[210mm] max-w-full')}>
            <iframe
              ref={iframeRef}
              title="Layout Preview"
              className="w-full h-full border-0"
              sandbox="allow-same-origin"
            />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/features/preview/PdfExport.tsx">
import { useState } from 'react';
import { Button, Spinner } from '@/components/ui';
import { cn } from '@/utils/cn';
import { useGeneratePdf, usePrintPresets } from '@/hooks/usePdf';
import type { PrintPreset } from '@/api';

interface PdfExportProps {
  layoutId: string;
  variantId?: string;
  disabled?: boolean;
}

export function PdfExport({ layoutId, variantId, disabled = false }: PdfExportProps) {
  const [selectedPreset, setSelectedPreset] = useState<string>('standard');
  const { data: presets, isLoading: presetsLoading } = usePrintPresets();
  const generatePdf = useGeneratePdf();

  const handleExport = async () => {
    try {
      const result = await generatePdf.mutateAsync({
        layoutId,
        variantId,
        preset: selectedPreset,
      });
      
      // Open download URL in new tab
      window.open(result.downloadUrl, '_blank');
    } catch (err) {
      console.error('PDF export failed:', err);
    }
  };

  return (
    <div className="space-y-4">
      <h3 className="text-sm font-medium text-neutral-800">PDF Export</h3>
      
      {/* Preset Selection */}
      <div className="space-y-2">
        <label className="text-sm text-neutral-600">Druckprofil</label>
        {presetsLoading ? (
          <div className="flex justify-center py-4">
            <Spinner size="sm" />
          </div>
        ) : (
          <div className="space-y-2">
            {(presets || defaultPresets).map((preset) => (
              <PresetOption
                key={preset.name}
                preset={preset}
                selected={selectedPreset === preset.name}
                onSelect={() => setSelectedPreset(preset.name)}
              />
            ))}
          </div>
        )}
      </div>

      {/* Export Button */}
      <Button
        onClick={handleExport}
        disabled={disabled || generatePdf.isPending}
        isLoading={generatePdf.isPending}
        className="w-full"
      >
        {generatePdf.isPending ? 'Exportiere...' : 'Als PDF exportieren'}
      </Button>

      {generatePdf.isError && (
        <p className="text-sm text-pastel-red-dark">
          Export fehlgeschlagen. Bitte versuchen Sie es erneut.
        </p>
      )}
    </div>
  );
}

interface PresetOptionProps {
  preset: PrintPreset;
  selected: boolean;
  onSelect: () => void;
}

function PresetOption({ preset, selected, onSelect }: PresetOptionProps) {
  return (
    <button
      onClick={onSelect}
      className={cn(
        'w-full text-left p-3 rounded-lg border-2 transition-colors',
        selected
          ? 'border-pastel-blue bg-pastel-blue-light'
          : 'border-neutral-200 hover:border-neutral-300'
      )}
    >
      <p className="text-sm font-medium text-neutral-800">{preset.name}</p>
      <p className="text-xs text-neutral-500 mt-1">{preset.description}</p>
      <div className="flex gap-3 mt-2 text-xs text-neutral-500">
        <span>{preset.dpi} DPI</span>
        {preset.bleedMm > 0 && <span>{preset.bleedMm}mm Beschnitt</span>}
        {preset.cropMarks && <span>Schnittmarken</span>}
      </div>
    </button>
  );
}

const defaultPresets: PrintPreset[] = [
  {
    name: 'standard',
    description: 'Für digitale Nutzung und Bürodrucker',
    dpi: 150,
    bleedMm: 0,
    cropMarks: false,
  },
  {
    name: 'professional',
    description: 'Für professionellen Druck mit Beschnitt',
    dpi: 300,
    bleedMm: 3,
    cropMarks: true,
  },
  {
    name: 'offset',
    description: 'Für Offset-Druck mit erweiterten Einstellungen',
    dpi: 300,
    bleedMm: 5,
    cropMarks: true,
  },
];
</file>

<file path="src/components/features/preview/VariantSelector.tsx">
import { cn } from '@/utils/cn';
import type { VariantResponse } from '@/api';

interface VariantSelectorProps {
  variants: VariantResponse[];
  selectedId: string | null;
  onSelect: (id: string) => void;
  disabled?: boolean;
}

export function VariantSelector({
  variants,
  selectedId,
  onSelect,
  disabled = false,
}: VariantSelectorProps) {
  if (variants.length === 0) {
    return (
      <div className="text-center py-4 text-neutral-500">
        Keine Varianten verfügbar
      </div>
    );
  }

  return (
    <div className="space-y-3">
      <h3 className="text-sm font-medium text-neutral-700">
        Varianten ({variants.length})
      </h3>
      <div className="grid grid-cols-2 gap-3">
        {variants.map((variant, index) => (
          <button
            key={variant.id}
            onClick={() => onSelect(variant.id)}
            disabled={disabled}
            className={cn(
              'relative rounded-lg border-2 p-2 transition-all',
              'focus:outline-none focus:ring-2 focus:ring-pastel-blue focus:ring-offset-2',
              selectedId === variant.id
                ? 'border-pastel-blue bg-pastel-blue/10'
                : 'border-neutral-200 hover:border-neutral-300',
              disabled && 'opacity-50 cursor-not-allowed'
            )}
          >
            {/* Thumbnail Preview */}
            <div className="aspect-[3/4] bg-neutral-100 rounded overflow-hidden mb-2">
              <VariantThumbnail variant={variant} />
            </div>
            
            {/* Label */}
            <p className="text-xs font-medium text-neutral-700">
              Variante {index + 1}
            </p>
            
            {/* Selected Indicator */}
            {selectedId === variant.id && (
              <div className="absolute top-1 right-1 w-5 h-5 bg-pastel-blue rounded-full flex items-center justify-center">
                <svg
                  className="w-3 h-3 text-white"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={3}
                    d="M5 13l4 4L19 7"
                  />
                </svg>
              </div>
            )}
          </button>
        ))}
      </div>
    </div>
  );
}

// Mini thumbnail component that renders HTML/CSS preview
function VariantThumbnail({ variant }: { variant: VariantResponse }) {
  return (
    <iframe
      srcDoc={`
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body { 
              font-family: 'Inter', system-ui, sans-serif;
              transform: scale(0.15);
              transform-origin: top left;
              width: 666%;
              height: 666%;
            }
            ${variant.css}
          </style>
        </head>
        <body>${variant.html}</body>
        </html>
      `}
      title="Variant Thumbnail"
      className="w-full h-full border-0 pointer-events-none"
      sandbox="allow-same-origin"
    />
  );
}
</file>

<file path="src/components/features/products/index.ts">
export { ProductCard } from './ProductCard';
export { ProductGrid } from './ProductGrid';
export { ProductSearch } from './ProductSearch';
export { ProductFilter } from './ProductFilter';
</file>

<file path="src/components/features/products/ProductCard.tsx">
import type { Product } from '@/api';
import { Card, Badge } from '@/components/ui';
import { formatPrice } from '@/utils';

interface ProductCardProps {
  product: Product;
  onClick?: () => void;
}

export function ProductCard({ product, onClick }: ProductCardProps) {
  return (
    <Card hoverable onClick={onClick} className="overflow-hidden">
      <div className="aspect-video bg-neutral-100 relative">
        {product.imageUrl ? (
          <img
            src={product.imageUrl}
            alt={product.name}
            className="w-full h-full object-cover"
            loading="lazy"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center text-neutral-400">
            Kein Bild
          </div>
        )}
      </div>
      <div className="p-4">
        <div className="flex items-start justify-between gap-2">
          <h3 className="font-semibold text-neutral-800 line-clamp-1">{product.name}</h3>
          <Badge variant="blue">{product.category}</Badge>
        </div>
        <p className="mt-1 text-sm text-neutral-600 line-clamp-2">
          {product.shortDescription}
        </p>
        <div className="mt-3 flex items-center justify-between">
          <span className="text-xs text-neutral-500">{product.series}</span>
          <span className="font-medium text-neutral-800">
            {formatPrice(product.priceEur)}
          </span>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/components/features/products/ProductFilter.tsx">
import { Select } from '@/components/ui';

interface ProductFilterProps {
  categories: string[];
  series: string[];
  selectedCategory: string;
  selectedSeries: string;
  onCategoryChange: (category: string) => void;
  onSeriesChange: (series: string) => void;
}

export function ProductFilter({
  categories,
  series,
  selectedCategory,
  selectedSeries,
  onCategoryChange,
  onSeriesChange,
}: ProductFilterProps) {
  return (
    <div className="flex flex-wrap gap-4">
      <Select
        value={selectedCategory}
        onChange={(e) => onCategoryChange(e.target.value)}
        className="w-48"
      >
        <option value="">Alle Kategorien</option>
        {categories.map((category) => (
          <option key={category} value={category}>
            {category}
          </option>
        ))}
      </Select>

      <Select
        value={selectedSeries}
        onChange={(e) => onSeriesChange(e.target.value)}
        className="w-48"
      >
        <option value="">Alle Baureihen</option>
        {series.map((s) => (
          <option key={s} value={s}>
            {s}
          </option>
        ))}
      </Select>
    </div>
  );
}
</file>

<file path="src/components/features/products/ProductGrid.tsx">
import type { Product } from '@/api';
import { ProductCard } from './ProductCard';

interface ProductGridProps {
  products: Product[];
  onProductClick?: (product: Product) => void;
}

export function ProductGrid({ products, onProductClick }: ProductGridProps) {
  if (products.length === 0) {
    return (
      <div className="text-center py-12 text-neutral-500">
        Keine Produkte gefunden.
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
      {products.map((product) => (
        <ProductCard
          key={product.id}
          product={product}
          onClick={() => onProductClick?.(product)}
        />
      ))}
    </div>
  );
}
</file>

<file path="src/components/features/products/ProductSearch.tsx">
import { Search } from 'lucide-react';
import { Input } from '@/components/ui';

interface ProductSearchProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}

export function ProductSearch({ value, onChange, placeholder = 'Suchen...' }: ProductSearchProps) {
  return (
    <div className="relative">
      <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-neutral-400" />
      <Input
        type="search"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="pl-10"
      />
    </div>
  );
}
</file>

<file path="src/components/features/prompts/index.ts">
export { PromptCard } from './PromptCard';
export { PromptDetail } from './PromptDetail';
</file>

<file path="src/components/features/prompts/PromptCard.tsx">
import type { ExamplePrompt } from '@/api';
import { Card, Badge, Button } from '@/components/ui';
import { styleToBadgeVariant } from '@/components/ui/Badge';
import { truncateText } from '@/utils';
import type { LayoutStyle } from '@/api';

interface PromptCardProps {
  prompt: ExamplePrompt;
  onClick?: () => void;
  onUse?: () => void;
}

export function PromptCard({ prompt, onClick, onUse }: PromptCardProps) {
  const styleVariant = styleToBadgeVariant[prompt.style as LayoutStyle] || 'default';

  return (
    <Card hoverable onClick={onClick} className="p-4 flex flex-col">
      <h3 className="font-semibold text-neutral-800 mb-2">{prompt.title}</h3>
      <p className="text-sm text-neutral-600 flex-1 mb-3">
        {truncateText(prompt.description || prompt.prompt, 100)}
      </p>
      <div className="flex flex-wrap gap-2 mb-3">
        <Badge variant={styleVariant}>{prompt.style}</Badge>
        <Badge variant="default">{prompt.format}</Badge>
      </div>
      <Button
        variant="secondary"
        size="sm"
        onClick={(e) => {
          e.stopPropagation();
          onUse?.();
        }}
        className="w-full"
      >
        Verwenden →
      </Button>
    </Card>
  );
}
</file>

<file path="src/components/features/prompts/PromptDetail.tsx">
import type { ExamplePrompt } from '@/api';
import { Badge, Button } from '@/components/ui';
import { styleToBadgeVariant } from '@/components/ui/Badge';
import type { LayoutStyle } from '@/api';

interface PromptDetailProps {
  prompt: ExamplePrompt;
  onUse?: () => void;
}

export function PromptDetail({ prompt, onUse }: PromptDetailProps) {
  const styleVariant = styleToBadgeVariant[prompt.style as LayoutStyle] || 'default';

  return (
    <div className="space-y-4">
      {prompt.description && (
        <div>
          <h4 className="text-sm font-medium text-neutral-800 mb-1">Beschreibung</h4>
          <p className="text-sm text-neutral-600">{prompt.description}</p>
        </div>
      )}

      <div>
        <h4 className="text-sm font-medium text-neutral-800 mb-2">Prompt</h4>
        <div className="bg-neutral-50 rounded-lg p-4 text-sm text-neutral-700 whitespace-pre-wrap">
          {prompt.prompt}
        </div>
      </div>

      <div>
        <h4 className="text-sm font-medium text-neutral-800 mb-2">Optionen</h4>
        <ul className="text-sm text-neutral-600 space-y-1">
          <li className="flex items-center gap-2">
            <span className="text-neutral-500">Format:</span>
            <Badge variant="default">{prompt.format}</Badge>
          </li>
          <li className="flex items-center gap-2">
            <span className="text-neutral-500">Stil:</span>
            <Badge variant={styleVariant}>{prompt.style}</Badge>
          </li>
        </ul>
      </div>

      {prompt.skills.length > 0 && (
        <div>
          <h4 className="text-sm font-medium text-neutral-800 mb-2">Verwendete Skills</h4>
          <div className="flex flex-wrap gap-2">
            {prompt.skills.map((skill) => (
              <Badge key={skill} variant="blue">
                {skill}
              </Badge>
            ))}
          </div>
        </div>
      )}

      <Button onClick={onUse} className="w-full">
        Im Wizard verwenden
      </Button>
    </div>
  );
}
</file>

<file path="src/components/features/prompts/prompts.test.ts">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import type { ExamplePrompt, LayoutStyle, PageFormat } from '@/api';
import { filterPrompts } from '@/utils';

/**
 * Property 7: Prompt Display and Filtering
 * Validates: Requirements 8.4, 8.5, 8.7
 */
describe('Prompt Display and Filtering', () => {
  const styles: LayoutStyle[] = ['modern', 'technical', 'premium', 'eco', 'dynamic'];
  const formats: PageFormat[] = ['A4', 'A5', 'A6', 'DL', 'SQUARE'];

  const promptArbitrary = fc.record({
    id: fc.uuid(),
    title: fc.string({ minLength: 1, maxLength: 50 }),
    description: fc.string({ minLength: 0, maxLength: 200 }),
    prompt: fc.string({ minLength: 10, maxLength: 500 }),
    skills: fc.array(fc.string({ minLength: 1, maxLength: 20 }), { maxLength: 5 }),
    style: fc.constantFrom(...styles),
    format: fc.constantFrom(...formats),
  }) as fc.Arbitrary<ExamplePrompt>;

  // Property: Filtering by 'all' style returns all prompts
  it('should return all prompts when filtering by "all" style', () => {
    fc.assert(
      fc.property(
        fc.array(promptArbitrary, { minLength: 0, maxLength: 20 }),
        (prompts) => {
          const filtered = filterPrompts(prompts, 'all', undefined);
          expect(filtered.length).toBe(prompts.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering by 'all' format returns all prompts
  it('should return all prompts when filtering by "all" format', () => {
    fc.assert(
      fc.property(
        fc.array(promptArbitrary, { minLength: 0, maxLength: 20 }),
        (prompts) => {
          const filtered = filterPrompts(prompts, undefined, 'all');
          expect(filtered.length).toBe(prompts.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering by style returns only prompts of that style
  it('should filter prompts by style correctly', () => {
    fc.assert(
      fc.property(
        fc.array(promptArbitrary, { minLength: 1, maxLength: 20 }),
        fc.constantFrom(...styles),
        (prompts, style) => {
          const filtered = filterPrompts(prompts, style, undefined);
          filtered.forEach((prompt) => {
            expect(prompt.style).toBe(style);
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering by format returns only prompts of that format
  it('should filter prompts by format correctly', () => {
    fc.assert(
      fc.property(
        fc.array(promptArbitrary, { minLength: 1, maxLength: 20 }),
        fc.constantFrom(...formats),
        (prompts, format) => {
          const filtered = filterPrompts(prompts, undefined, format);
          filtered.forEach((prompt) => {
            expect(prompt.format).toBe(format);
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering by both style and format returns intersection
  it('should filter prompts by both style and format correctly', () => {
    fc.assert(
      fc.property(
        fc.array(promptArbitrary, { minLength: 1, maxLength: 20 }),
        fc.constantFrom(...styles),
        fc.constantFrom(...formats),
        (prompts, style, format) => {
          const filtered = filterPrompts(prompts, style, format);
          filtered.forEach((prompt) => {
            expect(prompt.style).toBe(style);
            expect(prompt.format).toBe(format);
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering never increases the number of prompts
  it('should never increase prompt count when filtering', () => {
    fc.assert(
      fc.property(
        fc.array(promptArbitrary, { minLength: 0, maxLength: 20 }),
        fc.option(fc.constantFrom(...styles, 'all'), { nil: undefined }),
        fc.option(fc.constantFrom(...formats, 'all'), { nil: undefined }),
        (prompts, style, format) => {
          const filtered = filterPrompts(prompts, style as LayoutStyle | 'all', format as PageFormat | 'all');
          expect(filtered.length).toBeLessThanOrEqual(prompts.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: All prompts have required fields
  it('should have all required fields in prompts', () => {
    fc.assert(
      fc.property(
        promptArbitrary,
        (prompt) => {
          expect(prompt.id).toBeDefined();
          expect(prompt.title.length).toBeGreaterThan(0);
          expect(prompt.prompt.length).toBeGreaterThan(0);
          expect(styles).toContain(prompt.style);
          expect(formats).toContain(prompt.format);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering is idempotent
  it('should be idempotent when filtering', () => {
    fc.assert(
      fc.property(
        fc.array(promptArbitrary, { minLength: 0, maxLength: 20 }),
        fc.constantFrom(...styles),
        fc.constantFrom(...formats),
        (prompts, style, format) => {
          const filtered1 = filterPrompts(prompts, style, format);
          const filtered2 = filterPrompts(filtered1, style, format);
          expect(filtered1).toEqual(filtered2);
        }
      ),
      { numRuns: 100 }
    );
  });
});
</file>

<file path="src/components/features/skills/CategoryFilter.tsx">
import { cn } from '@/utils/cn';

interface CategoryFilterProps {
  categories: string[];
  selected: string;
  onChange: (category: string) => void;
}

export function CategoryFilter({ categories, selected, onChange }: CategoryFilterProps) {
  const allCategories = ['all', ...categories];

  const labels: Record<string, string> = {
    all: 'Alle Skills',
    core: 'Kern-Skills',
    styles: 'Stil-Skills',
    formats: 'Format-Skills',
  };

  return (
    <div className="space-y-1">
      {allCategories.map((category) => (
        <button
          key={category}
          onClick={() => onChange(category)}
          className={cn(
            'w-full text-left px-3 py-2 rounded-lg text-sm transition-colors',
            selected === category
              ? 'bg-pastel-blue text-neutral-800 font-medium'
              : 'text-neutral-600 hover:bg-neutral-100'
          )}
        >
          {labels[category] || category}
        </button>
      ))}
    </div>
  );
}
</file>

<file path="src/components/features/skills/index.ts">
export { SkillCard } from './SkillCard';
export { SkillDetail } from './SkillDetail';
export { CategoryFilter } from './CategoryFilter';
</file>

<file path="src/components/features/skills/SkillCard.tsx">
import type { Skill } from '@/api';
import { Card, Badge } from '@/components/ui';

interface SkillCardProps {
  skill: Skill;
  onClick?: () => void;
}

const categoryColors: Record<string, 'blue' | 'purple' | 'orange'> = {
  core: 'blue',
  styles: 'purple',
  formats: 'orange',
};

export function SkillCard({ skill, onClick }: SkillCardProps) {
  return (
    <Card hoverable onClick={onClick} className="p-4">
      <div className="flex items-start justify-between gap-2 mb-2">
        <h3 className="font-semibold text-neutral-800 text-sm uppercase tracking-wide">
          {skill.name.replace(/_/g, ' ')}
        </h3>
        <Badge variant={categoryColors[skill.category] || 'default'}>
          {skill.category}
        </Badge>
      </div>
      <div className="flex items-center gap-2 text-xs text-neutral-500">
        <span>Priorität: {skill.priority}</span>
        {skill.dependencies.length > 0 && (
          <span>• {skill.dependencies.length} Abhängigkeiten</span>
        )}
      </div>
    </Card>
  );
}
</file>

<file path="src/components/features/skills/SkillDetail.tsx">
import ReactMarkdown from 'react-markdown';
import type { Skill } from '@/api';
import { Badge } from '@/components/ui';

interface SkillDetailProps {
  skill: Skill;
  onDependencyClick?: (name: string) => void;
}

const categoryColors: Record<string, 'blue' | 'purple' | 'orange'> = {
  core: 'blue',
  styles: 'purple',
  formats: 'orange',
};

export function SkillDetail({ skill, onDependencyClick }: SkillDetailProps) {
  return (
    <div className="space-y-4">
      <div className="flex items-center gap-4">
        <Badge variant={categoryColors[skill.category] || 'default'}>
          {skill.category}
        </Badge>
        <span className="text-sm text-neutral-500">Priorität: {skill.priority}</span>
      </div>

      {skill.dependencies.length > 0 && (
        <div>
          <h4 className="text-sm font-medium text-neutral-800 mb-2">Abhängigkeiten</h4>
          <div className="flex flex-wrap gap-2">
            {skill.dependencies.map((dep) => (
              <button
                key={dep}
                onClick={() => onDependencyClick?.(dep)}
                className="px-2 py-1 text-xs bg-neutral-100 hover:bg-neutral-200 rounded transition-colors"
              >
                {dep}
              </button>
            ))}
          </div>
        </div>
      )}

      <div className="border-t border-neutral-200 pt-4">
        <h4 className="text-sm font-medium text-neutral-800 mb-2">Inhalt</h4>
        <div className="prose prose-sm max-w-none text-neutral-600">
          <ReactMarkdown>{skill.content}</ReactMarkdown>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/features/skills/skills.test.ts">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import type { Skill } from '@/api';
import { filterSkills, sortSkills } from '@/utils';

/**
 * Property 6: Skill Display and Filtering
 * Validates: Requirements 7.4, 7.5, 7.7
 */
describe('Skill Display and Filtering', () => {
  const skillArbitrary = fc.record({
    name: fc.string({ minLength: 1, maxLength: 30 }).map((s) => s.toUpperCase().replace(/\s/g, '_')),
    category: fc.constantFrom('core', 'styles', 'formats'),
    content: fc.string({ minLength: 10, maxLength: 500 }),
    dependencies: fc.array(fc.string({ minLength: 1, maxLength: 20 }), { maxLength: 5 }),
    priority: fc.integer({ min: 0, max: 100 }),
  }) as fc.Arbitrary<Skill>;

  // Property: Filtering by 'all' returns all skills
  it('should return all skills when filtering by "all"', () => {
    fc.assert(
      fc.property(
        fc.array(skillArbitrary, { minLength: 0, maxLength: 30 }),
        (skills) => {
          const filtered = filterSkills(skills, 'all');
          expect(filtered.length).toBe(skills.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering by undefined returns all skills
  it('should return all skills when filtering by undefined', () => {
    fc.assert(
      fc.property(
        fc.array(skillArbitrary, { minLength: 0, maxLength: 30 }),
        (skills) => {
          const filtered = filterSkills(skills, undefined);
          expect(filtered.length).toBe(skills.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering by category returns only skills of that category
  it('should filter skills by category correctly', () => {
    fc.assert(
      fc.property(
        fc.array(skillArbitrary, { minLength: 1, maxLength: 30 }),
        fc.constantFrom('core', 'styles', 'formats'),
        (skills, category) => {
          const filtered = filterSkills(skills, category);
          filtered.forEach((skill) => {
            expect(skill.category).toBe(category);
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering never increases the number of skills
  it('should never increase skill count when filtering', () => {
    fc.assert(
      fc.property(
        fc.array(skillArbitrary, { minLength: 0, maxLength: 30 }),
        fc.constantFrom('all', 'core', 'styles', 'formats'),
        (skills, category) => {
          const filtered = filterSkills(skills, category);
          expect(filtered.length).toBeLessThanOrEqual(skills.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Sorting preserves all elements
  it('should preserve all elements when sorting', () => {
    fc.assert(
      fc.property(
        fc.array(skillArbitrary, { minLength: 0, maxLength: 30 }),
        (skills) => {
          const sorted = sortSkills(skills);
          expect(sorted.length).toBe(skills.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Sorting produces ascending priority order
  it('should sort skills by priority in ascending order', () => {
    fc.assert(
      fc.property(
        fc.array(skillArbitrary, { minLength: 2, maxLength: 30 }),
        (skills) => {
          const sorted = sortSkills(skills);
          for (let i = 1; i < sorted.length; i++) {
            expect(sorted[i - 1].priority).toBeLessThanOrEqual(sorted[i].priority);
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Skill names are uppercase with underscores (convention)
  it('should have properly formatted skill names', () => {
    fc.assert(
      fc.property(
        skillArbitrary,
        (skill) => {
          // Names should be uppercase
          expect(skill.name).toBe(skill.name.toUpperCase());
          // Names should not contain spaces
          expect(skill.name).not.toContain(' ');
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Category is always one of the valid values
  it('should have valid category values', () => {
    const validCategories = ['core', 'styles', 'formats'];
    fc.assert(
      fc.property(
        skillArbitrary,
        (skill) => {
          expect(validCategories).toContain(skill.category);
        }
      ),
      { numRuns: 100 }
    );
  });
});
</file>

<file path="src/components/features/wizard/ChatInterface.tsx">
import { useRef, useEffect, useState } from 'react';
import { cn } from '@/utils/cn';
import { Button, Spinner } from '@/components/ui';

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

interface ChatInterfaceProps {
  messages: ChatMessage[];
  onSendMessage: (content: string) => void;
  isLoading?: boolean;
  disabled?: boolean;
}

export function ChatInterface({
  messages,
  onSendMessage,
  isLoading = false,
  disabled = false,
}: ChatInterfaceProps) {
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [input, setInput] = useState('');

  // Auto-scroll to bottom on new messages
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (input.trim() && !isLoading && !disabled) {
      onSendMessage(input.trim());
      setInput('');
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e);
    }
  };

  return (
    <div className="flex flex-col h-[400px] border border-neutral-200 rounded-lg overflow-hidden">
      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-neutral-50">
        {messages.map((message) => (
          <div
            key={message.id}
            className={cn(
              'flex',
              message.role === 'user' ? 'justify-end' : 'justify-start'
            )}
          >
            <div
              className={cn(
                'max-w-[80%] rounded-lg px-4 py-2',
                message.role === 'user'
                  ? 'bg-pastel-blue text-neutral-800'
                  : 'bg-white border border-neutral-200 text-neutral-700'
              )}
            >
              <p className="text-sm whitespace-pre-wrap">{message.content}</p>
              <p className="text-xs text-neutral-500 mt-1">
                {message.timestamp.toLocaleTimeString('de-DE', {
                  hour: '2-digit',
                  minute: '2-digit',
                })}
              </p>
            </div>
          </div>
        ))}
        {isLoading && (
          <div className="flex justify-start">
            <div className="bg-white border border-neutral-200 rounded-lg px-4 py-3">
              <div className="flex items-center gap-2">
                <Spinner size="sm" />
                <span className="text-sm text-neutral-500">Generiere Layout...</span>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <form onSubmit={handleSubmit} className="border-t border-neutral-200 p-3 bg-white">
        <div className="flex gap-2">
          <textarea
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Nachricht eingeben..."
            disabled={disabled || isLoading}
            rows={1}
            className={cn(
              'flex-1 px-3 py-2 border border-neutral-200 rounded-lg resize-none',
              'focus:outline-none focus:ring-2 focus:ring-pastel-blue focus:border-transparent',
              'placeholder:text-neutral-400',
              (disabled || isLoading) && 'bg-neutral-50 cursor-not-allowed'
            )}
          />
          <Button
            type="submit"
            disabled={!input.trim() || isLoading || disabled}
          >
            Senden
          </Button>
        </div>
        <p className="text-xs text-neutral-500 mt-2">
          Enter zum Senden, Shift+Enter für neue Zeile
        </p>
      </form>
    </div>
  );
}
</file>

<file path="src/components/features/wizard/ImageUpload.tsx">
import { useRef, useState, useCallback } from 'react';
import { cn } from '@/utils/cn';
import { validateImage, ALLOWED_IMAGE_TYPES, MAX_FILE_SIZE } from '@/utils';
import { Button } from '@/components/ui';

interface ImageUploadProps {
  value: { base64: string; mimeType: string } | null;
  onChange: (image: { base64: string; mimeType: string } | null) => void;
  disabled?: boolean;
}

export function ImageUpload({ value, onChange, disabled = false }: ImageUploadProps) {
  const inputRef = useRef<HTMLInputElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const processFile = useCallback(async (file: File) => {
    setError(null);
    const validation = validateImage(file);
    if (!validation.valid) {
      setError(validation.message || 'Ungültige Datei');
      return;
    }

    const reader = new FileReader();
    reader.onload = () => {
      const base64 = (reader.result as string).split(',')[1];
      onChange({ base64, mimeType: file.type });
    };
    reader.onerror = () => setError('Fehler beim Lesen der Datei');
    reader.readAsDataURL(file);
  }, [onChange]);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) processFile(file);
  };

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    if (disabled) return;
    const file = e.dataTransfer.files[0];
    if (file) processFile(file);
  }, [disabled, processFile]);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    if (!disabled) setIsDragging(true);
  };

  const handleDragLeave = () => setIsDragging(false);

  const handleRemove = () => {
    onChange(null);
    setError(null);
    if (inputRef.current) inputRef.current.value = '';
  };

  return (
    <div className="space-y-2">
      <input
        ref={inputRef}
        type="file"
        accept={ALLOWED_IMAGE_TYPES.join(',')}
        onChange={handleFileChange}
        disabled={disabled}
        className="hidden"
      />

      {value ? (
        <div className="relative rounded-lg border border-neutral-200 p-4">
          <div className="flex items-center gap-4">
            <img
              src={`data:${value.mimeType};base64,${value.base64}`}
              alt="Referenzbild"
              className="h-20 w-20 rounded-lg object-cover"
            />
            <div className="flex-1">
              <p className="text-sm font-medium text-neutral-700">Referenzbild hochgeladen</p>
              <p className="text-xs text-neutral-500">
                Das Bild wird für die Stilanalyse verwendet
              </p>
            </div>
            <Button
              variant="ghost"
              size="sm"
              onClick={handleRemove}
              disabled={disabled}
            >
              Entfernen
            </Button>
          </div>
        </div>
      ) : (
        <div
          onClick={() => !disabled && inputRef.current?.click()}
          onDrop={handleDrop}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          className={cn(
            'flex flex-col items-center justify-center rounded-lg border-2 border-dashed p-8 transition-colors cursor-pointer',
            isDragging ? 'border-pastel-blue bg-pastel-blue/10' : 'border-neutral-300',
            disabled ? 'cursor-not-allowed opacity-50' : 'hover:border-pastel-blue hover:bg-pastel-blue/5'
          )}
        >
          <svg
            className="mb-3 h-10 w-10 text-neutral-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={1.5}
              d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
            />
          </svg>
          <p className="text-sm font-medium text-neutral-700">
            Referenzbild hochladen (optional)
          </p>
          <p className="mt-1 text-xs text-neutral-500">
            JPG, PNG oder WebP bis {MAX_FILE_SIZE / 1024 / 1024}MB
          </p>
        </div>
      )}

      {error && (
        <p className="text-sm text-pastel-red-dark">{error}</p>
      )}
    </div>
  );
}
</file>

<file path="src/components/features/wizard/index.ts">
export { StepIndicator } from './StepIndicator';
export { ProductSelector } from './ProductSelector';
export { LayoutOptions } from './LayoutOptions';
export { PromptInput } from './PromptInput';
export { ImageUpload } from './ImageUpload';
export { ChatInterface } from './ChatInterface';
</file>

<file path="src/components/features/wizard/LayoutOptions.tsx">
import type { LayoutOptions as LayoutOptionsType, PageFormat, LayoutStyle } from '@/api';
import { Slider, Toggle } from '@/components/ui';
import { cn } from '@/utils/cn';
import { pageFormatDimensions, pageFormats } from '@/utils';

interface LayoutOptionsProps {
  options: LayoutOptionsType;
  onChange: (options: Partial<LayoutOptionsType>) => void;
}

const styles: Array<{ value: LayoutStyle; label: string; color: string }> = [
  { value: 'modern', label: 'Modern', color: 'bg-pastel-blue' },
  { value: 'technical', label: 'Technical', color: 'bg-neutral-200' },
  { value: 'premium', label: 'Premium', color: 'bg-pastel-purple' },
  { value: 'eco', label: 'Eco', color: 'bg-pastel-green' },
  { value: 'dynamic', label: 'Dynamic', color: 'bg-pastel-orange' },
];

export function LayoutOptions({ options, onChange }: LayoutOptionsProps) {
  return (
    <div className="space-y-8">
      {/* Page Format */}
      <div>
        <h3 className="text-sm font-medium text-neutral-800 mb-4">Seitenformat</h3>
        <div className="flex flex-wrap gap-3">
          {pageFormats.map((format) => {
            const isSelected = options.pageFormat === format;
            return (
              <button
                key={format}
                onClick={() => onChange({ pageFormat: format })}
                className={cn(
                  'flex flex-col items-center p-4 rounded-lg border-2 transition-colors min-w-[80px]',
                  isSelected
                    ? 'border-pastel-blue bg-pastel-blue-light'
                    : 'border-neutral-200 hover:border-neutral-300'
                )}
              >
                <FormatIcon format={format} isSelected={isSelected} />
                <span className="mt-2 text-sm font-medium text-neutral-800">
                  {format === 'SQUARE' ? '□' : format}
                </span>
              </button>
            );
          })}
        </div>
        {options.pageFormat && (
          <p className="mt-2 text-sm text-neutral-500">
            {pageFormatDimensions[options.pageFormat].label}
          </p>
        )}
      </div>

      {/* Style */}
      <div>
        <h3 className="text-sm font-medium text-neutral-800 mb-4">Stil</h3>
        <div className="flex flex-wrap gap-3">
          {styles.map((style) => {
            const isSelected = options.style === style.value;
            return (
              <button
                key={style.value}
                onClick={() => onChange({ style: style.value })}
                className={cn(
                  'px-4 py-2 rounded-lg border-2 transition-colors',
                  isSelected
                    ? `border-neutral-800 ${style.color}`
                    : 'border-neutral-200 hover:border-neutral-300'
                )}
              >
                <span className="text-sm font-medium text-neutral-800">
                  {style.label}
                </span>
              </button>
            );
          })}
        </div>
      </div>

      {/* Variant Count */}
      <div>
        <h3 className="text-sm font-medium text-neutral-800 mb-4">Varianten</h3>
        <div className="max-w-md">
          <Slider
            min={1}
            max={5}
            value={options.variantCount ?? 2}
            onChange={(e) => onChange({ variantCount: parseInt(e.target.value) })}
            label="Anzahl Varianten"
          />
          <p className="mt-2 text-sm text-neutral-500">
            Aktuell: {options.variantCount ?? 2} Varianten
          </p>
        </div>
      </div>

      {/* Options */}
      <div className="space-y-4">
        <h3 className="text-sm font-medium text-neutral-800">Optionen</h3>
        <div className="space-y-3">
          <Toggle
            checked={options.includeSpecs ?? true}
            onChange={(e) => onChange({ includeSpecs: e.target.checked })}
            label="Technische Daten einbeziehen"
          />
          <Toggle
            checked={options.complexStrategy ?? false}
            onChange={(e) => onChange({ complexStrategy: e.target.checked })}
            label="Komplexe Strategie (mehr LLM-Aufrufe, bessere Qualität)"
          />
        </div>
      </div>
    </div>
  );
}

function FormatIcon({ format, isSelected }: { format: PageFormat; isSelected: boolean }) {
  const dims = pageFormatDimensions[format];
  const aspectRatio = dims.width / dims.height;
  const maxHeight = 40;
  const height = maxHeight;
  const width = height * aspectRatio;

  return (
    <div
      className={cn(
        'border-2 rounded',
        isSelected ? 'border-pastel-blue-dark' : 'border-neutral-300'
      )}
      style={{ width: `${width}px`, height: `${height}px` }}
    />
  );
}
</file>

<file path="src/components/features/wizard/ProductSelector.tsx">
import { useState, useMemo } from 'react';
import { X, Plus } from 'lucide-react';
import type { Product } from '@/api';
import { Card, Button, Spinner } from '@/components/ui';
import { ProductSearch, ProductFilter } from '@/components/features/products';
import { useProducts, useCategories, useSeries } from '@/hooks';
import { filterProducts, formatPrice } from '@/utils';

interface ProductSelectorProps {
  selectedProducts: Product[];
  onAddProduct: (product: Product) => void;
  onRemoveProduct: (productId: number) => void;
}

export function ProductSelector({
  selectedProducts,
  onAddProduct,
  onRemoveProduct,
}: ProductSelectorProps) {
  const [search, setSearch] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('');
  const [selectedSeries, setSelectedSeries] = useState('');

  const { data: products, isLoading } = useProducts();
  const { data: categories } = useCategories();
  const { data: series } = useSeries();

  const availableProducts = useMemo(() => {
    if (!products) return [];
    const filtered = filterProducts(products, {
      category: selectedCategory || undefined,
      series: selectedSeries || undefined,
      search: search || undefined,
    });
    // Exclude already selected products
    return filtered.filter(
      (p) => !selectedProducts.some((sp) => sp.id === p.id)
    );
  }, [products, selectedCategory, selectedSeries, search, selectedProducts]);

  const isSelected = (productId: number) =>
    selectedProducts.some((p) => p.id === productId);

  return (
    <div className="space-y-6">
      {/* Selected Products */}
      <div>
        <h3 className="text-sm font-medium text-neutral-800 mb-3">
          Ausgewählt: {selectedProducts.length} Produkte
        </h3>
        {selectedProducts.length > 0 ? (
          <div className="flex flex-wrap gap-3">
            {selectedProducts.map((product) => (
              <div
                key={product.id}
                className="flex items-center gap-2 bg-pastel-blue-light px-3 py-2 rounded-lg"
              >
                <div>
                  <p className="text-sm font-medium text-neutral-800">
                    {product.name}
                  </p>
                  <p className="text-xs text-neutral-600">
                    {product.category} · {formatPrice(product.priceEur)}
                  </p>
                </div>
                <button
                  onClick={() => onRemoveProduct(product.id)}
                  className="p-1 hover:bg-pastel-blue rounded transition-colors"
                  aria-label={`${product.name} entfernen`}
                >
                  <X className="h-4 w-4 text-neutral-600" />
                </button>
              </div>
            ))}
          </div>
        ) : (
          <p className="text-sm text-neutral-500">
            Noch keine Produkte ausgewählt.
          </p>
        )}
      </div>

      {/* Filters */}
      <div className="flex flex-col sm:flex-row gap-4">
        <div className="flex-1">
          <ProductSearch value={search} onChange={setSearch} placeholder="Produkt suchen..." />
        </div>
        <ProductFilter
          categories={categories ?? []}
          series={series ?? []}
          selectedCategory={selectedCategory}
          selectedSeries={selectedSeries}
          onCategoryChange={setSelectedCategory}
          onSeriesChange={setSelectedSeries}
        />
      </div>

      {/* Available Products */}
      <div>
        <h3 className="text-sm font-medium text-neutral-800 mb-3">
          Verfügbare Produkte
        </h3>
        {isLoading ? (
          <div className="flex justify-center py-8">
            <Spinner />
          </div>
        ) : availableProducts.length === 0 ? (
          <p className="text-sm text-neutral-500 text-center py-8">
            Keine weiteren Produkte verfügbar.
          </p>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
            {availableProducts.map((product) => (
              <Card key={product.id} className="p-3">
                <div className="flex items-start justify-between gap-2">
                  <div className="flex-1 min-w-0">
                    <p className="font-medium text-neutral-800 text-sm truncate">
                      {product.name}
                    </p>
                    <p className="text-xs text-neutral-500 mt-0.5">
                      {product.series}
                    </p>
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => onAddProduct(product)}
                    disabled={isSelected(product.id)}
                    className="flex-shrink-0"
                  >
                    <Plus className="h-4 w-4" />
                  </Button>
                </div>
              </Card>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/features/wizard/PromptInput.tsx">
import { useRef, useEffect } from 'react';
import { cn } from '@/utils/cn';
import { getPromptCharacterCount } from '@/utils';

interface PromptInputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
}

export function PromptInput({
  value,
  onChange,
  placeholder = 'Beschreiben Sie, wie Ihr Katalog aussehen soll...',
  disabled = false,
}: PromptInputProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const { current, max, isOverLimit } = getPromptCharacterCount(value);

  // Auto-resize textarea
  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;
    }
  }, [value]);

  return (
    <div className="space-y-2">
      <textarea
        ref={textareaRef}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        disabled={disabled}
        rows={4}
        className={cn(
          'w-full px-4 py-3 border rounded-lg resize-none transition-colors',
          'focus:outline-none focus:ring-2 focus:ring-pastel-blue focus:border-transparent',
          'placeholder:text-neutral-400',
          isOverLimit ? 'border-pastel-red' : 'border-neutral-200',
          disabled && 'bg-neutral-50 cursor-not-allowed'
        )}
      />
      <div className="flex justify-end">
        <span
          className={cn(
            'text-sm',
            isOverLimit ? 'text-pastel-red-dark' : 'text-neutral-500'
          )}
        >
          {current.toLocaleString('de-DE')} / {max.toLocaleString('de-DE')} Zeichen
        </span>
      </div>
    </div>
  );
}
</file>

<file path="src/components/features/wizard/StepIndicator.tsx">
import { Check } from 'lucide-react';
import { cn } from '@/utils/cn';

interface Step {
  number: number;
  label: string;
}

interface StepIndicatorProps {
  steps: Step[];
  currentStep: number;
}

export function StepIndicator({ steps, currentStep }: StepIndicatorProps) {
  return (
    <div className="flex items-center justify-center mb-8">
      {steps.map((step, index) => {
        const isCompleted = step.number < currentStep;
        const isCurrent = step.number === currentStep;
        const isLast = index === steps.length - 1;

        return (
          <div key={step.number} className="flex items-center">
            {/* Step Circle */}
            <div className="flex flex-col items-center">
              <div
                className={cn(
                  'w-10 h-10 rounded-full flex items-center justify-center text-sm font-medium transition-colors',
                  isCompleted && 'bg-pastel-green text-neutral-800',
                  isCurrent && 'bg-pastel-blue text-neutral-800',
                  !isCompleted && !isCurrent && 'bg-neutral-200 text-neutral-500'
                )}
              >
                {isCompleted ? <Check className="h-5 w-5" /> : step.number}
              </div>
              <span
                className={cn(
                  'mt-2 text-xs font-medium',
                  isCurrent ? 'text-neutral-800' : 'text-neutral-500'
                )}
              >
                {step.label}
              </span>
            </div>

            {/* Connector Line */}
            {!isLast && (
              <div
                className={cn(
                  'w-16 sm:w-24 h-0.5 mx-2',
                  isCompleted ? 'bg-pastel-green' : 'bg-neutral-200'
                )}
              />
            )}
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="src/components/features/wizard/wizard.test.ts">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { 
  getPromptCharacterCount, 
  validatePromptLength, 
  MAX_PROMPT_LENGTH,
  validateImage,
  validateFileSize,
  validateImageType,
  MAX_FILE_SIZE,
  ALLOWED_IMAGE_TYPES
} from '@/utils';

describe('Character Counter Validation', () => {
  it('should correctly count characters for any string', () => {
    fc.assert(
      fc.property(fc.string(), (text) => {
        const result = getPromptCharacterCount(text);
        expect(result.current).toBe(text.length);
        expect(result.max).toBe(MAX_PROMPT_LENGTH);
        expect(result.remaining).toBe(MAX_PROMPT_LENGTH - text.length);
      })
    );
  });

  it('should correctly identify over-limit prompts', () => {
    fc.assert(
      fc.property(fc.string(), (text) => {
        const result = getPromptCharacterCount(text);
        expect(result.isOverLimit).toBe(text.length > MAX_PROMPT_LENGTH);
      })
    );
  });

  it('should validate prompt length correctly', () => {
    fc.assert(
      fc.property(
        fc.string({ minLength: 1, maxLength: MAX_PROMPT_LENGTH }),
        (text) => {
          const result = validatePromptLength(text);
          expect(result.valid).toBe(true);
        }
      )
    );
  });

  it('should reject empty prompts', () => {
    const result = validatePromptLength('');
    expect(result.valid).toBe(false);
    expect(result.message).toBeDefined();
  });

  it('should reject prompts exceeding max length', () => {
    fc.assert(
      fc.property(
        fc.string({ minLength: MAX_PROMPT_LENGTH + 1, maxLength: MAX_PROMPT_LENGTH + 100 }),
        (text) => {
          const result = validatePromptLength(text);
          expect(result.valid).toBe(false);
          expect(result.message).toBeDefined();
        }
      )
    );
  });

  it('should have consistent remaining calculation', () => {
    fc.assert(
      fc.property(fc.string(), (text) => {
        const result = getPromptCharacterCount(text);
        expect(result.current + result.remaining).toBe(result.max);
      })
    );
  });
});

describe('Image Validation', () => {
  const createMockFile = (size: number, type: string): File => {
    const blob = new Blob(['x'.repeat(size)], { type });
    return new File([blob], 'test.jpg', { type });
  };

  it('should accept valid image types', () => {
    ALLOWED_IMAGE_TYPES.forEach((type) => {
      const file = createMockFile(1000, type);
      const result = validateImageType(file);
      expect(result.valid).toBe(true);
    });
  });

  it('should reject invalid image types', () => {
    const invalidTypes = ['image/gif', 'image/bmp', 'application/pdf', 'text/plain'];
    invalidTypes.forEach((type) => {
      const file = createMockFile(1000, type);
      const result = validateImageType(file);
      expect(result.valid).toBe(false);
    });
  });

  it('should accept files under size limit', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 1, max: MAX_FILE_SIZE }),
        (size) => {
          const file = createMockFile(size, 'image/jpeg');
          const result = validateFileSize(file);
          expect(result.valid).toBe(true);
        }
      )
    );
  });

  it('should reject files over size limit', () => {
    const file = createMockFile(MAX_FILE_SIZE + 1, 'image/jpeg');
    const result = validateFileSize(file);
    expect(result.valid).toBe(false);
  });

  it('should validate complete image correctly', () => {
    const validFile = createMockFile(1000, 'image/jpeg');
    expect(validateImage(validFile).valid).toBe(true);

    const invalidType = createMockFile(1000, 'image/gif');
    expect(validateImage(invalidType).valid).toBe(false);

    const tooLarge = createMockFile(MAX_FILE_SIZE + 1, 'image/jpeg');
    expect(validateImage(tooLarge).valid).toBe(false);
  });
});
</file>

<file path="src/components/layout/AppLayout.tsx">
import { useState } from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import { Sidebar } from './Sidebar';
import { Header } from './Header';

const pageTitles: Record<string, string> = {
  '/': 'Dashboard',
  '/skills': 'Skill Explorer',
  '/prompts': 'Prompt Explorer',
  '/wizard': 'Katalog erstellen',
};

export function AppLayout() {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const location = useLocation();

  const title = location.pathname.startsWith('/preview')
    ? 'Katalog-Vorschau'
    : pageTitles[location.pathname] || 'CatalogForge';

  return (
    <div className="flex min-h-screen bg-neutral-50">
      <Sidebar isOpen={sidebarOpen} onClose={() => setSidebarOpen(false)} />

      <div className="flex-1 flex flex-col min-w-0">
        <Header title={title} onMenuClick={() => setSidebarOpen(true)} />
        <main className="flex-1">
          <Outlet />
        </main>
      </div>
    </div>
  );
}
</file>

<file path="src/components/layout/Header.tsx">
import { Menu } from 'lucide-react';

interface HeaderProps {
  title: string;
  onMenuClick: () => void;
}

export function Header({ title, onMenuClick }: HeaderProps) {
  return (
    <header className="sticky top-0 z-30 bg-white border-b border-neutral-200">
      <div className="flex items-center gap-4 px-6 py-4">
        <button
          onClick={onMenuClick}
          className="p-2 rounded-lg hover:bg-neutral-100 md:hidden"
          aria-label="Menü öffnen"
        >
          <Menu className="h-5 w-5 text-neutral-600" />
        </button>
        <h1 className="text-xl font-semibold text-neutral-800">{title}</h1>
      </div>
    </header>
  );
}
</file>

<file path="src/components/layout/index.ts">
export { AppLayout } from './AppLayout';
export { Sidebar } from './Sidebar';
export { Header } from './Header';
export { PageContainer } from './PageContainer';
</file>

<file path="src/components/layout/PageContainer.tsx">
import type { ReactNode } from 'react';
import { cn } from '@/utils/cn';

interface PageContainerProps {
  children: ReactNode;
  className?: string;
}

export function PageContainer({ children, className }: PageContainerProps) {
  return (
    <div className={cn('px-6 py-6 max-w-7xl mx-auto', className)}>
      {children}
    </div>
  );
}
</file>

<file path="src/components/layout/Sidebar.test.tsx">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';

/**
 * Property 2: Responsive Sidebar Behavior
 * Validates: Requirements 3.5, 3.6, 3.7
 */
describe('Sidebar Responsive Behavior', () => {
  const breakpoints = {
    mobile: 640,
    tablet: 768,
    desktop: 1024,
    largeDesktop: 1280,
  };

  // Property: Sidebar visibility follows breakpoint rules
  it('should determine sidebar visibility based on viewport width', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 320, max: 1920 }),
        fc.boolean(),
        (viewportWidth, isOpen) => {
          const isMobile = viewportWidth < breakpoints.tablet;
          
          // On mobile: sidebar visibility depends on isOpen state
          // On desktop: sidebar is always visible
          const shouldBeVisible = isMobile ? isOpen : true;
          
          expect(typeof shouldBeVisible).toBe('boolean');
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Mobile overlay only appears when sidebar is open on mobile
  it('should show overlay only on mobile when sidebar is open', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 320, max: 1920 }),
        fc.boolean(),
        (viewportWidth, isOpen) => {
          const isMobile = viewportWidth < breakpoints.tablet;
          const shouldShowOverlay = isMobile && isOpen;
          
          expect(typeof shouldShowOverlay).toBe('boolean');
          if (!isMobile) {
            expect(shouldShowOverlay).toBe(false);
          }
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Sidebar width is consistent
  it('should have consistent sidebar width', () => {
    const sidebarWidth = 256; // 64 * 4 = 256px (w-64 in Tailwind)
    
    fc.assert(
      fc.property(
        fc.integer({ min: 320, max: 1920 }),
        (viewportWidth) => {
          // Sidebar width should be constant regardless of viewport
          expect(sidebarWidth).toBe(256);
          // Content area should be viewport minus sidebar on desktop
          if (viewportWidth >= breakpoints.tablet) {
            const contentWidth = viewportWidth - sidebarWidth;
            expect(contentWidth).toBeGreaterThan(0);
          }
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Navigation items are always present
  it('should always have navigation items defined', () => {
    const navigationItems = [
      { path: '/', label: 'Dashboard' },
      { path: '/skills', label: 'Skill Explorer' },
      { path: '/prompts', label: 'Prompt Explorer' },
      { path: '/wizard', label: 'Katalog erstellen' },
    ];

    expect(navigationItems.length).toBe(4);
    navigationItems.forEach((item) => {
      expect(item.path).toBeDefined();
      expect(item.label).toBeDefined();
      expect(item.path.startsWith('/')).toBe(true);
    });
  });
});
</file>

<file path="src/components/layout/Sidebar.tsx">
import { NavLink } from 'react-router-dom';
import { LayoutDashboard, Sparkles, MessageSquare, Wand2 } from 'lucide-react';
import { cn } from '@/utils/cn';

const navigationItems = [
  { path: '/', label: 'Dashboard', icon: LayoutDashboard },
  { path: '/skills', label: 'Skill Explorer', icon: Sparkles },
  { path: '/prompts', label: 'Prompt Explorer', icon: MessageSquare },
];

interface SidebarProps {
  isOpen: boolean;
  onClose: () => void;
}

export function Sidebar({ isOpen, onClose }: SidebarProps) {
  return (
    <>
      {/* Mobile overlay */}
      {isOpen && (
        <div
          className="fixed inset-0 bg-black/50 z-40 md:hidden"
          onClick={onClose}
          aria-hidden="true"
        />
      )}

      {/* Sidebar */}
      <aside
        role="navigation"
        aria-label="Hauptnavigation"
        className={cn(
          'fixed top-0 left-0 z-50 h-full w-64 bg-sidebar border-r border-neutral-200',
          'transform transition-transform duration-200 ease-in-out',
          'md:translate-x-0 md:static md:z-0',
          isOpen ? 'translate-x-0' : '-translate-x-full'
        )}
      >
        <div className="flex flex-col h-full">
          {/* Logo */}
          <div className="px-6 py-5 border-b border-neutral-200">
            <h1 className="text-xl font-semibold text-neutral-800">
              🏭 CatalogForge
            </h1>
          </div>

          {/* Navigation */}
          <nav className="flex-1 px-4 py-4" aria-label="Seitennavigation">
            <ul className="space-y-1" role="list">
              {navigationItems.map((item) => (
                <li key={item.path}>
                  <NavLink
                    to={item.path}
                    onClick={onClose}
                    className={({ isActive }) =>
                      cn(
                        'flex items-center gap-3 px-3 py-2 rounded-lg text-sm font-medium transition-colors',
                        isActive
                          ? 'bg-pastel-blue text-neutral-800'
                          : 'text-neutral-600 hover:bg-neutral-100 hover:text-neutral-800'
                      )
                    }
                  >
                    <item.icon className="h-5 w-5" />
                    {item.label}
                  </NavLink>
                </li>
              ))}
            </ul>

            {/* Primary CTA */}
            <div className="mt-6 pt-6 border-t border-neutral-200">
              <NavLink
                to="/wizard"
                onClick={onClose}
                className={({ isActive }) =>
                  cn(
                    'flex items-center gap-3 px-3 py-3 rounded-lg text-sm font-medium transition-colors',
                    isActive
                      ? 'bg-pastel-blue-dark text-neutral-800'
                      : 'bg-pastel-blue hover:bg-pastel-blue-dark text-neutral-800'
                  )
                }
              >
                <Wand2 className="h-5 w-5" />
                Katalog erstellen
              </NavLink>
            </div>
          </nav>

          {/* Footer */}
          <div className="px-6 py-4 border-t border-neutral-200">
            <div className="flex items-center gap-2 text-xs text-neutral-500">
              <span className="h-2 w-2 rounded-full bg-pastel-green" />
              Backend: Online
            </div>
            <p className="text-xs text-neutral-400 mt-1">v1.0.0</p>
          </div>
        </div>
      </aside>
    </>
  );
}
</file>

<file path="src/components/ui/Badge.test.tsx">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import type { LayoutStyle } from '@/api/types';
import { styleToBadgeVariant, type BadgeVariant } from './Badge';

/**
 * Property 10: Style to Badge Color Mapping
 * Validates: Requirements 2.5
 */
describe('Badge Style Mapping', () => {
  const validStyles: LayoutStyle[] = ['modern', 'technical', 'premium', 'eco', 'dynamic'];
  const validBadgeVariants: BadgeVariant[] = ['default', 'blue', 'green', 'purple', 'yellow', 'orange', 'red'];

  // Property: Every LayoutStyle maps to a valid BadgeVariant
  it('should map every layout style to a valid badge variant', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...validStyles),
        (style) => {
          const badgeVariant = styleToBadgeVariant[style];
          expect(validBadgeVariants).toContain(badgeVariant);
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Style mapping is deterministic (same input always produces same output)
  it('should produce deterministic mappings', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...validStyles),
        (style) => {
          const result1 = styleToBadgeVariant[style];
          const result2 = styleToBadgeVariant[style];
          expect(result1).toBe(result2);
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: All styles have a mapping defined
  it('should have mappings for all layout styles', () => {
    validStyles.forEach((style) => {
      expect(styleToBadgeVariant[style]).toBeDefined();
    });
  });

  // Property: Expected specific mappings
  it('should map styles to expected badge variants', () => {
    expect(styleToBadgeVariant['modern']).toBe('blue');
    expect(styleToBadgeVariant['technical']).toBe('default');
    expect(styleToBadgeVariant['premium']).toBe('purple');
    expect(styleToBadgeVariant['eco']).toBe('green');
    expect(styleToBadgeVariant['dynamic']).toBe('orange');
  });
});
</file>

<file path="src/components/ui/Badge.tsx">
import { forwardRef, type HTMLAttributes } from 'react';
import { cn } from '@/utils/cn';
import type { LayoutStyle } from '@/api/types';

export type BadgeVariant = 'default' | 'blue' | 'green' | 'purple' | 'yellow' | 'orange' | 'red';

interface BadgeProps extends HTMLAttributes<HTMLSpanElement> {
  variant?: BadgeVariant;
}

const variantStyles: Record<BadgeVariant, string> = {
  default: 'bg-neutral-100 text-neutral-600',
  blue: 'bg-pastel-blue-light text-neutral-800',
  green: 'bg-pastel-green-light text-neutral-800',
  purple: 'bg-pastel-purple-light text-neutral-800',
  yellow: 'bg-pastel-yellow-light text-neutral-800',
  orange: 'bg-pastel-orange-light text-neutral-800',
  red: 'bg-pastel-red-light text-neutral-800',
};

export const styleToBadgeVariant: Record<LayoutStyle, BadgeVariant> = {
  modern: 'blue',
  technical: 'default',
  premium: 'purple',
  eco: 'green',
  dynamic: 'orange',
};

export const Badge = forwardRef<HTMLSpanElement, BadgeProps>(
  ({ className, variant = 'default', children, ...props }, ref) => {
    return (
      <span
        ref={ref}
        className={cn(
          'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium',
          variantStyles[variant],
          className
        )}
        {...props}
      >
        {children}
      </span>
    );
  }
);

Badge.displayName = 'Badge';
</file>

<file path="src/components/ui/Button.test.tsx">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import type { ButtonVariant, ButtonSize } from './Button';

/**
 * Property 1: UI Component Variant Mapping
 * Validates: Requirements 2.3, 2.5, 2.9
 */
describe('Button Variant Mapping', () => {
  const validVariants: ButtonVariant[] = ['primary', 'secondary', 'ghost', 'danger'];
  const validSizes: ButtonSize[] = ['sm', 'md', 'lg'];

  // Property: All valid variants map to distinct style classes
  it('should have distinct styles for each variant', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...validVariants),
        fc.constantFrom(...validVariants),
        (variant1, variant2) => {
          if (variant1 !== variant2) {
            // Different variants should produce different visual results
            expect(variant1).not.toBe(variant2);
          }
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: All valid sizes are recognized
  it('should recognize all valid sizes', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...validSizes),
        (size) => {
          expect(validSizes).toContain(size);
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Variant and size combinations are independent
  it('should allow any combination of variant and size', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...validVariants),
        fc.constantFrom(...validSizes),
        (variant, size) => {
          // All combinations should be valid
          expect(validVariants).toContain(variant);
          expect(validSizes).toContain(size);
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });
});
</file>

<file path="src/components/ui/Button.tsx">
import { forwardRef, type ButtonHTMLAttributes } from 'react';
import { cn } from '@/utils/cn';

export type ButtonVariant = 'primary' | 'secondary' | 'ghost' | 'danger';
export type ButtonSize = 'sm' | 'md' | 'lg';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
  isLoading?: boolean;
}

const variantStyles: Record<ButtonVariant, string> = {
  primary: 'bg-pastel-blue hover:bg-pastel-blue-dark text-neutral-800',
  secondary: 'bg-white border border-neutral-200 hover:bg-neutral-50 text-neutral-800',
  ghost: 'bg-transparent hover:bg-neutral-100 text-neutral-800',
  danger: 'bg-pastel-red hover:bg-pastel-red-dark text-neutral-800',
};

const sizeStyles: Record<ButtonSize, string> = {
  sm: 'px-3 py-1.5 text-sm',
  md: 'px-4 py-2 text-base',
  lg: 'px-6 py-3 text-lg',
};

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'primary', size = 'md', isLoading, disabled, children, ...props }, ref) => {
    return (
      <button
        ref={ref}
        className={cn(
          'inline-flex items-center justify-center font-medium rounded-lg transition-colors',
          'focus:outline-none focus:ring-2 focus:ring-pastel-blue focus:ring-offset-2',
          'disabled:opacity-50 disabled:cursor-not-allowed',
          variantStyles[variant],
          sizeStyles[size],
          className
        )}
        disabled={disabled || isLoading}
        aria-disabled={disabled || isLoading}
        aria-busy={isLoading}
        {...props}
      >
        {isLoading ? (
          <span className="mr-2 h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent" aria-hidden="true" />
        ) : null}
        {children}
      </button>
    );
  }
);

Button.displayName = 'Button';
</file>

<file path="src/components/ui/Card.tsx">
import { forwardRef, type HTMLAttributes } from 'react';
import { cn } from '@/utils/cn';

interface CardProps extends HTMLAttributes<HTMLDivElement> {
  hoverable?: boolean;
}

export const Card = forwardRef<HTMLDivElement, CardProps>(
  ({ className, hoverable = false, children, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          'bg-white rounded-lg shadow-card',
          hoverable && 'hover:shadow-card-hover transition-shadow cursor-pointer',
          className
        )}
        {...props}
      >
        {children}
      </div>
    );
  }
);

Card.displayName = 'Card';

export const CardHeader = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('px-6 py-4 border-b border-neutral-100', className)} {...props} />
  )
);

CardHeader.displayName = 'CardHeader';

export const CardContent = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('px-6 py-4', className)} {...props} />
  )
);

CardContent.displayName = 'CardContent';

export const CardFooter = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('px-6 py-4 border-t border-neutral-100', className)} {...props} />
  )
);

CardFooter.displayName = 'CardFooter';
</file>

<file path="src/components/ui/index.ts">
export { Button, type ButtonVariant, type ButtonSize } from './Button';
export { Card, CardHeader, CardContent, CardFooter } from './Card';
export { Badge, styleToBadgeVariant, type BadgeVariant } from './Badge';
export { Input } from './Input';
export { Select } from './Select';
export { Modal } from './Modal';
export { Tabs, TabsList, TabsTrigger, TabsContent } from './Tabs';
export { Slider } from './Slider';
export { Toggle } from './Toggle';
export { Spinner } from './Spinner';
export { ToastProvider, useToast } from './Toast';
</file>

<file path="src/components/ui/Input.tsx">
import { forwardRef, type InputHTMLAttributes } from 'react';
import { cn } from '@/utils/cn';

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  error?: string;
  label?: string;
}

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ className, error, label, id, ...props }, ref) => {
    const inputId = id || (label ? label.toLowerCase().replace(/\s+/g, '-') : undefined);
    const errorId = error ? `${inputId}-error` : undefined;

    return (
      <div className="w-full">
        {label && (
          <label htmlFor={inputId} className="block text-sm font-medium text-neutral-700 mb-1">
            {label}
          </label>
        )}
        <input
          ref={ref}
          id={inputId}
          className={cn(
            'w-full px-3 py-2 border rounded-lg transition-colors',
            'focus:outline-none focus:ring-2 focus:ring-pastel-blue focus:border-transparent',
            'placeholder:text-neutral-400',
            error ? 'border-pastel-red' : 'border-neutral-200',
            className
          )}
          aria-invalid={!!error}
          aria-describedby={errorId}
          {...props}
        />
        {error && (
          <p id={errorId} className="mt-1 text-sm text-pastel-red-dark" role="alert">
            {error}
          </p>
        )}
      </div>
    );
  }
);

Input.displayName = 'Input';
</file>

<file path="src/components/ui/Modal.tsx">
import { useEffect, useRef, type ReactNode } from 'react';
import { X } from 'lucide-react';
import { cn } from '@/utils/cn';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: ReactNode;
  className?: string;
}

export function Modal({ isOpen, onClose, title, children, className }: ModalProps) {
  const modalRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center"
      onClick={(e) => e.target === e.currentTarget && onClose()}
    >
      <div className="fixed inset-0 bg-black/50" aria-hidden="true" />
      <div
        ref={modalRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby={title ? 'modal-title' : undefined}
        className={cn(
          'relative z-50 w-full max-w-lg max-h-[90vh] overflow-auto',
          'bg-white rounded-lg shadow-xl',
          className
        )}
      >
        {title && (
          <div className="flex items-center justify-between px-6 py-4 border-b border-neutral-100">
            <h2 id="modal-title" className="text-lg font-semibold text-neutral-800">
              {title}
            </h2>
            <button
              onClick={onClose}
              className="p-1 rounded-lg hover:bg-neutral-100 transition-colors"
              aria-label="Schließen"
            >
              <X className="h-5 w-5 text-neutral-600" />
            </button>
          </div>
        )}
        <div className="p-6">{children}</div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ui/Select.tsx">
import { forwardRef, type SelectHTMLAttributes } from 'react';
import { cn } from '@/utils/cn';
import { ChevronDown } from 'lucide-react';

interface SelectProps extends SelectHTMLAttributes<HTMLSelectElement> {
  error?: string;
}

export const Select = forwardRef<HTMLSelectElement, SelectProps>(
  ({ className, error, children, ...props }, ref) => {
    return (
      <div className="relative w-full">
        <select
          ref={ref}
          className={cn(
            'w-full px-3 py-2 pr-10 border rounded-lg appearance-none transition-colors',
            'focus:outline-none focus:ring-2 focus:ring-pastel-blue focus:border-transparent',
            'bg-white cursor-pointer',
            error ? 'border-pastel-red' : 'border-neutral-200',
            className
          )}
          {...props}
        >
          {children}
        </select>
        <ChevronDown className="absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 text-neutral-400 pointer-events-none" />
        {error && <p className="mt-1 text-sm text-pastel-red-dark">{error}</p>}
      </div>
    );
  }
);

Select.displayName = 'Select';
</file>

<file path="src/components/ui/Slider.tsx">
import { forwardRef, type InputHTMLAttributes } from 'react';
import { cn } from '@/utils/cn';

interface SliderProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'type'> {
  label?: string;
  showValue?: boolean;
}

export const Slider = forwardRef<HTMLInputElement, SliderProps>(
  ({ className, label, showValue = true, value, min = 1, max = 5, ...props }, ref) => {
    return (
      <div className="w-full">
        {(label || showValue) && (
          <div className="flex justify-between mb-2">
            {label && <span className="text-sm text-neutral-600">{label}</span>}
            {showValue && (
              <span className="text-sm font-medium text-neutral-800">{value}</span>
            )}
          </div>
        )}
        <input
          ref={ref}
          type="range"
          min={min}
          max={max}
          value={value}
          className={cn(
            'w-full h-2 bg-neutral-200 rounded-lg appearance-none cursor-pointer',
            'accent-pastel-blue',
            className
          )}
          {...props}
        />
        <div className="flex justify-between mt-1">
          <span className="text-xs text-neutral-400">{min}</span>
          <span className="text-xs text-neutral-400">{max}</span>
        </div>
      </div>
    );
  }
);

Slider.displayName = 'Slider';
</file>

<file path="src/components/ui/Spinner.tsx">
import { cn } from '@/utils/cn';

interface SpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

const sizeStyles = {
  sm: 'h-4 w-4 border-2',
  md: 'h-8 w-8 border-2',
  lg: 'h-12 w-12 border-3',
};

export function Spinner({ size = 'md', className }: SpinnerProps) {
  return (
    <div
      role="status"
      aria-label="Laden..."
      className={cn(
        'animate-spin rounded-full border-pastel-blue border-t-transparent',
        sizeStyles[size],
        className
      )}
    />
  );
}
</file>

<file path="src/components/ui/Tabs.tsx">
import { createContext, useContext, useState, type ReactNode } from 'react';
import { cn } from '@/utils/cn';

interface TabsContextValue {
  activeTab: string;
  setActiveTab: (tab: string) => void;
}

const TabsContext = createContext<TabsContextValue | null>(null);

interface TabsProps {
  defaultValue: string;
  children: ReactNode;
  className?: string;
}

export function Tabs({ defaultValue, children, className }: TabsProps) {
  const [activeTab, setActiveTab] = useState(defaultValue);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className={className}>{children}</div>
    </TabsContext.Provider>
  );
}

interface TabsListProps {
  children: ReactNode;
  className?: string;
}

export function TabsList({ children, className }: TabsListProps) {
  return (
    <div
      role="tablist"
      className={cn('flex border-b border-neutral-200', className)}
    >
      {children}
    </div>
  );
}

interface TabsTriggerProps {
  value: string;
  children: ReactNode;
  className?: string;
}

export function TabsTrigger({ value, children, className }: TabsTriggerProps) {
  const context = useContext(TabsContext);
  if (!context) throw new Error('TabsTrigger must be used within Tabs');

  const isActive = context.activeTab === value;

  return (
    <button
      role="tab"
      aria-selected={isActive}
      onClick={() => context.setActiveTab(value)}
      className={cn(
        'px-4 py-2 text-sm font-medium transition-colors',
        'border-b-2 -mb-px',
        isActive
          ? 'border-pastel-blue text-neutral-800'
          : 'border-transparent text-neutral-600 hover:text-neutral-800',
        className
      )}
    >
      {children}
    </button>
  );
}

interface TabsContentProps {
  value: string;
  children: ReactNode;
  className?: string;
}

export function TabsContent({ value, children, className }: TabsContentProps) {
  const context = useContext(TabsContext);
  if (!context) throw new Error('TabsContent must be used within Tabs');

  if (context.activeTab !== value) return null;

  return (
    <div role="tabpanel" className={cn('py-4', className)}>
      {children}
    </div>
  );
}
</file>

<file path="src/components/ui/Toast.tsx">
import { createContext, useContext, useState, useCallback, type ReactNode } from 'react';
import { X, CheckCircle, AlertCircle, Info, AlertTriangle } from 'lucide-react';
import { cn } from '@/utils/cn';

export type ToastType = 'success' | 'error' | 'info' | 'warning';

interface ToastData {
  id: string;
  type: ToastType;
  message: string;
}

interface ToastContextValue {
  toasts: ToastData[];
  addToast: (type: ToastType, message: string) => void;
  removeToast: (id: string) => void;
}

const ToastContext = createContext<ToastContextValue | null>(null);

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) throw new Error('useToast must be used within ToastProvider');
  return context;
}

interface ToastProviderProps {
  children: ReactNode;
}

export function ToastProvider({ children }: ToastProviderProps) {
  const [toasts, setToasts] = useState<ToastData[]>([]);

  const addToast = useCallback((type: ToastType, message: string) => {
    const id = crypto.randomUUID();
    setToasts((prev) => [...prev, { id, type, message }]);
    setTimeout(() => {
      setToasts((prev) => prev.filter((t) => t.id !== id));
    }, 5000);
  }, []);

  const removeToast = useCallback((id: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ toasts, addToast, removeToast }}>
      {children}
      <ToastContainer toasts={toasts} removeToast={removeToast} />
    </ToastContext.Provider>
  );
}

const icons: Record<ToastType, typeof CheckCircle> = {
  success: CheckCircle,
  error: AlertCircle,
  info: Info,
  warning: AlertTriangle,
};

const styles: Record<ToastType, string> = {
  success: 'bg-pastel-green border-pastel-green-dark',
  error: 'bg-pastel-red border-pastel-red-dark',
  info: 'bg-pastel-blue border-pastel-blue-dark',
  warning: 'bg-pastel-yellow border-pastel-yellow-dark',
};

interface ToastContainerProps {
  toasts: ToastData[];
  removeToast: (id: string) => void;
}

function ToastContainer({ toasts, removeToast }: ToastContainerProps) {
  if (toasts.length === 0) return null;

  return (
    <div
      aria-live="polite"
      className="fixed bottom-4 right-4 z-50 flex flex-col gap-2"
    >
      {toasts.map((toast) => {
        const Icon = icons[toast.type];
        return (
          <div
            key={toast.id}
            className={cn(
              'flex items-center gap-3 px-4 py-3 rounded-lg border shadow-lg',
              'animate-in slide-in-from-right',
              styles[toast.type]
            )}
          >
            <Icon className="h-5 w-5 text-neutral-800" />
            <p className="text-sm text-neutral-800">{toast.message}</p>
            <button
              onClick={() => removeToast(toast.id)}
              className="ml-2 p-1 rounded hover:bg-black/10"
              aria-label="Schließen"
            >
              <X className="h-4 w-4" />
            </button>
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="src/components/ui/Toggle.tsx">
import { forwardRef, type InputHTMLAttributes } from 'react';
import { cn } from '@/utils/cn';

interface ToggleProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'type'> {
  label?: string;
}

export const Toggle = forwardRef<HTMLInputElement, ToggleProps>(
  ({ className, label, checked, ...props }, ref) => {
    return (
      <label className={cn('inline-flex items-center cursor-pointer', className)}>
        <div className="relative">
          <input
            ref={ref}
            type="checkbox"
            checked={checked}
            className="sr-only peer"
            {...props}
          />
          <div
            className={cn(
              'w-11 h-6 rounded-full transition-colors',
              'peer-focus:ring-2 peer-focus:ring-pastel-blue peer-focus:ring-offset-2',
              checked ? 'bg-pastel-blue' : 'bg-neutral-200'
            )}
          />
          <div
            className={cn(
              'absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform',
              checked && 'translate-x-5'
            )}
          />
        </div>
        {label && <span className="ml-3 text-sm text-neutral-800">{label}</span>}
      </label>
    );
  }
);

Toggle.displayName = 'Toggle';
</file>

<file path="src/components/ErrorBoundary.tsx">
import { Component, type ReactNode } from 'react';
import { Button, Card } from '@/components/ui';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen flex items-center justify-center p-6 bg-neutral-50">
          <Card className="max-w-md w-full p-6 text-center">
            <div className="mb-4">
              <svg
                className="mx-auto h-12 w-12 text-pastel-red"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                />
              </svg>
            </div>
            <h2 className="text-xl font-semibold text-neutral-800 mb-2">
              Etwas ist schiefgelaufen
            </h2>
            <p className="text-neutral-600 mb-4">
              Ein unerwarteter Fehler ist aufgetreten. Bitte versuchen Sie es erneut.
            </p>
            {this.state.error && (
              <p className="text-sm text-neutral-500 mb-4 font-mono bg-neutral-100 p-2 rounded">
                {this.state.error.message}
              </p>
            )}
            <div className="flex gap-3 justify-center">
              <Button variant="secondary" onClick={() => window.location.reload()}>
                Seite neu laden
              </Button>
              <Button onClick={this.handleReset}>
                Erneut versuchen
              </Button>
            </div>
          </Card>
        </div>
      );
    }

    return this.props.children;
  }
}
</file>

<file path="src/context/index.ts">
// Re-export Toast context from UI components
export { ToastProvider, useToast } from '@/components/ui/Toast';
</file>

<file path="src/hooks/index.ts">
export { useProducts, useProduct, useCategories, useSeries, useProductSearch } from './useProducts';
export { useSkills, useSkillCategories, useSkillsByCategory, useExamplePrompts } from './useSkills';
export { useLayout, useLayoutVariants, useGenerateFromText, useGenerateFromImage, useUpdateLayout, useDeleteLayout } from './useLayouts';
export { usePrintPresets, useGeneratePdf, useDownloadPdf } from './usePdf';
export { useImageUpload, useImageUploadBase64, fileToBase64 } from './useImageUpload';
export { useDebounce } from './useDebounce';
</file>

<file path="src/hooks/useDebounce.ts">
import { useState, useEffect } from 'react';

/**
 * Debounces a value by the specified delay.
 * Useful for search inputs to avoid excessive API calls.
 */
export function useDebounce<T>(value: T, delay: number = 300): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}
</file>

<file path="src/hooks/useImageUpload.ts">
import { useMutation } from '@tanstack/react-query';
import { imagesApi } from '@/api';

export function useImageUpload() {
  return useMutation({
    mutationFn: (file: File) => imagesApi.upload(file),
  });
}

export function useImageUploadBase64() {
  return useMutation({
    mutationFn: ({ base64Data, mimeType, filename }: { 
      base64Data: string; 
      mimeType: string; 
      filename?: string;
    }) => imagesApi.uploadBase64(base64Data, mimeType, filename),
  });
}

export function fileToBase64(file: File): Promise<{ base64: string; mimeType: string }> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const result = reader.result as string;
      const base64 = result.split(',')[1];
      resolve({ base64, mimeType: file.type });
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}
</file>

<file path="src/hooks/useLayouts.ts">
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { layoutsApi } from '@/api';
import type { LayoutResponse, TextToLayoutRequest, ImageToLayoutRequest } from '@/api';

export function useLayout(id: string) {
  return useQuery({
    queryKey: ['layouts', id],
    queryFn: () => layoutsApi.getById(id),
    enabled: !!id,
  });
}

export function useLayoutVariants(id: string) {
  return useQuery({
    queryKey: ['layouts', id, 'variants'],
    queryFn: () => layoutsApi.getVariants(id),
    enabled: !!id,
  });
}

export function useGenerateFromText() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (request: TextToLayoutRequest) => layoutsApi.generateFromText(request),
    onSuccess: (data) => {
      queryClient.setQueryData(['layouts', data.id], data);
    },
  });
}

export function useGenerateFromImage() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (request: ImageToLayoutRequest) => layoutsApi.generateFromImage(request),
    onSuccess: (data) => {
      queryClient.setQueryData(['layouts', data.id], data);
    },
  });
}

export function useUpdateLayout() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, layout }: { id: string; layout: Partial<LayoutResponse> }) =>
      layoutsApi.update(id, layout),
    onSuccess: (data, { id }) => {
      queryClient.setQueryData(['layouts', id], data);
    },
  });
}

export function useDeleteLayout() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: layoutsApi.delete,
    onSuccess: (_, id) => {
      queryClient.removeQueries({ queryKey: ['layouts', id] });
    },
  });
}
</file>

<file path="src/hooks/usePdf.ts">
import { useQuery, useMutation } from '@tanstack/react-query';
import { pdfApi } from '@/api';
import type { PdfGenerateRequest } from '@/api';

export function usePrintPresets() {
  return useQuery({
    queryKey: ['pdf', 'presets'],
    queryFn: pdfApi.getPresets,
  });
}

export function useGeneratePdf() {
  return useMutation({
    mutationFn: (request: PdfGenerateRequest) => pdfApi.generate(request),
  });
}

export function useDownloadPdf() {
  return useMutation({
    mutationFn: async (id: string) => {
      const blob = await pdfApi.download(id);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `katalog-${id}.pdf`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    },
  });
}
</file>

<file path="src/hooks/useProducts.ts">
import { useQuery } from '@tanstack/react-query';
import { productsApi } from '@/api';

export function useProducts(category?: string, series?: string) {
  return useQuery({
    queryKey: ['products', { category, series }],
    queryFn: () => productsApi.getAll(category, series),
  });
}

export function useProduct(id: number) {
  return useQuery({
    queryKey: ['products', id],
    queryFn: () => productsApi.getById(id),
    enabled: !!id,
  });
}

export function useCategories() {
  return useQuery({
    queryKey: ['products', 'categories'],
    queryFn: productsApi.getCategories,
  });
}

export function useSeries() {
  return useQuery({
    queryKey: ['products', 'series'],
    queryFn: productsApi.getSeries,
  });
}

export function useProductSearch(query: string) {
  return useQuery({
    queryKey: ['products', 'search', query],
    queryFn: () => productsApi.search(query),
    enabled: query.length >= 2,
  });
}
</file>

<file path="src/hooks/useSkills.ts">
import { useQuery } from '@tanstack/react-query';
import { skillsApi } from '@/api';

export function useSkills() {
  return useQuery({
    queryKey: ['skills'],
    queryFn: skillsApi.getAll,
  });
}

export function useSkillCategories() {
  return useQuery({
    queryKey: ['skills', 'categories'],
    queryFn: skillsApi.getCategories,
  });
}

export function useSkillsByCategory(category: string) {
  return useQuery({
    queryKey: ['skills', category],
    queryFn: () => skillsApi.getByCategory(category),
    enabled: !!category,
  });
}

export function useExamplePrompts() {
  return useQuery({
    queryKey: ['skills', 'prompts', 'examples'],
    queryFn: skillsApi.getExamplePrompts,
  });
}
</file>

<file path="src/pages/CatalogPreview/CatalogPreviewPage.tsx">
import { useState } from 'react';
import { useParams, useSearchParams, useNavigate } from 'react-router-dom';
import { PageContainer } from '@/components/layout';
import { Button, Card, Modal, Spinner } from '@/components/ui';
import { 
  LayoutPreview, 
  VariantSelector, 
  CodeEditor, 
  PdfExport 
} from '@/components/features/preview';
import { useLayout, useDeleteLayout } from '@/hooks/useLayouts';

type ViewMode = 'preview' | 'code';

export function CatalogPreviewPage() {
  const { id } = useParams<{ id: string }>();
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  
  const initialVariantId = searchParams.get('variant');
  const [selectedVariantId, setSelectedVariantId] = useState<string | null>(initialVariantId);
  const [viewMode, setViewMode] = useState<ViewMode>('preview');
  const [showDeleteModal, setShowDeleteModal] = useState(false);

  const { data: layout, isLoading, error } = useLayout(id || '');
  const deleteLayout = useDeleteLayout();

  const selectedVariant = layout?.variants.find((v) => v.id === selectedVariantId) || 
    layout?.variants[0] || null;

  const handleDelete = async () => {
    if (!id) return;
    try {
      await deleteLayout.mutateAsync(id);
      navigate('/');
    } catch (err) {
      console.error('Delete failed:', err);
    }
  };

  const handleBackToWizard = () => {
    navigate('/wizard');
  };

  if (isLoading) {
    return (
      <PageContainer>
        <div className="flex items-center justify-center h-96">
          <Spinner size="lg" />
        </div>
      </PageContainer>
    );
  }

  if (error || !layout) {
    return (
      <PageContainer>
        <div className="text-center py-12">
          <h2 className="text-xl font-semibold text-neutral-800 mb-2">
            Layout nicht gefunden
          </h2>
          <p className="text-neutral-600 mb-4">
            Das angeforderte Layout existiert nicht oder wurde gelöscht.
          </p>
          <Button onClick={handleBackToWizard}>
            Neuen Katalog erstellen
          </Button>
        </div>
      </PageContainer>
    );
  }

  return (
    <PageContainer>
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold text-neutral-800">Katalog-Vorschau</h1>
          <p className="text-neutral-600 mt-1">
            Layout ID: {layout.id} · Format: {layout.pageFormat} · {layout.variantCount} Variante(n)
          </p>
        </div>
        <div className="flex gap-3">
          <Button variant="ghost" onClick={handleBackToWizard}>
            Neuer Katalog
          </Button>
          <Button variant="danger" onClick={() => setShowDeleteModal(true)}>
            Löschen
          </Button>
        </div>
      </div>

      {/* View Mode Toggle */}
      <div className="flex gap-2 mb-6">
        <Button
          variant={viewMode === 'preview' ? 'primary' : 'secondary'}
          onClick={() => setViewMode('preview')}
        >
          Vorschau
        </Button>
        <Button
          variant={viewMode === 'code' ? 'primary' : 'secondary'}
          onClick={() => setViewMode('code')}
        >
          Code
        </Button>
      </div>

      {/* Main Content */}
      <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
        {/* Preview/Code Area */}
        <div className="lg:col-span-3">
          <Card className="p-4 h-[600px]">
            {viewMode === 'preview' ? (
              <LayoutPreview
                variant={selectedVariant}
                pageFormat={layout.pageFormat}
                className="h-full"
              />
            ) : (
              <CodeEditor
                html={selectedVariant?.html || ''}
                css={selectedVariant?.css || ''}
                readOnly
              />
            )}
          </Card>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Variant Selector */}
          <Card className="p-4">
            <VariantSelector
              variants={layout.variants}
              selectedId={selectedVariantId || selectedVariant?.id || null}
              onSelect={setSelectedVariantId}
            />
          </Card>

          {/* PDF Export */}
          <Card className="p-4">
            <PdfExport
              layoutId={layout.id}
              variantId={selectedVariantId || selectedVariant?.id}
            />
          </Card>

          {/* Layout Info */}
          <Card className="p-4">
            <h3 className="text-sm font-medium text-neutral-800 mb-3">Details</h3>
            <dl className="space-y-2 text-sm">
              <div className="flex justify-between">
                <dt className="text-neutral-500">Erstellt</dt>
                <dd className="text-neutral-800">
                  {new Date(layout.generatedAt).toLocaleString('de-DE')}
                </dd>
              </div>
              <div className="flex justify-between">
                <dt className="text-neutral-500">Status</dt>
                <dd className="text-neutral-800">{layout.status}</dd>
              </div>
              <div className="flex justify-between">
                <dt className="text-neutral-500">Format</dt>
                <dd className="text-neutral-800">{layout.pageFormat}</dd>
              </div>
            </dl>
          </Card>
        </div>
      </div>

      {/* Delete Confirmation Modal */}
      <Modal
        isOpen={showDeleteModal}
        onClose={() => setShowDeleteModal(false)}
        title="Layout löschen"
      >
        <div className="space-y-4">
          <p className="text-neutral-600">
            Möchten Sie dieses Layout wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.
          </p>
          <div className="flex justify-end gap-3">
            <Button variant="secondary" onClick={() => setShowDeleteModal(false)}>
              Abbrechen
            </Button>
            <Button
              variant="danger"
              onClick={handleDelete}
              isLoading={deleteLayout.isPending}
            >
              Löschen
            </Button>
          </div>
        </div>
      </Modal>
    </PageContainer>
  );
}
</file>

<file path="src/pages/CatalogWizard/CatalogWizardPage.tsx">
import { useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { PageContainer } from '@/components/layout';
import { Button, Card } from '@/components/ui';
import { 
  StepIndicator, 
  ProductSelector, 
  LayoutOptions, 
  PromptInput, 
  ImageUpload, 
  ChatInterface 
} from '@/components/features/wizard';
import { LayoutPreview, VariantSelector } from '@/components/features/preview';
import { useWizardStore } from '@/store/wizardStore';
import { useGenerateFromText, useGenerateFromImage } from '@/hooks/useLayouts';
import { validatePromptLength } from '@/utils';

const STEPS = [
  { number: 1, label: 'Produkte' },
  { number: 2, label: 'Optionen' },
  { number: 3, label: 'Prompt' },
  { number: 4, label: 'Ergebnis' },
];

export function CatalogWizardPage() {
  const navigate = useNavigate();
  const {
    currentStep,
    nextStep,
    prevStep,
    selectedProducts,
    addProduct,
    removeProduct,
    options,
    setOptions,
    prompt,
    setPrompt,
    referenceImage,
    setReferenceImage,
    chatHistory,
    addChatMessage,
    generatedLayout,
    setGeneratedLayout,
    selectedVariantId,
    setSelectedVariantId,
    isGenerating,
    setIsGenerating,
    setError,
    reset,
  } = useWizardStore();

  const textToLayout = useGenerateFromText();
  const imageToLayout = useGenerateFromImage();

  const canProceed = useCallback(() => {
    switch (currentStep) {
      case 1:
        return selectedProducts.length > 0;
      case 2:
        return true;
      case 3:
        return validatePromptLength(prompt).valid || referenceImage !== null;
      case 4:
        return generatedLayout !== null && selectedVariantId !== null;
      default:
        return false;
    }
  }, [currentStep, selectedProducts, prompt, referenceImage, generatedLayout, selectedVariantId]);

  const handleGenerate = async () => {
    if (!canProceed()) return;

    setIsGenerating(true);
    setError(null);

    // Add user message to chat
    addChatMessage({ role: 'user', content: prompt });

    try {
      const productIds = selectedProducts.map((p) => p.id);
      let result;

      if (referenceImage) {
        result = await imageToLayout.mutateAsync({
          productIds,
          options,
          prompt: prompt || undefined,
          imageBase64: referenceImage.base64,
          imageMimeType: referenceImage.mimeType,
        });
      } else {
        result = await textToLayout.mutateAsync({
          productIds,
          options,
          prompt,
        });
      }

      setGeneratedLayout(result);
      if (result.variants.length > 0) {
        setSelectedVariantId(result.variants[0].id);
      }

      // Add assistant response
      addChatMessage({
        role: 'assistant',
        content: `Ich habe ${result.variantCount} Layout-Variante(n) für Sie generiert. Wählen Sie Ihre bevorzugte Variante aus.`,
      });

      nextStep();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Fehler bei der Generierung';
      setError(message);
      addChatMessage({
        role: 'assistant',
        content: `Es ist ein Fehler aufgetreten: ${message}. Bitte versuchen Sie es erneut.`,
      });
    } finally {
      setIsGenerating(false);
    }
  };

  const handleFinish = () => {
    if (generatedLayout && selectedVariantId) {
      navigate(`/preview/${generatedLayout.id}?variant=${selectedVariantId}`);
    }
  };

  const handleReset = () => {
    reset();
  };

  const selectedVariant = generatedLayout?.variants.find((v) => v.id === selectedVariantId) || null;

  return (
    <PageContainer>
      {/* Header */}
      <div className="mb-6">
        <h1 className="text-2xl font-bold text-neutral-800">Katalog erstellen</h1>
        <p className="text-neutral-600 mt-1">
          Erstellen Sie in 4 Schritten Ihren individuellen Produktkatalog
        </p>
      </div>

      {/* Step Indicator */}
      <div className="mb-8">
        <StepIndicator steps={STEPS} currentStep={currentStep} />
      </div>

      {/* Step Content */}
      <Card className="p-6">
        {currentStep === 1 && (
          <div className="space-y-6">
            <div>
              <h2 className="text-lg font-semibold text-neutral-800 mb-2">
                Produkte auswählen
              </h2>
              <p className="text-neutral-600">
                Wählen Sie die Produkte aus, die in Ihrem Katalog erscheinen sollen.
              </p>
            </div>
            <ProductSelector
              selectedProducts={selectedProducts}
              onAddProduct={addProduct}
              onRemoveProduct={removeProduct}
            />
          </div>
        )}

        {currentStep === 2 && (
          <div className="space-y-6">
            <div>
              <h2 className="text-lg font-semibold text-neutral-800 mb-2">
                Layout-Optionen
              </h2>
              <p className="text-neutral-600">
                Konfigurieren Sie Format, Stil und weitere Optionen für Ihren Katalog.
              </p>
            </div>
            <LayoutOptions options={options} onChange={setOptions} />
          </div>
        )}

        {currentStep === 3 && (
          <div className="space-y-6">
            <div>
              <h2 className="text-lg font-semibold text-neutral-800 mb-2">
                Beschreibung & Referenzbild
              </h2>
              <p className="text-neutral-600">
                Beschreiben Sie, wie Ihr Katalog aussehen soll, oder laden Sie ein Referenzbild hoch.
              </p>
            </div>
            
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <div className="space-y-4">
                <PromptInput
                  value={prompt}
                  onChange={setPrompt}
                  disabled={isGenerating}
                />
                <ImageUpload
                  value={referenceImage}
                  onChange={setReferenceImage}
                  disabled={isGenerating}
                />
              </div>
              <div>
                <ChatInterface
                  messages={chatHistory}
                  onSendMessage={(content) => {
                    setPrompt(content);
                    handleGenerate();
                  }}
                  isLoading={isGenerating}
                  disabled={isGenerating}
                />
              </div>
            </div>
          </div>
        )}

        {currentStep === 4 && (
          <div className="space-y-6">
            <div>
              <h2 className="text-lg font-semibold text-neutral-800 mb-2">
                Ergebnis
              </h2>
              <p className="text-neutral-600">
                Wählen Sie Ihre bevorzugte Layout-Variante aus.
              </p>
            </div>
            
            <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
              <div className="lg:col-span-3">
                <LayoutPreview
                  variant={selectedVariant}
                  pageFormat={generatedLayout?.pageFormat}
                  className="h-[600px]"
                />
              </div>
              <div>
                <VariantSelector
                  variants={generatedLayout?.variants || []}
                  selectedId={selectedVariantId}
                  onSelect={setSelectedVariantId}
                />
              </div>
            </div>
          </div>
        )}
      </Card>

      {/* Navigation */}
      <div className="flex justify-between mt-6">
        <div>
          {currentStep > 1 && (
            <Button variant="secondary" onClick={prevStep} disabled={isGenerating}>
              Zurück
            </Button>
          )}
        </div>
        <div className="flex gap-3">
          <Button variant="ghost" onClick={handleReset} disabled={isGenerating}>
            Neu starten
          </Button>
          {currentStep < 3 && (
            <Button onClick={nextStep} disabled={!canProceed()}>
              Weiter
            </Button>
          )}
          {currentStep === 3 && (
            <Button onClick={handleGenerate} disabled={!canProceed() || isGenerating} isLoading={isGenerating}>
              Generieren
            </Button>
          )}
          {currentStep === 4 && (
            <Button onClick={handleFinish} disabled={!canProceed()}>
              Zur Vorschau
            </Button>
          )}
        </div>
      </div>
    </PageContainer>
  );
}
</file>

<file path="src/pages/Dashboard/DashboardPage.tsx">
import { useState, useMemo } from 'react';
import { Package, FolderTree, Layers, Zap } from 'lucide-react';
import { PageContainer } from '@/components/layout';
import { StatCard, PieChart, BarChart } from '@/components/charts';
import { ProductGrid, ProductSearch, ProductFilter } from '@/components/features/products';
import { Card, CardHeader, CardContent, Spinner, Modal } from '@/components/ui';
import { useProducts, useCategories, useSeries, useDebounce } from '@/hooks';
import {
  filterProducts,
  countByCategory,
  countBySeries,
  countElectric,
} from '@/utils';
import type { Product } from '@/api';

export function DashboardPage() {
  const [search, setSearch] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('');
  const [selectedSeries, setSelectedSeries] = useState('');
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);

  // Debounce search input for better performance
  const debouncedSearch = useDebounce(search, 300);

  const { data: products, isLoading: productsLoading } = useProducts();
  const { data: categories } = useCategories();
  const { data: series } = useSeries();

  const filteredProducts = useMemo(() => {
    if (!products) return [];
    return filterProducts(products, {
      category: selectedCategory || undefined,
      series: selectedSeries || undefined,
      search: debouncedSearch || undefined,
    });
  }, [products, selectedCategory, selectedSeries, debouncedSearch]);

  const categoryData = useMemo(() => {
    if (!products) return [];
    return countByCategory(products);
  }, [products]);

  const seriesData = useMemo(() => {
    if (!products) return [];
    return countBySeries(products);
  }, [products]);

  const electricCount = useMemo(() => {
    if (!products) return 0;
    return countElectric(products);
  }, [products]);

  const handleCategoryClick = (name: string) => {
    setSelectedCategory(name === selectedCategory ? '' : name);
  };

  const handleSeriesClick = (name: string) => {
    setSelectedSeries(name === selectedSeries ? '' : name);
  };

  if (productsLoading) {
    return (
      <PageContainer className="flex items-center justify-center min-h-[50vh]">
        <Spinner size="lg" />
      </PageContainer>
    );
  }

  return (
    <PageContainer>
      {/* Stats */}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
        <StatCard
          title="Produkte gesamt"
          value={products?.length ?? 0}
          icon={Package}
        />
        <StatCard
          title="Kategorien"
          value={categories?.length ?? 0}
          icon={FolderTree}
        />
        <StatCard
          title="Baureihen"
          value={series?.length ?? 0}
          icon={Layers}
        />
        <StatCard
          title="Elektrofahrzeuge"
          value={electricCount}
          icon={Zap}
        />
      </div>

      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-8">
        <PieChart
          title="Verteilung nach Kategorie"
          data={categoryData}
          onSegmentClick={handleCategoryClick}
        />
        <BarChart
          title="Produkte pro Baureihe"
          data={seriesData}
          onBarClick={handleSeriesClick}
        />
      </div>

      {/* Product List */}
      <Card>
        <CardHeader>
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <h2 className="text-lg font-semibold text-neutral-800">Produkte</h2>
            <div className="flex flex-col sm:flex-row gap-4">
              <ProductSearch value={search} onChange={setSearch} />
              <ProductFilter
                categories={categories ?? []}
                series={series ?? []}
                selectedCategory={selectedCategory}
                selectedSeries={selectedSeries}
                onCategoryChange={setSelectedCategory}
                onSeriesChange={setSelectedSeries}
              />
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <ProductGrid
            products={filteredProducts}
            onProductClick={setSelectedProduct}
          />
        </CardContent>
      </Card>

      {/* Product Detail Modal */}
      <Modal
        isOpen={!!selectedProduct}
        onClose={() => setSelectedProduct(null)}
        title={selectedProduct?.name}
        className="max-w-2xl"
      >
        {selectedProduct && (
          <div className="space-y-4">
            {selectedProduct.imageUrl && (
              <img
                src={selectedProduct.imageUrl}
                alt={selectedProduct.name}
                className="w-full h-48 object-cover rounded-lg"
              />
            )}
            <p className="text-neutral-600">{selectedProduct.description}</p>
            
            {selectedProduct.highlights.length > 0 && (
              <div>
                <h4 className="font-medium text-neutral-800 mb-2">Highlights</h4>
                <ul className="list-disc list-inside text-sm text-neutral-600">
                  {selectedProduct.highlights.map((h, i) => (
                    <li key={i}>{h}</li>
                  ))}
                </ul>
              </div>
            )}

            {Object.keys(selectedProduct.specs).length > 0 && (
              <div>
                <h4 className="font-medium text-neutral-800 mb-2">Technische Daten</h4>
                <dl className="grid grid-cols-2 gap-2 text-sm">
                  {Object.entries(selectedProduct.specs).map(([key, value]) => (
                    <div key={key}>
                      <dt className="text-neutral-500">{key}</dt>
                      <dd className="text-neutral-800">{value}</dd>
                    </div>
                  ))}
                </dl>
              </div>
            )}
          </div>
        )}
      </Modal>
    </PageContainer>
  );
}
</file>

<file path="src/pages/PromptExplorer/PromptExplorerPage.tsx">
import { useState, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { PageContainer } from '@/components/layout';
import { PromptCard, PromptDetail } from '@/components/features/prompts';
import { Select, Modal, Spinner } from '@/components/ui';
import { useExamplePrompts } from '@/hooks';
import { useWizardStore } from '@/store/wizardStore';
import { filterPrompts } from '@/utils';
import type { ExamplePrompt, LayoutStyle, PageFormat } from '@/api';

const styles: Array<{ value: LayoutStyle | 'all'; label: string }> = [
  { value: 'all', label: 'Alle Stile' },
  { value: 'modern', label: 'Modern' },
  { value: 'technical', label: 'Technical' },
  { value: 'premium', label: 'Premium' },
  { value: 'eco', label: 'Eco' },
  { value: 'dynamic', label: 'Dynamic' },
];

const formats: Array<{ value: PageFormat | 'all'; label: string }> = [
  { value: 'all', label: 'Alle Formate' },
  { value: 'A4', label: 'A4' },
  { value: 'A5', label: 'A5' },
  { value: 'A6', label: 'A6' },
  { value: 'DL', label: 'DL' },
  { value: 'SQUARE', label: 'Quadrat' },
];

export function PromptExplorerPage() {
  const navigate = useNavigate();
  const [selectedStyle, setSelectedStyle] = useState<LayoutStyle | 'all'>('all');
  const [selectedFormat, setSelectedFormat] = useState<PageFormat | 'all'>('all');
  const [selectedPrompt, setSelectedPrompt] = useState<ExamplePrompt | null>(null);

  const { data: prompts, isLoading } = useExamplePrompts();
  const { setPrompt, setOptions } = useWizardStore();

  const filteredPrompts = useMemo(() => {
    if (!prompts) return [];
    return filterPrompts(prompts, selectedStyle, selectedFormat);
  }, [prompts, selectedStyle, selectedFormat]);

  const handleUsePrompt = (prompt: ExamplePrompt) => {
    setPrompt(prompt.prompt);
    setOptions({
      style: prompt.style as LayoutStyle,
      pageFormat: prompt.format as PageFormat,
    });
    navigate('/wizard');
  };

  if (isLoading) {
    return (
      <PageContainer className="flex items-center justify-center min-h-[50vh]">
        <Spinner size="lg" />
      </PageContainer>
    );
  }

  return (
    <PageContainer>
      {/* Filters */}
      <div className="flex flex-wrap gap-4 mb-6">
        <Select
          value={selectedStyle}
          onChange={(e) => setSelectedStyle(e.target.value as LayoutStyle | 'all')}
          className="w-40"
        >
          {styles.map((style) => (
            <option key={style.value} value={style.value}>
              {style.label}
            </option>
          ))}
        </Select>

        <Select
          value={selectedFormat}
          onChange={(e) => setSelectedFormat(e.target.value as PageFormat | 'all')}
          className="w-40"
        >
          {formats.map((format) => (
            <option key={format.value} value={format.value}>
              {format.label}
            </option>
          ))}
        </Select>
      </div>

      {/* Prompt Grid */}
      {filteredPrompts.length === 0 ? (
        <div className="text-center py-12 text-neutral-500">
          Keine Prompts gefunden.
        </div>
      ) : (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredPrompts.map((prompt) => (
            <PromptCard
              key={prompt.id}
              prompt={prompt}
              onClick={() => setSelectedPrompt(prompt)}
              onUse={() => handleUsePrompt(prompt)}
            />
          ))}
        </div>
      )}

      {/* Prompt Detail Modal */}
      <Modal
        isOpen={!!selectedPrompt}
        onClose={() => setSelectedPrompt(null)}
        title={selectedPrompt?.title}
        className="max-w-xl"
      >
        {selectedPrompt && (
          <PromptDetail
            prompt={selectedPrompt}
            onUse={() => {
              handleUsePrompt(selectedPrompt);
              setSelectedPrompt(null);
            }}
          />
        )}
      </Modal>
    </PageContainer>
  );
}
</file>

<file path="src/pages/SkillExplorer/SkillExplorerPage.tsx">
import { useState, useMemo } from 'react';
import { PageContainer } from '@/components/layout';
import { SkillCard, SkillDetail, CategoryFilter } from '@/components/features/skills';
import { Card, Modal, Spinner } from '@/components/ui';
import { useSkills, useSkillCategories } from '@/hooks';
import { filterSkills, sortSkills } from '@/utils';
import type { Skill } from '@/api';

export function SkillExplorerPage() {
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [selectedSkill, setSelectedSkill] = useState<Skill | null>(null);

  const { data: skills, isLoading: skillsLoading } = useSkills();
  const { data: categories } = useSkillCategories();

  const filteredSkills = useMemo(() => {
    if (!skills) return [];
    const filtered = filterSkills(skills, selectedCategory === 'all' ? undefined : selectedCategory);
    return sortSkills(filtered);
  }, [skills, selectedCategory]);

  const handleDependencyClick = (name: string) => {
    const skill = skills?.find((s) => s.name === name);
    if (skill) {
      setSelectedSkill(skill);
    }
  };

  if (skillsLoading) {
    return (
      <PageContainer className="flex items-center justify-center min-h-[50vh]">
        <Spinner size="lg" />
      </PageContainer>
    );
  }

  return (
    <PageContainer>
      <div className="flex flex-col md:flex-row gap-6">
        {/* Sidebar Filter */}
        <aside className="w-full md:w-48 flex-shrink-0">
          <Card className="p-4">
            <h3 className="font-medium text-neutral-800 mb-3">Filter</h3>
            <CategoryFilter
              categories={categories ?? []}
              selected={selectedCategory}
              onChange={setSelectedCategory}
            />
          </Card>
        </aside>

        {/* Skill Grid */}
        <main className="flex-1">
          {filteredSkills.length === 0 ? (
            <div className="text-center py-12 text-neutral-500">
              Keine Skills gefunden.
            </div>
          ) : (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
              {filteredSkills.map((skill) => (
                <SkillCard
                  key={skill.name}
                  skill={skill}
                  onClick={() => setSelectedSkill(skill)}
                />
              ))}
            </div>
          )}
        </main>
      </div>

      {/* Skill Detail Modal */}
      <Modal
        isOpen={!!selectedSkill}
        onClose={() => setSelectedSkill(null)}
        title={selectedSkill?.name.replace(/_/g, ' ')}
        className="max-w-2xl"
      >
        {selectedSkill && (
          <SkillDetail
            skill={selectedSkill}
            onDependencyClick={handleDependencyClick}
          />
        )}
      </Modal>
    </PageContainer>
  );
}
</file>

<file path="src/store/wizardStore.test.ts">
import { describe, it, expect, beforeEach } from 'vitest';
import * as fc from 'fast-check';
import { useWizardStore } from './wizardStore';
import type { Product, PageFormat, LayoutStyle } from '@/api';

/**
 * Property 8: Wizard Store State Management
 * Validates: Requirements 9.1, 9.2, 9.3, 9.4, 9.6, 9.10, 9.11, 9.12
 */
describe('Wizard Store State Management', () => {
  beforeEach(() => {
    useWizardStore.getState().reset();
  });

  const productArbitrary = fc.record({
    id: fc.integer({ min: 1, max: 1000 }),
    name: fc.string({ minLength: 1, maxLength: 50 }),
    shortDescription: fc.string(),
    description: fc.string(),
    longDescription: fc.string(),
    category: fc.constantFrom('Fernverkehr', 'Verteiler', 'Bau', 'Elektro'),
    series: fc.constantFrom('Actros', 'Arocs', 'eActros', 'Atego'),
    specs: fc.dictionary(fc.string(), fc.string()),
    highlights: fc.array(fc.string()),
    imageUrl: fc.string(),
    priceEur: fc.option(fc.integer({ min: 10000, max: 500000 }), { nil: null }),
  }) as fc.Arbitrary<Product>;

  // Property: Adding a product increases selectedProducts length by 1 (if not duplicate)
  it('should add unique products to selection', () => {
    fc.assert(
      fc.property(
        productArbitrary,
        (product) => {
          useWizardStore.getState().reset();
          const initialLength = useWizardStore.getState().selectedProducts.length;
          useWizardStore.getState().addProduct(product);
          const newLength = useWizardStore.getState().selectedProducts.length;
          expect(newLength).toBe(initialLength + 1);
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Adding duplicate product does not increase length
  it('should not add duplicate products', () => {
    fc.assert(
      fc.property(
        productArbitrary,
        (product) => {
          const store = useWizardStore.getState();
          store.reset();
          store.addProduct(product);
          const lengthAfterFirst = useWizardStore.getState().selectedProducts.length;
          store.addProduct(product);
          expect(useWizardStore.getState().selectedProducts.length).toBe(lengthAfterFirst);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Removing a product decreases length by 1 (if exists)
  it('should remove products from selection', () => {
    fc.assert(
      fc.property(
        productArbitrary,
        (product) => {
          const store = useWizardStore.getState();
          store.reset();
          store.addProduct(product);
          const lengthBefore = useWizardStore.getState().selectedProducts.length;
          store.removeProduct(product.id);
          expect(useWizardStore.getState().selectedProducts.length).toBe(lengthBefore - 1);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Step navigation stays within bounds [1, 4]
  it('should keep step within valid bounds', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 0, max: 10 }),
        (times) => {
          const store = useWizardStore.getState();
          store.reset();
          for (let i = 0; i < times; i++) {
            store.nextStep();
          }
          const step = useWizardStore.getState().currentStep;
          expect(step).toBeGreaterThanOrEqual(1);
          expect(step).toBeLessThanOrEqual(4);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: prevStep never goes below 1
  it('should not go below step 1', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 0, max: 10 }),
        (times) => {
          const store = useWizardStore.getState();
          store.reset();
          for (let i = 0; i < times; i++) {
            store.prevStep();
          }
          expect(useWizardStore.getState().currentStep).toBe(1);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: setOptions merges with existing options
  it('should merge options correctly', () => {
    fc.assert(
      fc.property(
        fc.constantFrom('A4', 'A5', 'A6', 'DL', 'SQUARE') as fc.Arbitrary<PageFormat>,
        fc.constantFrom('modern', 'technical', 'premium', 'eco', 'dynamic') as fc.Arbitrary<LayoutStyle>,
        fc.integer({ min: 1, max: 5 }),
        (format, style, variantCount) => {
          const store = useWizardStore.getState();
          store.reset();
          store.setOptions({ pageFormat: format });
          store.setOptions({ style });
          store.setOptions({ variantCount });
          
          const options = useWizardStore.getState().options;
          expect(options.pageFormat).toBe(format);
          expect(options.style).toBe(style);
          expect(options.variantCount).toBe(variantCount);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: setPrompt updates prompt correctly
  it('should update prompt correctly', () => {
    fc.assert(
      fc.property(
        fc.string({ minLength: 0, maxLength: 5000 }),
        (prompt) => {
          const store = useWizardStore.getState();
          store.reset();
          store.setPrompt(prompt);
          expect(useWizardStore.getState().prompt).toBe(prompt);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: reset returns to initial state
  it('should reset to initial state', () => {
    fc.assert(
      fc.property(
        productArbitrary,
        fc.string({ minLength: 1, maxLength: 100 }),
        (product, prompt) => {
          const store = useWizardStore.getState();
          store.addProduct(product);
          store.setPrompt(prompt);
          store.nextStep();
          store.reset();
          
          const state = useWizardStore.getState();
          expect(state.currentStep).toBe(1);
          expect(state.selectedProducts.length).toBe(0);
          expect(state.prompt).toBe('');
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Chat messages are added with unique IDs
  it('should add chat messages with unique IDs', () => {
    fc.assert(
      fc.property(
        fc.array(fc.string({ minLength: 1, maxLength: 100 }), { minLength: 2, maxLength: 10 }),
        (messages) => {
          const store = useWizardStore.getState();
          store.reset();
          
          messages.forEach((content) => {
            store.addChatMessage({ role: 'user', content });
          });
          
          const chatHistory = useWizardStore.getState().chatHistory;
          const ids = chatHistory.map((m) => m.id);
          const uniqueIds = new Set(ids);
          expect(uniqueIds.size).toBe(ids.length);
        }
      ),
      { numRuns: 100 }
    );
  });
});
</file>

<file path="src/store/wizardStore.ts">
import { create } from 'zustand';
import type { Product, LayoutOptions, LayoutResponse, PageFormat, LayoutStyle } from '@/api';

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

interface WizardState {
  // Navigation
  currentStep: 1 | 2 | 3 | 4;
  setStep: (step: 1 | 2 | 3 | 4) => void;
  nextStep: () => void;
  prevStep: () => void;

  // Step 1: Products
  selectedProducts: Product[];
  addProduct: (product: Product) => void;
  removeProduct: (productId: number) => void;
  clearProducts: () => void;

  // Step 2: Options
  options: LayoutOptions;
  setOptions: (options: Partial<LayoutOptions>) => void;

  // Step 3: Prompt
  prompt: string;
  setPrompt: (prompt: string) => void;
  referenceImage: { base64: string; mimeType: string } | null;
  setReferenceImage: (image: { base64: string; mimeType: string } | null) => void;

  // Chat
  chatHistory: ChatMessage[];
  addChatMessage: (message: Omit<ChatMessage, 'id' | 'timestamp'>) => void;
  clearChat: () => void;

  // Step 4: Result
  generatedLayout: LayoutResponse | null;
  setGeneratedLayout: (layout: LayoutResponse | null) => void;
  selectedVariantId: string | null;
  setSelectedVariantId: (id: string | null) => void;

  // Status
  isGenerating: boolean;
  setIsGenerating: (value: boolean) => void;
  error: string | null;
  setError: (error: string | null) => void;

  // Reset
  reset: () => void;
}

const initialOptions: LayoutOptions = {
  pageFormat: 'A4' as PageFormat,
  style: 'modern' as LayoutStyle,
  variantCount: 2,
  includeSpecs: true,
  complexStrategy: false,
};

const createWelcomeMessage = (): ChatMessage => ({
  id: 'welcome',
  role: 'assistant',
  content: 'Willkommen! Beschreiben Sie, wie Ihr Katalog aussehen soll. Ich generiere dann passende Layout-Varianten für Sie.',
  timestamp: new Date(),
});

export const useWizardStore = create<WizardState>((set) => ({
  // Navigation
  currentStep: 1,
  setStep: (step) => set({ currentStep: step }),
  nextStep: () =>
    set((state) => ({
      currentStep: Math.min(state.currentStep + 1, 4) as 1 | 2 | 3 | 4,
    })),
  prevStep: () =>
    set((state) => ({
      currentStep: Math.max(state.currentStep - 1, 1) as 1 | 2 | 3 | 4,
    })),

  // Products
  selectedProducts: [],
  addProduct: (product) =>
    set((state) => ({
      selectedProducts: state.selectedProducts.some((p) => p.id === product.id)
        ? state.selectedProducts
        : [...state.selectedProducts, product],
    })),
  removeProduct: (productId) =>
    set((state) => ({
      selectedProducts: state.selectedProducts.filter((p) => p.id !== productId),
    })),
  clearProducts: () => set({ selectedProducts: [] }),

  // Options
  options: initialOptions,
  setOptions: (options) =>
    set((state) => ({
      options: { ...state.options, ...options },
    })),

  // Prompt
  prompt: '',
  setPrompt: (prompt) => set({ prompt }),
  referenceImage: null,
  setReferenceImage: (image) => set({ referenceImage: image }),

  // Chat
  chatHistory: [createWelcomeMessage()],
  addChatMessage: (message) =>
    set((state) => ({
      chatHistory: [
        ...state.chatHistory,
        {
          ...message,
          id: crypto.randomUUID(),
          timestamp: new Date(),
        },
      ],
    })),
  clearChat: () => set({ chatHistory: [createWelcomeMessage()] }),

  // Result
  generatedLayout: null,
  setGeneratedLayout: (layout) => set({ generatedLayout: layout }),
  selectedVariantId: null,
  setSelectedVariantId: (id) => set({ selectedVariantId: id }),

  // Status
  isGenerating: false,
  setIsGenerating: (value) => set({ isGenerating: value }),
  error: null,
  setError: (error) => set({ error }),

  // Reset
  reset: () =>
    set({
      currentStep: 1,
      selectedProducts: [],
      options: initialOptions,
      prompt: '',
      referenceImage: null,
      chatHistory: [createWelcomeMessage()],
      generatedLayout: null,
      selectedVariantId: null,
      isGenerating: false,
      error: null,
    }),
}));
</file>

<file path="src/styles/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  /* Primary Colors */
  --pastel-blue: #A8D5E5;
  --pastel-blue-dark: #7BC0D4;
  --pastel-green: #B5E5CF;
  --pastel-purple: #D4B5E5;
  --pastel-yellow: #F5E6A3;
  --pastel-red: #E5B5B5;
  --pastel-orange: #E5CDB5;

  /* Neutrals */
  --neutral-50: #FAFAFA;
  --neutral-100: #F5F5F5;
  --neutral-200: #E5E5E5;
  --neutral-300: #D4D4D4;
  --neutral-600: #525252;
  --neutral-800: #262626;
  --neutral-900: #171717;

  /* Backgrounds */
  --bg-primary: #FAFAFA;
  --bg-card: #FFFFFF;
  --bg-sidebar: #F0F7FA;
}

body {
  font-family: 'Inter', system-ui, sans-serif;
  background-color: var(--bg-primary);
  color: var(--neutral-800);
}

/* Focus styles for accessibility */
*:focus-visible {
  outline: 2px solid var(--pastel-blue);
  outline-offset: 2px;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--neutral-100);
}

::-webkit-scrollbar-thumb {
  background: var(--neutral-300);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--neutral-600);
}
</file>

<file path="src/test/setup.ts">
import '@testing-library/jest-dom';
</file>

<file path="src/utils/aggregations.test.ts">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import type { Product } from '@/api';
import {
  countByCategory,
  countBySeries,
  calculatePriceRange,
  getTotalCount,
  getUniqueCategories,
  getUniqueSeries,
} from './aggregations';

/**
 * Property 4: Dashboard Data Aggregation
 * Validates: Requirements 6.2, 6.3, 6.4, 6.5
 */
describe('Dashboard Data Aggregation', () => {
  const productArbitrary = fc.record({
    id: fc.integer({ min: 1, max: 1000 }),
    name: fc.string({ minLength: 1, maxLength: 50 }),
    shortDescription: fc.string(),
    description: fc.string(),
    longDescription: fc.string(),
    category: fc.constantFrom('Fernverkehr', 'Verteiler', 'Bau', 'Elektro'),
    series: fc.constantFrom('Actros', 'Arocs', 'eActros', 'Atego'),
    specs: fc.dictionary(fc.string(), fc.string()),
    highlights: fc.array(fc.string()),
    imageUrl: fc.string(),
    priceEur: fc.option(fc.integer({ min: 10000, max: 500000 }), { nil: null }),
  }) as fc.Arbitrary<Product>;

  // Property: Sum of category counts equals total product count
  it('should have category counts sum equal to total products', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 0, maxLength: 50 }),
        (products) => {
          const categoryCounts = countByCategory(products);
          const sum = categoryCounts.reduce((acc, c) => acc + c.value, 0);
          expect(sum).toBe(products.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Sum of series counts equals total product count
  it('should have series counts sum equal to total products', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 0, maxLength: 50 }),
        (products) => {
          const seriesCounts = countBySeries(products);
          const sum = seriesCounts.reduce((acc, c) => acc + c.value, 0);
          expect(sum).toBe(products.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: getTotalCount returns array length
  it('should return correct total count', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 0, maxLength: 50 }),
        (products) => {
          expect(getTotalCount(products)).toBe(products.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Unique categories count <= total products
  it('should have unique categories count <= total products', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 0, maxLength: 50 }),
        (products) => {
          const uniqueCategories = getUniqueCategories(products);
          expect(uniqueCategories.length).toBeLessThanOrEqual(products.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Unique series count <= total products
  it('should have unique series count <= total products', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 0, maxLength: 50 }),
        (products) => {
          const uniqueSeries = getUniqueSeries(products);
          expect(uniqueSeries.length).toBeLessThanOrEqual(products.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Price range min <= avg <= max
  it('should have valid price range ordering', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 1, maxLength: 50 }),
        (products) => {
          const range = calculatePriceRange(products);
          if (range) {
            expect(range.min).toBeLessThanOrEqual(range.avg);
            expect(range.avg).toBeLessThanOrEqual(range.max);
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Empty products returns null price range
  it('should return null price range for products without prices', () => {
    const productsWithoutPrices: Product[] = [
      {
        id: 1,
        name: 'Test',
        shortDescription: '',
        description: '',
        longDescription: '',
        category: 'Fernverkehr',
        series: 'Actros',
        specs: {},
        highlights: [],
        imageUrl: '',
        priceEur: null,
      },
    ];
    expect(calculatePriceRange(productsWithoutPrices)).toBeNull();
  });

  // Property: Category counts are sorted descending by value
  it('should sort category counts in descending order', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 2, maxLength: 50 }),
        (products) => {
          const counts = countByCategory(products);
          for (let i = 1; i < counts.length; i++) {
            expect(counts[i - 1].value).toBeGreaterThanOrEqual(counts[i].value);
          }
        }
      ),
      { numRuns: 100 }
    );
  });
});
</file>

<file path="src/utils/aggregations.ts">
import type { Product } from '@/api';

export interface CategoryCount {
  name: string;
  value: number;
}

export interface SeriesCount {
  name: string;
  value: number;
}

export interface PriceRange {
  min: number;
  max: number;
  avg: number;
}

export function countByCategory(products: Product[]): CategoryCount[] {
  const counts = products.reduce((acc, product) => {
    acc[product.category] = (acc[product.category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  return Object.entries(counts)
    .map(([name, value]) => ({ name, value }))
    .sort((a, b) => b.value - a.value);
}

export function countBySeries(products: Product[]): SeriesCount[] {
  const counts = products.reduce((acc, product) => {
    acc[product.series] = (acc[product.series] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  return Object.entries(counts)
    .map(([name, value]) => ({ name, value }))
    .sort((a, b) => b.value - a.value);
}

export function countElectric(products: Product[]): number {
  return products.filter(
    (p) => p.category === 'Elektro' || p.name.toLowerCase().includes('eactros')
  ).length;
}

export function calculatePriceRange(products: Product[]): PriceRange | null {
  const prices = products
    .map((p) => p.priceEur)
    .filter((p): p is number => p !== null);

  if (prices.length === 0) return null;

  return {
    min: Math.min(...prices),
    max: Math.max(...prices),
    avg: prices.reduce((sum, p) => sum + p, 0) / prices.length,
  };
}

export function getTotalCount(products: Product[]): number {
  return products.length;
}

export function getUniqueCategories(products: Product[]): string[] {
  return [...new Set(products.map((p) => p.category))].sort();
}

export function getUniqueSeries(products: Product[]): string[] {
  return [...new Set(products.map((p) => p.series))].sort();
}
</file>

<file path="src/utils/cn.ts">
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/utils/errorMessages.test.ts">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { getErrorMessage, errorMessages, isKnownErrorCode } from './errorMessages';

/**
 * Property 9: Error Message Mapping
 * Validates: Requirements 15.1, 15.2, 15.3, 15.4, 15.5
 */
describe('Error Message Mapping', () => {
  const knownCodes = [400, 404, 413, 500, 502, 503];

  // Property: Known error codes always return their specific message
  it('should return specific message for known error codes', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...knownCodes),
        (code) => {
          const message = getErrorMessage(code);
          expect(message).toBe(errorMessages[code]);
          expect(message.length).toBeGreaterThan(0);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Unknown error codes always return fallback message
  it('should return fallback message for unknown error codes', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 100, max: 599 }).filter((n) => !knownCodes.includes(n)),
        (code) => {
          const message = getErrorMessage(code);
          expect(message).toBe(errorMessages[500]);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: isKnownErrorCode correctly identifies known codes
  it('should correctly identify known error codes', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 100, max: 599 }),
        (code) => {
          const isKnown = isKnownErrorCode(code);
          expect(isKnown).toBe(knownCodes.includes(code));
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: All error messages are non-empty German strings
  it('should have non-empty German messages for all known codes', () => {
    knownCodes.forEach((code) => {
      const message = errorMessages[code];
      expect(message).toBeDefined();
      expect(message.length).toBeGreaterThan(10);
      // German messages typically contain umlauts or specific words
      expect(message).toMatch(/[äöüßÄÖÜ]|Bitte|Fehler|nicht|ist/);
    });
  });

  // Property: getErrorMessage is deterministic
  it('should produce deterministic results', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 100, max: 599 }),
        (code) => {
          const result1 = getErrorMessage(code);
          const result2 = getErrorMessage(code);
          expect(result1).toBe(result2);
        }
      ),
      { numRuns: 100 }
    );
  });
});
</file>

<file path="src/utils/errorMessages.ts">
export type ErrorCode = 400 | 404 | 413 | 500 | 502 | 503;

export const errorMessages: Record<number, string> = {
  400: 'Ungültige Eingabe. Bitte überprüfen Sie Ihre Daten.',
  404: 'Die angeforderte Ressource wurde nicht gefunden.',
  413: 'Die Datei ist zu groß. Maximale Größe: 10MB.',
  500: 'Ein unerwarteter Fehler ist aufgetreten.',
  502: 'Der KI-Service ist momentan nicht erreichbar. Bitte versuchen Sie es später erneut.',
  503: 'Der Service ist vorübergehend nicht verfügbar.',
};

export function getErrorMessage(status: number): string {
  return errorMessages[status] || errorMessages[500];
}

export function isKnownErrorCode(status: number): boolean {
  return status in errorMessages;
}
</file>

<file path="src/utils/filters.test.ts">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { filterProducts, sortProducts, filterSkills, sortSkills } from './filters';
import type { Product, Skill } from '@/api';

/**
 * Property 5: Product Filtering and Sorting
 * Validates: Requirements 6.6, 6.11, 6.12
 */
describe('Product Filtering and Sorting', () => {
  const productArbitrary = fc.record({
    id: fc.integer({ min: 1, max: 1000 }),
    name: fc.string({ minLength: 1, maxLength: 50 }),
    shortDescription: fc.string({ minLength: 1, maxLength: 100 }),
    description: fc.string(),
    longDescription: fc.string(),
    category: fc.constantFrom('Fernverkehr', 'Verteiler', 'Bau', 'Elektro'),
    series: fc.constantFrom('Actros', 'Arocs', 'eActros', 'Atego'),
    specs: fc.dictionary(fc.string(), fc.string()),
    highlights: fc.array(fc.string()),
    imageUrl: fc.string(),
    priceEur: fc.option(fc.integer({ min: 10000, max: 500000 }), { nil: null }),
  }) as fc.Arbitrary<Product>;

  // Property: Filtering by category returns only products of that category
  it('should filter products by category correctly', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 1, maxLength: 20 }),
        fc.constantFrom('Fernverkehr', 'Verteiler', 'Bau', 'Elektro'),
        (products, category) => {
          const filtered = filterProducts(products, { category });
          filtered.forEach((product) => {
            expect(product.category).toBe(category);
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering by series returns only products of that series
  it('should filter products by series correctly', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 1, maxLength: 20 }),
        fc.constantFrom('Actros', 'Arocs', 'eActros', 'Atego'),
        (products, series) => {
          const filtered = filterProducts(products, { series });
          filtered.forEach((product) => {
            expect(product.series).toBe(series);
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Filtering never increases the number of products
  it('should never increase product count when filtering', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 0, maxLength: 20 }),
        fc.record({
          category: fc.option(fc.constantFrom('Fernverkehr', 'Verteiler', 'Bau', 'Elektro'), { nil: undefined }),
          series: fc.option(fc.constantFrom('Actros', 'Arocs', 'eActros', 'Atego'), { nil: undefined }),
          search: fc.option(fc.string({ maxLength: 20 }), { nil: undefined }),
        }),
        (products, filters) => {
          const filtered = filterProducts(products, filters);
          expect(filtered.length).toBeLessThanOrEqual(products.length);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Sorting preserves all elements
  it('should preserve all elements when sorting', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 0, maxLength: 20 }),
        fc.constantFrom('name', 'price', 'category', 'series') as fc.Arbitrary<'name' | 'price' | 'category' | 'series'>,
        fc.constantFrom('asc', 'desc') as fc.Arbitrary<'asc' | 'desc'>,
        (products, sortBy, direction) => {
          const sorted = sortProducts(products, sortBy, direction);
          expect(sorted.length).toBe(products.length);
          // All original IDs should be present
          const originalIds = products.map((p) => p.id).sort();
          const sortedIds = sorted.map((p) => p.id).sort();
          expect(sortedIds).toEqual(originalIds);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Sorting by name produces alphabetically ordered results
  it('should sort by name in correct order', () => {
    fc.assert(
      fc.property(
        fc.array(productArbitrary, { minLength: 2, maxLength: 20 }),
        fc.constantFrom('asc', 'desc') as fc.Arbitrary<'asc' | 'desc'>,
        (products, direction) => {
          const sorted = sortProducts(products, 'name', direction);
          for (let i = 1; i < sorted.length; i++) {
            const comparison = sorted[i - 1].name.localeCompare(sorted[i].name, 'de');
            if (direction === 'asc') {
              expect(comparison).toBeLessThanOrEqual(0);
            } else {
              expect(comparison).toBeGreaterThanOrEqual(0);
            }
          }
        }
      ),
      { numRuns: 100 }
    );
  });
});

describe('Skill Filtering and Sorting', () => {
  const skillArbitrary = fc.record({
    name: fc.string({ minLength: 1, maxLength: 30 }),
    category: fc.constantFrom('core', 'styles', 'formats'),
    content: fc.string(),
    dependencies: fc.array(fc.string()),
    priority: fc.integer({ min: 0, max: 100 }),
  }) as fc.Arbitrary<Skill>;

  // Property: Filtering skills by category returns only skills of that category
  it('should filter skills by category correctly', () => {
    fc.assert(
      fc.property(
        fc.array(skillArbitrary, { minLength: 1, maxLength: 20 }),
        fc.constantFrom('core', 'styles', 'formats'),
        (skills, category) => {
          const filtered = filterSkills(skills, category);
          filtered.forEach((skill) => {
            expect(skill.category).toBe(category);
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Sorting skills by priority produces ordered results
  it('should sort skills by priority in ascending order', () => {
    fc.assert(
      fc.property(
        fc.array(skillArbitrary, { minLength: 2, maxLength: 20 }),
        (skills) => {
          const sorted = sortSkills(skills);
          for (let i = 1; i < sorted.length; i++) {
            expect(sorted[i - 1].priority).toBeLessThanOrEqual(sorted[i].priority);
          }
        }
      ),
      { numRuns: 100 }
    );
  });
});
</file>

<file path="src/utils/filters.ts">
import type { Product, Skill, ExamplePrompt, LayoutStyle, PageFormat } from '@/api';

export type SortDirection = 'asc' | 'desc';

export interface ProductFilters {
  category?: string;
  series?: string;
  search?: string;
}

export function filterProducts(products: Product[], filters: ProductFilters): Product[] {
  return products.filter((product) => {
    if (filters.category && product.category !== filters.category) return false;
    if (filters.series && product.series !== filters.series) return false;
    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      const matchesName = product.name.toLowerCase().includes(searchLower);
      const matchesDescription = product.shortDescription.toLowerCase().includes(searchLower);
      if (!matchesName && !matchesDescription) return false;
    }
    return true;
  });
}

export function sortProducts(
  products: Product[],
  sortBy: 'name' | 'price' | 'category' | 'series',
  direction: SortDirection = 'asc'
): Product[] {
  const sorted = [...products].sort((a, b) => {
    let comparison = 0;
    switch (sortBy) {
      case 'name':
        comparison = a.name.localeCompare(b.name, 'de');
        break;
      case 'price':
        const priceA = a.priceEur ?? 0;
        const priceB = b.priceEur ?? 0;
        comparison = priceA - priceB;
        break;
      case 'category':
        comparison = a.category.localeCompare(b.category, 'de');
        break;
      case 'series':
        comparison = a.series.localeCompare(b.series, 'de');
        break;
    }
    return direction === 'asc' ? comparison : -comparison;
  });
  return sorted;
}

export function filterSkills(skills: Skill[], category?: string): Skill[] {
  if (!category || category === 'all') return skills;
  return skills.filter((skill) => skill.category === category);
}

export function sortSkills(skills: Skill[]): Skill[] {
  return [...skills].sort((a, b) => a.priority - b.priority);
}

export function filterPrompts(
  prompts: ExamplePrompt[],
  style?: LayoutStyle | 'all',
  format?: PageFormat | 'all'
): ExamplePrompt[] {
  return prompts.filter((prompt) => {
    if (style && style !== 'all' && prompt.style !== style) return false;
    if (format && format !== 'all' && prompt.format !== format) return false;
    return true;
  });
}

export function groupProductsByCategory(products: Product[]): Record<string, Product[]> {
  return products.reduce((acc, product) => {
    if (!acc[product.category]) {
      acc[product.category] = [];
    }
    acc[product.category].push(product);
    return acc;
  }, {} as Record<string, Product[]>);
}

export function groupProductsBySeries(products: Product[]): Record<string, Product[]> {
  return products.reduce((acc, product) => {
    if (!acc[product.series]) {
      acc[product.series] = [];
    }
    acc[product.series].push(product);
    return acc;
  }, {} as Record<string, Product[]>);
}
</file>

<file path="src/utils/formatters.ts">
export function formatPrice(price: number | null): string {
  if (price === null) return 'Preis auf Anfrage';
  return new Intl.NumberFormat('de-DE', {
    style: 'currency',
    currency: 'EUR',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(price);
}

export function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('de-DE', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  }).format(date);
}

export function formatTime(dateString: string): string {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('de-DE', {
    hour: '2-digit',
    minute: '2-digit',
  }).format(date);
}

export function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  return `${(ms / 1000).toFixed(1)}s`;
}

export function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - 3) + '...';
}
</file>

<file path="src/utils/index.ts">
export { cn } from './cn';
export * from './formatters';
export * from './validators';
export * from './filters';
export * from './errorMessages';
export * from './pageFormats';
export * from './aggregations';
</file>

<file path="src/utils/pageFormats.test.ts">
import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import type { PageFormat } from '@/api';
import {
  pageFormatDimensions,
  pageFormats,
  getPageDimensions,
  getAspectRatio,
  isPortrait,
  isLandscape,
  isSquare,
} from './pageFormats';

/**
 * Property 11: Page Format Dimensions
 * Validates: Requirements 11.2
 */
describe('Page Format Dimensions', () => {
  // Property: All page formats have positive dimensions
  it('should have positive dimensions for all formats', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...pageFormats),
        (format: PageFormat) => {
          const dims = getPageDimensions(format);
          expect(dims.width).toBeGreaterThan(0);
          expect(dims.height).toBeGreaterThan(0);
          expect(dims.unit).toBe('mm');
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Aspect ratio is always positive
  it('should have positive aspect ratio for all formats', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...pageFormats),
        (format: PageFormat) => {
          const ratio = getAspectRatio(format);
          expect(ratio).toBeGreaterThan(0);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Portrait, landscape, and square are mutually exclusive
  it('should have mutually exclusive orientation classifications', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...pageFormats),
        (format: PageFormat) => {
          const portrait = isPortrait(format);
          const landscape = isLandscape(format);
          const square = isSquare(format);
          
          // Exactly one should be true
          const trueCount = [portrait, landscape, square].filter(Boolean).length;
          expect(trueCount).toBe(1);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: Square format has equal width and height
  it('should have equal dimensions for square format', () => {
    const dims = getPageDimensions('SQUARE');
    expect(dims.width).toBe(dims.height);
    expect(isSquare('SQUARE')).toBe(true);
  });

  // Property: A-series formats follow ISO 216 ratios (approximately 1:√2)
  it('should have correct A-series aspect ratios', () => {
    const sqrt2 = Math.SQRT2;
    const tolerance = 0.01;

    ['A4', 'A5', 'A6'].forEach((format) => {
      const dims = getPageDimensions(format as PageFormat);
      const ratio = dims.height / dims.width;
      expect(Math.abs(ratio - sqrt2)).toBeLessThan(tolerance);
    });
  });

  // Property: All formats have a label defined
  it('should have labels for all formats', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...pageFormats),
        (format: PageFormat) => {
          const dims = getPageDimensions(format);
          expect(dims.label).toBeDefined();
          expect(dims.label.length).toBeGreaterThan(0);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Property: getPageDimensions is deterministic
  it('should return consistent dimensions', () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...pageFormats),
        (format: PageFormat) => {
          const dims1 = getPageDimensions(format);
          const dims2 = getPageDimensions(format);
          expect(dims1).toEqual(dims2);
        }
      ),
      { numRuns: 100 }
    );
  });

  // Verify specific known dimensions
  it('should have correct specific dimensions', () => {
    expect(pageFormatDimensions.A4).toEqual({
      width: 210,
      height: 297,
      unit: 'mm',
      label: 'A4 (210×297mm)',
    });
    expect(pageFormatDimensions.DL).toEqual({
      width: 99,
      height: 210,
      unit: 'mm',
      label: 'DL (99×210mm)',
    });
  });
});
</file>

<file path="src/utils/pageFormats.ts">
import type { PageFormat } from '@/api';

export interface PageDimensions {
  width: number;
  height: number;
  unit: 'mm';
  label: string;
}

export const pageFormatDimensions: Record<PageFormat, PageDimensions> = {
  A4: { width: 210, height: 297, unit: 'mm', label: 'A4 (210×297mm)' },
  A5: { width: 148, height: 210, unit: 'mm', label: 'A5 (148×210mm)' },
  A6: { width: 105, height: 148, unit: 'mm', label: 'A6 (105×148mm)' },
  DL: { width: 99, height: 210, unit: 'mm', label: 'DL (99×210mm)' },
  SQUARE: { width: 210, height: 210, unit: 'mm', label: 'Quadrat (210×210mm)' },
};

export const pageFormats: PageFormat[] = ['A4', 'A5', 'A6', 'DL', 'SQUARE'];

export function getPageDimensions(format: PageFormat): PageDimensions {
  return pageFormatDimensions[format];
}

export function getAspectRatio(format: PageFormat): number {
  const dims = pageFormatDimensions[format];
  return dims.width / dims.height;
}

export function isPortrait(format: PageFormat): boolean {
  const dims = pageFormatDimensions[format];
  return dims.height > dims.width;
}

export function isLandscape(format: PageFormat): boolean {
  const dims = pageFormatDimensions[format];
  return dims.width > dims.height;
}

export function isSquare(format: PageFormat): boolean {
  const dims = pageFormatDimensions[format];
  return dims.width === dims.height;
}
</file>

<file path="src/utils/validators.ts">
export const MAX_PROMPT_LENGTH = 5000;
export const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
export const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp'];

export function validatePromptLength(prompt: string): { valid: boolean; message?: string } {
  if (prompt.length === 0) {
    return { valid: false, message: 'Bitte geben Sie einen Prompt ein.' };
  }
  if (prompt.length > MAX_PROMPT_LENGTH) {
    return { valid: false, message: `Prompt darf maximal ${MAX_PROMPT_LENGTH} Zeichen haben.` };
  }
  return { valid: true };
}

export function validateFileSize(file: File): { valid: boolean; message?: string } {
  if (file.size > MAX_FILE_SIZE) {
    return { valid: false, message: 'Die Datei ist zu groß. Maximale Größe: 10MB.' };
  }
  return { valid: true };
}

export function validateImageType(file: File): { valid: boolean; message?: string } {
  if (!ALLOWED_IMAGE_TYPES.includes(file.type)) {
    return { valid: false, message: 'Nur JPG, PNG und WebP Dateien sind erlaubt.' };
  }
  return { valid: true };
}

export function validateImage(file: File): { valid: boolean; message?: string } {
  const typeValidation = validateImageType(file);
  if (!typeValidation.valid) return typeValidation;
  
  const sizeValidation = validateFileSize(file);
  if (!sizeValidation.valid) return sizeValidation;
  
  return { valid: true };
}

export function getPromptCharacterCount(prompt: string): {
  current: number;
  max: number;
  remaining: number;
  isOverLimit: boolean;
} {
  return {
    current: prompt.length,
    max: MAX_PROMPT_LENGTH,
    remaining: MAX_PROMPT_LENGTH - prompt.length,
    isOverLimit: prompt.length > MAX_PROMPT_LENGTH,
  };
}
</file>

<file path="src/App.tsx">
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AppLayout } from '@/components/layout';
import { ToastProvider, Spinner } from '@/components/ui';
import { ErrorBoundary } from '@/components/ErrorBoundary';

// Lazy load pages for code splitting
const DashboardPage = lazy(() => import('@/pages/Dashboard/DashboardPage').then(m => ({ default: m.DashboardPage })));
const SkillExplorerPage = lazy(() => import('@/pages/SkillExplorer/SkillExplorerPage').then(m => ({ default: m.SkillExplorerPage })));
const PromptExplorerPage = lazy(() => import('@/pages/PromptExplorer/PromptExplorerPage').then(m => ({ default: m.PromptExplorerPage })));
const CatalogWizardPage = lazy(() => import('@/pages/CatalogWizard/CatalogWizardPage').then(m => ({ default: m.CatalogWizardPage })));
const CatalogPreviewPage = lazy(() => import('@/pages/CatalogPreview/CatalogPreviewPage').then(m => ({ default: m.CatalogPreviewPage })));

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 Minuten
      retry: 1,
    },
  },
});

function PageLoader() {
  return (
    <div className="flex items-center justify-center min-h-[50vh]">
      <Spinner size="lg" />
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <ToastProvider>
          <BrowserRouter>
            <Suspense fallback={<PageLoader />}>
              <Routes>
                <Route element={<AppLayout />}>
                  <Route path="/" element={<DashboardPage />} />
                  <Route path="/skills" element={<SkillExplorerPage />} />
                  <Route path="/prompts" element={<PromptExplorerPage />} />
                  <Route path="/wizard" element={<CatalogWizardPage />} />
                  <Route path="/preview/:id" element={<CatalogPreviewPage />} />
                  <Route path="*" element={<Navigate to="/" replace />} />
                </Route>
              </Routes>
            </Suspense>
          </BrowserRouter>
        </ToastProvider>
      </QueryClientProvider>
    </ErrorBoundary>
  );
}

export default App;
</file>

<file path="src/main.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './styles/globals.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</file>

<file path=".env.example">
# API Configuration
VITE_API_URL=http://localhost:8080/api/v1
</file>

<file path=".gitignore">
# Dependencies
node_modules

# Build
dist
dist-ssr
*.local

# Editor
.vscode/*
!.vscode/extensions.json
.idea

# Logs
logs
*.log
npm-debug.log*

# Environment
.env
.env.local
.env.*.local

# Testing
coverage

# OS
.DS_Store
Thumbs.db
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <title>CatalogForge</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "catforge-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.22.0",
    "@tanstack/react-query": "^5.24.0",
    "zustand": "^4.5.0",
    "recharts": "^2.12.0",
    "react-hook-form": "^7.50.0",
    "react-markdown": "^9.0.1",
    "lucide-react": "^0.330.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.55",
    "@types/react-dom": "^18.2.19",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.17",
    "eslint": "^8.56.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.3.3",
    "vite": "^5.1.0",
    "vitest": "^1.3.0",
    "@testing-library/react": "^14.2.0",
    "@testing-library/jest-dom": "^6.4.0",
    "jsdom": "^24.0.0",
    "fast-check": "^3.15.0",
    "@types/node": "^20.11.0"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {
      colors: {
        pastel: {
          blue: {
            DEFAULT: '#A8D5E5',
            dark: '#7BC0D4',
            light: '#D4EAF2',
          },
          green: {
            DEFAULT: '#B5E5CF',
            dark: '#8AD4B5',
            light: '#DAF2E7',
          },
          purple: {
            DEFAULT: '#D4B5E5',
            dark: '#B98AD4',
            light: '#E9DAF2',
          },
          yellow: {
            DEFAULT: '#F5E6A3',
            dark: '#E8D47A',
            light: '#FAF3D1',
          },
          red: {
            DEFAULT: '#E5B5B5',
            dark: '#D48A8A',
            light: '#F2DADA',
          },
          orange: {
            DEFAULT: '#E5CDB5',
            dark: '#D4B08A',
            light: '#F2E6DA',
          },
        },
        sidebar: '#F0F7FA',
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
      },
      boxShadow: {
        card: '0 1px 3px 0 rgb(0 0 0 / 0.05), 0 1px 2px -1px rgb(0 0 0 / 0.05)',
        'card-hover': '0 4px 6px -1px rgb(0 0 0 / 0.07), 0 2px 4px -2px rgb(0 0 0 / 0.07)',
      },
    },
  },
  plugins: [],
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts", "vitest.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
      },
    },
  },
});
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    include: ['src/**/*.{test,spec}.{js,ts,jsx,tsx}'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: ['node_modules/', 'src/test/'],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
</file>

</files>
